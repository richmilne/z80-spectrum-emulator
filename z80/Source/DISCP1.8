DISCIP segment byte public
      
        org     0


NotAvailable:
        ret



;*************************** DISCiPLEIn ***********************************

DISCiPLEIn      proc

;**************************************************************************
;
;       ENTRY:  BL=in address
;
;       EXIT:   relevant routine called
;
;**************************************************************************
        cmp byte es:disc_on,0ff         ; DISCiPLE connected?
        jne DISCiPLEInRet               ; jump if not
        cmp bl,01b                      ; get status reg
        if z jmp DISCiPLEIn27
        cmp bl,05b                      ; get track number
        if z jmp DISCiPLEIn91
        cmp bl,09b                      ; get sector number
        if z jmp DISCiPLEIn155
        cmp bl,0db                      ; get data
        if z jmp DISCiPLEIn219

DISCiPLEInRet:
        mov ah,0ffh
        mov bh,ah
        retf

DISCiPLEIn      endp

;********************** END OF PROCEDURE DISCiPLEIn ***********************




;*************************** DISCiPLEOut **********************************

DISCiPLEOut     proc

;**************************************************************************
;
;       ENTRY:  BL=out address
;
;       EXIT:   relevant routine called
;
;**************************************************************************
        cmp byte es:disc_on,0ff         ; DISCiPLE connected?
        jne DISCiPLEOutRet              ; jump if not
        cmp bl,01b                      ; send command
        if z jmp DISCiPLEOut27
        cmp bl,05b                      ; set track number
        if z jmp DISCiPLEOut91
        cmp bl,09b                      ; set sector number
        if z jmp DISCiPLEOut155
        cmp bl,0db                      ; send data
        if z jmp DISCiPLEOut219

DISCiPLEOutRet:
        retf

DISCiPLEOut     endp

;********************** END OF PROCEDURE DISCiPLEOut **********************




;*************************** PLUSDIn **************************************

PLUSDIn         proc

;**************************************************************************
;
;       ENTRY:  BL=in address
;
;       EXIT:   relevant routine called
;
;**************************************************************************
        cmp byte es:disc_on,0ff         ; PLUS D connected?
        jne PLUSDInRet                  ; jump if not
        cmp bl,0e3                      ; get status reg
        if z jmp DISCiPLEIn27
        cmp bl,0eb                      ; get track number
        if z jmp DISCiPLEIn91
        cmp bl,0f3                      ; get sector number
        if z jmp DISCiPLEIn155
        cmp bl,0fb                      ; get data
        if z jmp DISCiPLEIn219

PLUSDInRet:
        mov ah,0ffh
        mov bh,ah
        retf

PLUSDIn         endp

;********************** END OF PROCEDURE PLUSDIn **************************




;*************************** PLUSDOut *************************************

PLUSDOut        proc

;**************************************************************************
;
;       ENTRY:  BL=out address
;
;       EXIT:   relevant routine called
;
;**************************************************************************
        cmp byte es:disc_on,0ff         ; DISCiPLE connected?
        jne PLUSDOutRet                 ; jump if not
        cmp bl,0e3                      ; send command
        if z jmp DISCiPLEOut27
        cmp bl,0eb                      ; set track number
        if z jmp DISCiPLEOut91
        cmp bl,0f3                      ; set sector number
        if z jmp DISCiPLEOut155
        cmp bl,0fb                      ; send data
        if z jmp DISCiPLEOut219

PLUSDOutRet:
        retf

PLUSDOut        endp

;********************** END OF PROCEDURE PLUSDOut *************************




;*************************** PLUSDIn247 ***********************************

PLUSDIn247      proc

;**************************************************************************
;
;       ENTRY:  none
;
;       EXIT:   BH=AH=bit 7 = busy bit of printer
;
;**************************************************************************

;        push    ax
;        push    dx
;        mov     ah,2                    ; get printer status
;        mov     dx,es:zxprint           ; printer 0
;        int     017                     ; PRINTER SERVICES
;        and     ah,128
;        xor     ah,128
;        mov     bh,ah
;        pop     dx
;        pop     ax
;        mov     ah,bh
;        retf

        mov ah,byte es:[offset dtr]     ;get status of RS232 output
        and ah,128                      ; channel (GL)
        retf

PLUSDIn247      endp

;********************** END OF PROCEDURE PLUSDIn247 ***********************





;*************************** DISCiPLEIn27 *********************************

DISCiPLEIn27    proc

;**************************************************************************
;
;       ENTRY:  none
;
;       EXIT:   BH=AH=status of disk controller
;
;**************************************************************************
        push    di
        push    ax
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        test    byte ptr cs:[di],128            ; command offset
        jz      DISCiPLEIn27Type1               ; jump if it is TYPE 1
        mov     al,byte ptr cs:[di]
        and     al,11110000b                    ; is it force
        cmp     al,11010000b                    ; interrupt?
        jne     DISCiPLEIn27PType2rw            ; jump if it is not

DISCiPLEIn27Type1:
        cmp     byte ptr cs:[di+TrackOff],0     ; track 0?
        if ne  jmp DISCiPLEIn27P1               ; jump if not
        or      byte ptr cs:[di+StatusOff],4    ; signal track 0
        jmp     DISCiPLEIn27P1

DISCiPLEIN27PType2RW:                           ; read/write type
        cmp     word ptr cs:[DISCiPLEDataLength],0    ; 0 bytes to read/write
        je      DISCiPLEIn27P1
        or      byte ptr cs:[di+StatusOff],10100011b
        jmp     DISCiPLEIn27Pret                  ; jump to return value

DISCiPLEIn27Err:
        or      byte ptr cs:[di+StatusOff],16   ; error
        jmp     DISCiPLEIn27P1

DISCiPLEIn27P0:
        and     byte ptr cs:[di+StatusOff],253  ; remove IP

DISCiPLEIn27P1:
        and     byte ptr cs:[di+StatusOff],253  ; remove IP
        cmp     byte ptr cs:[DISCiPLEAllowIP],0ff
        jne     DISCiPLEIN27P
        inc     word ptr cs:[DISCiPLEIPCnt]
        cmp     word ptr cs:[DISCiPLEIPCnt],200   ; index pulse due?
        jne     DISCiPLEIn27PRet

DISCiPLEIn27P:
        or      byte ptr cs:[di+StatusOff],2

DISCiPLEIn27P10:
        mov     ax,0
        mov     word ptr cs:[DISCiPLEIPCnt],ax

DISCiPLEIn27PRet:
        pop     ax
        mov     ah,byte ptr cs:[di+StatusOff]   ; get status
        mov     bh,ah
        pop     di
        retf

DISCiPLEIpCnt:
        dw      0

DISCiPLEAllowIP:
        db      0ff


DISCiPLEIn27    endp

;********************** END OF PROCEDURE DISCiPLEIn27 *********************



;*************************** DISCiPLEIn91 *********************************

DISCiPLEIn91    proc

;**************************************************************************
;
;       ENTRY:  none
;
;       EXIT:   BH=AH=Track register value
;
;**************************************************************************
        push    di
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     ah,byte ptr cs:[di+TrackOff]    ; get status
        mov     bh,ah
        pop     di
        retf

DISCiPLEIn91    endp

;********************** END OF PROCEDURE DISCiPLEIn91 *********************



;*************************** DISCiPLEIn155 ********************************

DISCiPLEIn155   proc

;**************************************************************************
;
;       ENTRY:  none
;
;       EXIT:   BH=AH=sector register value
;
;**************************************************************************
        push    di
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     ah,byte ptr cs:[di+SectorOff]   ; get sector register
        mov     bh,ah
        pop     di
        retf

DISCiPLEIn155   endp

;********************** END OF PROCEDURE DISCiPLEIn155 ********************




;*************************** DISCiPLEIn219 ********************************

DISCiPLEIn219   proc

;**************************************************************************
;
;       ENTRY:  none
;
;       EXIT:   AH=byte read
;
;**************************************************************************
        push    di
        push    bx
        mov     ah,0ff
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        cmp     word ptr cs:[DISCiPLEDataLength],0      ; 0 bytes left?
        je      DISCiPLEIn219Err                        ; jump if it is
        mov     bx,word ptr cs:[DISCiPLEDataAddress]
        mov     ah,byte ptr cs:[bx]                     ; read byte
        inc     word ptr cs:[DISCiPLEDataAddress],bx    ; next byte position
        dec     word ptr cs:[DISCiPLEDataLength]        ; 1 byte less to read
        mov     byte ptr cs:[di+StatusOff],0            ; signal all clear
        jmp     DISCiPLEIn219Ret                        ; jump to return

DISCiPLEIn219Err:
        mov     byte ptr cs:[di+StatusOff],16           ; signal error
        mov     ah,0

DISCiPLEIn219Ret:
        pop     bx
        pop     di
        mov     bh,ah
        retf

DISCiPLEIn219   endp

;********************** END OF PROCEDURE DISCiPLEIn219 ********************




;*************************** DISCiPLEOut27 ********************************

DISCiPLEOut27   proc

;**************************************************************************
;
;       ENTRY:  AH=command
;
;       EXIT:
;
;**************************************************************************
        push    di
        call    DISCiPLEDiskCommand
        pop     di
        retf

DISCiPLEOut27   endp

;********************** END OF PROCEDURE DISCiPLEOut27 ********************




;*************************** DISCiPLEOut91 ********************************

DISCiPLEOut91   proc

;**************************************************************************
;
;       ENTRY: AH=byte to output (TRACK REG.)
;
;       EXIT:
;
;**************************************************************************
        push    di
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     byte ptr cs:[di+Trackoff],ah
        pop     di
        retf

DISCiPLEOut91   endp

;********************** END OF PROCEDURE DISCiPLEOut91 ********************




;*************************** DISCiPLEOut155 *******************************

DISCiPLEOut155  proc

;**************************************************************************
;
;       ENTRY:  AH=byte to output (SECTOR REG.)
;
;       EXIT:
;
;**************************************************************************
        push    di
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     byte ptr cs:[di+SectorOff],ah
        pop     di
        retf

DISCiPLEOut155  endp

;********************** END OF PROCEDURE DISCiPLEOut155 *******************




;*************************** DISCiPLEOut219 *******************************

DISCiPLEOut219  proc

;**************************************************************************
;
;       ENTRY:  AH=byte to write
;
;       EXIT:   byte written to sector buffer and pointers updated
;
;**************************************************************************
        push    di
        push    ax
        push    bx
        push    cx
        push    dx
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     al,byte ptr cs:[di]                     ; get command
        and     al,11100000b                            ; keep top 3 bits
        cmp     al,10100000b                            ; is it writesec?
        if e jmp DISCiPLEOut219WriteSec                  ; jump if it is

DISCiPLEOut219ReadWriteTrack:
        mov     al,byte ptr cs:[di]                     ; get command
        test    al,16                                   ; read or write?
        if e jmp DISCiPLEOut219Ok                       ; read not ready *******
        mov     al,0
        mov     byte ptr cs:[DISCiPLEAllowIP],al        ; don't allow Index pulse

        cmp     byte ptr cs:[DISCiPLEFormMode],0ff      ; sector ID?
        if ne jmp DISCiPLEOut219WriteGap                ; jump if not
        push    bx
        mov     bx,word ptr cs:[DISCiPLEDataAddress]    ; get address to write to
        mov     byte ptr cs:[bx],ah                     ; save byte
        inc     word ptr cs:[DISCiPLEDataAddress]       ; point to next byte
        inc     word ptr cs:[DISCiPLEFormTot]           ; 1 more byte written
        dec     byte ptr cs:[DISCiPLEIDLen]             ; 1 less ID byte
        jne     DISCiPLEOut219Write1                    ; jump if more ID bytes
        mov     al,0
        mov     byte ptr cs:[DISCiPLEFormMode],al       ; signal gap!
        push    cx
        mov     bx,128
        mov     cl,ah
        shl     bx,cl
        inc     bx
        mov     word ptr cs:[DISCiPLEFormSkip],bx       ; bx=sector length
        pop     cx

DISCiPLEOut219Write1:
        pop     bx
        jmp     DISCiPLEOut219Ok

DISCiPLEOut219WriteGap:
        cmp     word ptr cs:[DISCiPLEFormSkip],0
        je      DISCiPLEOut219WriteGap1
        cmp     byte ptr cs:[DISCiPLEA1Cnt],6
        jne     DISCiPLEOut219WriteGap1
        inc     word ptr cs:[DISCiPLEFormTot]
        dec     word ptr cs:[DISCiPLEFormSkip]
        if ne jmp DISCiPLEOut219Ok
        mov     al,0
        mov     byte ptr cs:[DISCiPLEA1Cnt],al
        jmp     DISCiPLEOut219Ok

DISCiPLEOut219WriteGap1:
        cmp     ah,0f5                                  ; write A1?
        jne     DISCiPLEOut219WriteGap2
        inc     byte ptr cs:[DISCiPLEA1Cnt]
        inc     word ptr cs:[DISCiPLEFormTot]
        jmp     DISCiPLEOut219Ok

DISCiPLEOut219WriteGap2:
        cmp     ah,0fe                                  ; Sector ID?
        jne     DISCiPLEOut219WriteGap3
        cmp     byte ptr cs:[DISCiPLEA1Cnt],3           ; sector ID?
        jne     DISCiPLEOut219WriteGap3
        mov     al,0ff
        mov     byte ptr cs:[DISCiPLEFormMode],al
        inc     word ptr cs:[DISCiPLEFormTot]
        mov     al,4
        mov     byte ptr cs:[DISCiPLEIDLen],al
        jmp     DISCiPLEOut219Ok

DISCiPLEOut219WriteGap3:
        inc     word ptr cs:[DISCiPLEFormTot]
        cmp     word ptr cs:[DISCiPLEFormTot],6101
        if c jmp DISCiPLEOut219Ok
        mov     al,0ff
        mov     byte ptr cs:[DISCiPLEAllowIP],al        ; allow IP

DISCiPLEOut219WriteFormat:                              ; ****************
        mov byte cs:[offset disciplebufftrk],0ff        ;GL
        push    bx
        push    cx
        push    dx
        push    es
        push    ds
        push    di
        call    SetInt01E
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     ch,byte ptr cs:[di+TrackOff]
        xor     cl,cl
        mov     dh,byte ptr cs:[di+SideSelOff]
        mov     dl,byte ptr cs:[di+DriveOff]
        mov     ax,cs
        mov     es,ax                            
        mov     bx,offset DISCiPLEBuffer+5120
        mov     ax,0501                                 ; format
        int     013
        call    ResetInt01E
        pop     di
        pop     ds
        pop     es
        pop     dx
        pop     cx
        pop     bx
        jmp     DISCiPLEOut219Ok

DISCiPLEOut219WriteSec:
        cmp     word ptr cs:[DISCiPLEDataLength],0      ; 0 bytes to write
        if e jmp DISCiPLEOut219Err                      ; signal error
        mov     bx,word ptr cs:[DISCiPLEDataAddress]    ; get write address
        mov     byte ptr cs:[bx],ah                     ; write byte
        inc     word ptr cs:[DISCiPLEDataAddress]       ; point to next locn.
        dec     word ptr cs:[DISCiPLEDataLength]        ; 1 byte less to write
        cmp     word ptr cs:[DISCiPLEDataLength],0      ; 0 bytes to write
        if ne jmp DISCiPLEOut219Ok                      ; jump if not
        mov byte cs:disciplebufftrk,0ff                 ; buffered track invalid (GL)

DISCiPLEOut219Write:
        mov     bx,TypeOff
        cmp     byte ptr cs:[di+bx],1                   ; is it a file?
        if e jmp DISCiPLEOut219WriteFile                ; jump if it is

DISCiPLEOut219WriteDisk:
        push    es
        mov     ax,cs
        mov     es,ax
        mov     cx,3                                    ; 3 tries to write

DISCiPLEWriteDisk0:
        push    cx
        mov     bx,offset DISCiPLEBuffer                ; ES:BX write address
        mov     ah,03                                   ; write sector
        mov     al,1                                    ; 1 sector
        mov     ch,byte ptr cs:[di+TrackOff]            ; CH=track
        mov     cl,byte ptr cs:[di+SectorOff]           ; CL=sector
        mov     dh,byte ptr cs:[di+SideSelOff]          ; DH=side
        mov     dl,byte ptr cs:[di+DriveOff]            ; DL=drive
        int     013                                     ; DISK SERVICES
        pop     cx
        jnc     DISCiPLEOut219WriteDisk1                ; jump if no errors
        loop    DISCiPLEOut219WriteDisk0                ; jump if there are
        pop     es
        jmp     DISCiPLEOut219Err                       ; signal write error

DISCiPLEOut219WriteDisk1:
        pop     es
        jmp     DISCiPLEOut219Ok                        ; jump if all ok

DISCiPLEOut219WriteFile:
        jmp     DISCiPLEOut219Ret                       ; not ready *********

DISCiPLEOut219Ok:
        mov     byte ptr cs:[di+StatusOff],0            ; signal ok
        jmp     DISCiPLEOut219Ret                       ; return

DISCiPLEOut219Err:
        test    ah,2                                    ; write protected     
        jz      DISCiPLEOut219Err2                      ; jump if not
        mov     byte ptr cs:[di+StatusOff],64

DISCiPLEOut219Err2:
        or      byte ptr cs:[di+StatusOff],16           ; signal error

DISCiPLEOut219Ret:
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        pop     di
        retf

DISCiPLEFormTot:
        dw      0               ; total count of bytes sent during format

DISCiPLEFormSecs:
        db      0               ; total sectors to format

DISCiPLEFormMode:
        db      0               ; 0=gaps or data, 0ff=sector ID

DISCiPLEFormSkip:       
        dw      0               ; holds bytes to skip for data

DISCiPLESecSize:
        db      0               ; 0-128,1-256,2-512,3-1024,4-2048,5-4096

DISCiPLEA1Cnt:
        db      0

DISCiPLEOldInt1e:
        dd      0               ; old int 1e

DISCiPLEIDLen:
        db      0

DISCiPLENewInt1e:
        db      0df,02,025,02,0a,010,0ff,014,0,0f,8,0

DISCiPLEOut219  endp

;********************** END OF PROCEDURE DISCiPLEOut219 *******************




;*************************** DISCiPLEOut31 ********************************

DISCiPLEOut31   proc

;**************************************************************************
;
;       ENTRY:  AH=byte to output
;
;       EXIT:
;
;**************************************************************************
        push    di
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        push    ax
        mov     al,0
        mov     byte ptr cs:[di+SideSelOff],al
        and     ah,2                       ; keep side select
        cmp     ah,2                       ; side 1?
        jne     DISCiPLEOut31L
        xor     byte ptr cs:[di+SideSelOff],1 ; change side

DISCiPLEOut31L:
        pop     ax
        push    ax
        and     ah,1                    ; keep drive select
        xor     ah,1
        inc     ah
        mov     byte ptr cs:[DISCiPLEDiskNo],ah ; store disk number
        cmp     ah,1                    ; drive 1?
        jne     DISCiPLEOut31L1
        mov     ax,offset L1772D1Command
        jmp     DISCiPLEOut31L2


DISCiPLEOut31L1:
        mov     ax,offset L1772D2Command

DISCiPLEOut31L2:
        mov     word ptr cs:[DISCiPLEDiskBase],ax       ; store base address
        pop     ax                                      ; restore data byte
        push    ax                                      ; store data byte
        cmp     byte ptr es:_disctype,16                ; DISCiPLE hardware?
        jnc     DISCiPLEOut31Ret                        ; jump if not
        cmp     byte ptr es:_discinhibit,0              ; INHIBIT button in? GL mod
        je      DISCiPLEOut31Ret                        ; jump if not. GL mod
        test    ah,16                                   ; inhibit status
        jnz     DISCiPLEOut31RomEnable                  ; enable ROM paging
        mov     ah,0ff                                  ; disable ROM paging
        jmp     DISCiPLEOut31Rom

DISCiPLEOut31RomEnable:
        mov     ah,0

DISCiPLEOut31Rom:
        mov     byte ptr es:_discinhibitflg,ah          ; set ROM page flag


DISCiPLEOut31Ret:
        pop     ax
        pop     di
        retf

DISCiPLEOut31   endp

;********************** END OF PROCEDURE DISCiPLEOut31 ********************




;*************************** PLUSDOut239 **********************************

PLUSDOut239     proc

;**************************************************************************
;
;       ENTRY:  AH=byte to output
;
;       EXIT:
;
;**************************************************************************
        push    di
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        push    ax
        mov     al,0
        mov     byte ptr cs:[di+SideSelOff],al
        and     ah,128                    ; keep side select
        cmp     ah,128                    ; side 1?
        jne     PLUSDOut239L
        xor     byte ptr cs:[di+SideSelOff],1 ; change side

PLUSDOut239L:
        pop     ax
        push    ax
        and     ah,3                    ; get drive select
        mov     byte ptr cs:[DISCiPLEDiskNo],ah ; store disk number
        cmp     ah,1                    ; drive 1?
        jne     PLUSDOut239L1
        mov     ax,offset L1772D1Command
        jmp     PLUSDOut239L2


PLUSDOut239L1:
        mov     ax,offset L1772D2Command

PLUSDOut239L2:
        mov     word ptr cs:[DISCiPLEDiskBase],ax       ; store base address
        pop     ax
        pop     di
        retf

PLUSDOut239     endp

;********************** END OF PROCEDURE PLUSDOut239 **********************




;*********************** Create DISCiPLE Disk *****************************

CreateDISCiPLEDisk  proc

;**************************************************************************
;       ENTRY:  DS:SI=Filename to create DISK image in
;
;       EXIT:   Carry = Clear if created
;               Carry = Set if error
;**************************************************************************

        push    ax
        push    bx
        push    cx
        push    dx
        push    di
        mov     ah,05bh                         ; Create File
        mov     cx,0                            ; normal attributes
        mov     dx,si                           ; filename at DS:DX
        int     21h                             ; DOS CALL
        jc      CreateDISCDRet                  ; Jump if error occurred
        mov     word ptr cs:[CreateDISCDHan],ax ; Store file handle
        mov     bx,ax                           ; BX=file handle
        push    ds                              ; store data segment
        mov     ax,cs                           ; AX=code segment
        mov     ds,ax                           ; DS=code segment
        push    bx                              ; store file handle
        mov     ah,40h                          ; Write to file
        mov     cx,32                           ; length of 32 bytes
        mov     dx,offset CreateDISCDBlan       ; address
        int     21h                             ; DOS CALL
        jc      CreateDISCWrErr1                ; Jump if write error
        pop     bx                              ; recall file handle to BX
        mov     ah,040h                         ; write to file
        push    bx                              ; store file handle
        push    ax                              ; store command
        mov     dx,offset DISCiPLEBuffer        ; DX = offset of buffer
        mov     cx,1018                         ; CX = bytes to write
        int     21h                             ; DOS CALL
        jc      CreateDISCWrErr2                ; Jump if write error
        pop     ax                              ; AX = command
        pop     bx                              ; BX = file handle
        pop     ds                              ; restore data segment

CreateDISCDClose:
        mov     ah,03eh                         ; Close file
        mov     bx,word ptr cs:[CreateDISCDHan] ; BX = file handle
        int     21h                             ; DOS CALL

CreateDISCDret:
        pop     di
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret

CreateDISCWrErr1:
        pop     bx                              ; restore file handle
        pop     ds                              ; restore data segment
        jmp     CreateDISCWrErrRet

CreateDISCWrErr2:
        pop     cx                              ; restore no. of blocks
        pop     ax                              ; restore command
        pop     bx                              ; restore file handle
        pop     ds                              ; restore data segment

CreateDISCWrErrRet:
        push    bx                              ; store file handle
        mov     ah,03eh                         ; Close file
        int     21h                             ; DOS CALL
        pop     bx                              ; restore file handle
        mov     ah,041h                         ; Delete File
        int     21h                             ; DOS CALL
        clc                                     ; signal error
        jmp     CreateDISCDRet                  ; jump to return routine


CreateDISCDHan:
        dw      0                               ; File handle
CreateDISCDBlan:
        db      32 dup (32)                     ; 32 * ' '



CreateDISCiPLEDisk  endp
;**************** END OF PROCEDURE CreateDISCiPLEDisk *********************





;************************ FoundDISCiPLEDisk *******************************

FoundDISCiPLEDisk       proc

;**************************************************************************
;       ENTRY:  DS:SI = address of filename of file to look for
;
;       EXIT:   zero flag = Set for found
;               zero flag = Clear for not found
;**************************************************************************

        push    ax
        push    bx
        push    cx
        push    dx
        push    es
        push    ds
        mov     ah,02fh                         ; Get DTA address
        int     21h                             ; DOS CALL
        mov     word ptr cs:[FoundDISCODTA],bx  ; Store old DTA off & seg
        mov     word ptr cs:[FoundDISCODTA+2],es
        mov     ah,01ah                         ; Set DTA
        mov     dx,offset FoundDISCDDTA         ; DX = offset of DTA
        int     21h                             ; Set DTA
        mov     dx,si                           ; DS:DX = filename
        mov     cx,0                            ; normal attribute
        mov     ah,04eh                         ; Search for first match
        int     21h                             ; DOS CALL
        jc      FoundDISCDNot                   ; jump if not found
        xor     ax,ax
        jmp     FoundDISCDRet

FoundDISCDNot:
        mov     ax,1
        cmp     ax,0

FoundDISCDRet:
        pushf                                   ; store flags
        mov     ah,01ah                         ; Set DTA
        mov     dx,word ptr cs:[FoundDISCODTA+2]
        mov     ds,dx
        mov     dx,word ptr cs:[FoundDISCODTA]
        int     21h                             ; DOS CALL
        popf                                    ; restore flags
        pop     ds
        pop     es
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret

FoundDISCDDTA:
        db      43 dup (0)                      ; temporary DTA
FoundDISCODTA: dd      0                        ; old DTA address

FoundDISCiPLEDisk       endp

;*************** END OF PROCEDURE FoundDISCiPLEDisk ***********************





;************************* DISCiPLEUseFile ********************************
DISCiPLEUseFile         proc
;
;**************************************************************************
;
;       ENTRY:  DS:SI = address of filename
;               DISCiPLEDiskno = Drive Number
;       EXIT:   Carry Clear = Done
;               Carry Set   = Error
;               Old File closed & New file open and Track data loaded
;**************************************************************************
        push    ax
        push    bx
        push    cx
        push    dx
        push    si
        push    di
        push    ds
        push    es
        cmp     byte ptr cs:[DISCiPLEDiskNo],0
        jne     DISCiPLEUseF1
        stc                                     ; error! No drive selected
        jmp     DISCiPLEUseFRet                 ; return to calling routine

DISCiPLEUseF1:
        mov     di,word ptr cs:[DISCiPLEDiskBase] ; base addr. of drive data
        mov     bx,HandleOff                    ; File Handle offset
        mov     ax,word ptr cs:[di+bx]           
        cmp     ax,0                            ; No file used?
        je      DISCiPLEUseF1Open               ; jump if no file open
        push    di
        push    si
        push    bx
        mov     bx,ax                           ; BX=file handle of open file
        mov     ah,03eh                         ; CLOSE FILE
        int     21h                             ; DOS CALL
        jnc     DISCiPLEUseF1Closed             ; jump if no error
        pop     bx
        pop     si
        pop     di
        stc                                     ; signify error
        jmp     DISCiPLEUseFRet                 ; return to calling routine

DISCiPLEUseF1Closed:
        pop     bx
        pop     si
        pop     di
        mov     word ptr cs:[di+bx],0           ; signify no file open
        mov     bx,WriteProtOff                 ; write protect offset
        mov     ax,0
        mov     byte ptr cs:[di+bx],al
        mov     bx,TypeOff                      ; disk type offset
        mov     byte ptr cs:[di+bx],al
        mov     bx,CommandOff
        mov     word ptr cs:[di+bx],ax          ; reset 1772 registers
        mov     word ptr cs:[di+bx+2],ax        ; reset 1772 registers
        mov     word ptr cs:[di+bx+4],ax        ; reset 1772 registers

DISCiPLEUseF1Open:
        mov     ax,cs
        mov     es,ax                           ; ES=code segment
        mov     bx,FileNameOff                  ; Filename Offset
        push    bx                              ; Store Filename Offset
        mov     cx,0                            ; byte count

DISCiPLEUseF1O1:
        mov     al,byte ptr ds:[si]             ; Get byte of filename
        mov     byte ptr es:[di+bx],al
        inc     si
        inc     bx
        inc     cx
        cmp     al,0
        je      DISCiPLEUseF1O2                 ; jump if filename finished
        cmp     cx,32
        jb      DISCiPLEUseF1O1                 ; jump if more to go
        pop     bx                              ; error FILENAME TOO LONG!
        stc
        jmp     DISCiPLEUseFRet                 ; jump to calling routine

DISCiPLEUseF1O2:
        pop     bx                              ; restore filename offset
        mov     ax,cs
        mov     ds,ax                           ; DS = code segment
        mov     dx,di
        add     dx,bx                           ; DX = address of filename
        mov     ah,03dh                         ; Open file
        mov     al,2                            ; R/W access!
        int     21h
        jnc     DISCiPLEUseF1O3                 ; jump if no error
        cmp     ax,5                            ; if access denied
        je      DISCiPLEUseF1O21                ; jump for READ ACCESS ONLY!

DISCiPLEUseF1O2Err:
        stc
        jmp     DISCiPLEUseFRet

DISCiPLEUseF1O21:
        mov     ax,3dh                          ; OPEN FILE
        mov     al,0                            ; READ ACCESS
        int     21h                             ; DOS CALL
        jc      DISCiPLEUseF1O2Err              ; jump if error
        mov     bx,HandleOff                    ; file handle offset
        mov     word ptr cs:[di+bx],ax          ; store file handle
        mov     bx,WriteProtOff                 ; write protect offset
        mov     al,1
        mov     byte ptr cs:[di+bx],al
        mov     byte ptr cs:[di+TypeOff],al     ; type = file
        jmp     DISCiPLEUseFi3                  ; jump with all clear

DISCiPLEUseF1O3:
        mov     bx,HandleOff                    ; file handle offset
        mov     word ptr cs:[di+bx],ax          ; store file handle
        push    ax
        mov     al,1
        mov     byte ptr cs:[di+TypeOff],al     ; type = file
        pop     ax

DISCiPLEUseFile2:                               ; Now Load up disk info
        mov     bx,ax                           ; BX = File Handle
        push    bx                              ; store file handle
        mov     ah,042h                         ; MOVE FILE POINTER
        mov     al,0                            ; FROM BEGINNING OF FILE
        mov     cx,0
        mov     dx,32                           ; to position CX:DX
        int     21h                             ; DOS CALL
        jnc     DISCiPLEUseFi1                  ; jump if no error
        pop     bx
        jmp     DISCiPLEUseFRet

DISCiPLEUseFi1:
        pop     bx                              ; restore file handle
        push    bx                              ; store file handle
        push    ds
        mov     ax,cs
        mov     ds,ax                           ; DS=code segment
        mov     dx,di
        add     dx,TotTracksOff                 ; Total Tracks Offset
        mov     cx,1018                         ; 1018 bytes (6*84*2+10)
        mov     ah,03fh                         ; READ BYTES
        int     21h                             ; DOS CALL
        jnc     DISCiPLEUseFi2Chk               ; jump if no error
        pop     ds

DISCiPLEUseFi3:
        mov     bx,TypeOff                      ; disk type offset
        mov     al,1                            ; TYPE=FILE
        mov     byte ptr cs:[di+bx],al
        clc                                     ; signal no error
        jmp     DISCiPLEUseFRet

DISCiPLEUseFi2Chk:
        cmp     ax,1018                         ; check for all bytes read
        je      DISCiPLEUseFi2                  ; jump if they were
        pop     ds
        stc                                     ; signal error
        jmp     DISCiPLEUseFRet                 ; return to calling routine

DISCiPLEUseFi2:
        pop     ds
        pop     bx                              ; restore file handle
        mov     ah,042h                         ; move file pointer
        mov     al,1                            ; from current location
        mov     cx,0
        mov     dx,0                            ; do not move!
        int     21h                             ; DOS CALL
        mov     cx,ax                           ; CX=least sig. file loc
        mov     bx,FilePOff                     ; file pointer
        mov     word ptr cs:[di+bx],cx          ; least significant
        mov     word ptr cs:[di+bx+2],dx        ; most significant
        clc

DISCiPLEUseFRet:
        pop     es
        pop     ds
        pop     di
        pop     si
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret


DISCiPLEUseFile         endp

;******************** END OF PROCEDURE DISCiPLEUseFile ********************




;************************ DISCiPLECloseAllDisks ***************************
DISCiPLECloseAllDisks   proc

;**************************************************************************
;
;       ENTRY:  Nothing
;
;       EXIT:   All disk files (ie Hard-Disk diskettes) are closed
;               Carry Clear = Done
;               Carry Set   = Error
;
;**************************************************************************
        push    ax
        push    bx
        push    cx
        push    dx
        push    si
        mov     si,offset L1772D1Command
        mov     bx,HandleOff                    ; file handle offset
        cmp     word ptr cs:[si+bx],0           ; File Opened for Disk1?
        jne     DISCiPLECloseAll1               ; jump if not
        mov     ax,word ptr cs:[si+bx]          ; get file handle
        mov     bx,ax
        mov     ah,03eh                         ; CLOSE FILE
        int     21h                             ; DOS CALL
        jc      DISCiPLECloseAllDRet            ; jump if error

DISCiPLECloseAll1:
        mov     si,offset L1772D2Command
        mov     bx,HandleOff                    ; file handle offset
        cmp     word ptr cs:[si+bx],0           ; File Opened for Disk2?
        jne     DISCiPLECloseAll2               ; jump if not
        mov     ax,word ptr cs:[si+bx]          ; get file handle
        mov     bx,ax
        mov     ah,03eh                         ; CLOSE FILE
        int     21h                             ; DOS CALL

DISCiPLECloseAll2:
        clc                                     ; signal no error

DISCiPLECloseAllDRet:
        pop     si
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret

DISCiPLECloseAllDisks   endp
;*************** END OF PROCEDURE DISCiPLECloseAllDisks *******************



;************************* DISCiPLEDiskCommand ****************************
;
DISCiPLEDiskCommand     proc

;**************************************************************************
;       ENTRY:  AH = 1772 Command
;
;       EXIT:   Status registers set
;**************************************************************************
;
        pushf
        push    bx
        push    cx
        push    dx
        push    si
        push    di
        push    ds
        push    es
        push    ax
        call    DISCiPLECheckActive             ; Ensure base address correct
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     byte ptr cs:[di+CommandOff],ah
        mov     al,ah                           ; AL=AH=command
        and     al,011100000b                   ; Keep most of commands
        mov     cl,3
        rol     al,cl                           ; move top 3 bits to bottom
        add     al,al                           ; multiply by two to get
        xor     ah,ah                           ; offset
        mov     bx,ax                           ; BX = offset
        pop     ax                              ; restore command
        push    ax
        mov     si,offset DISCiPLECommTab       ; SI = Command Table address
        call    word ptr cs:[si+bx]             ; Call appropriate routine
        pop     ax
        pop     es
        pop     ds
        pop     di
        pop     si
        pop     dx
        pop     cx
        pop     bx
        popf
        ret



DISCiPLECommTab:
        dw      DISCiPLEResSeek                 ; Reset/Seek commands
        dw      DISCiPLEStep                    ; Step drive head
        dw      DISCiPLEStepIn                  ; Step drive head in
        dw      DISCiPLEStepOut                 ; Step drive head out
        dw      DISCiPLEReadSec                 ; Read Sector
        dw      DISCiPLEWriteSec                ; Write Sector
        dw      DISCiPLEReadAdFor               ; Read Address/Force Int.
        dw      DISCiPLEReWrTrk                 ; Read/Write Track

;**************************************************************************



DISCiPLEDiskCommand     endp

;******************** END OF PROCEDURE DISCiPLEDiskCommand ****************





;*************************** DISCiPLEResSeek ******************************
DISCiPLEResSeek         proc

;**************************************************************************
;
;       ENTRY:  AH=command
;               1772 registers set
;
;       EXIT:   1772 registers set
;               Correct track selected
;
;**************************************************************************
        push    ax
        push    bx
        push    cx
        push    dx
        push    si
        push    di
        push    ds
        push    es
        mov byte cs:[disciplebufftrk],0ff           ;GL
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        push    ax
        mov     al,0
        mov     byte ptr cs:[di+StatusOff],al   ; status OK
        pop     ax
        test    ah,000010000b                   ; Is it seek?
        jnz     DISCiPLESeek                    ; jump if it is
        mov     bx,TypeOff                      ; disk type offset
        cmp     byte ptr cs:[di+bx],1           ; is the type a file?
        je      DISCiPLEResFile
        jmp     near ptr DISCiPLEResDisk

DISCiPLEResFile:
        mov     al,0
        mov     dl,0
        jmp     DISCiPLEResNext

DISCiPLESeek:
        mov     bx,TypeOff
        cmp     byte ptr cs:[di+bx],1           ; is the type a file?
        je      DISCiPLESeekF                   ; jump if it is not a floppy
        cmp     byte ptr cs:[di+bx],0ffh        ; is the type a floppy
        jne     DISCiPLESekDE                   ; jump if not
        jmp     near ptr DISCiPLESekDisk

DISCiPLESekDE:
        or      byte ptr cs:[di+StatusOff],16   ; signal seek error
        jmp     DISCiPLEResSRet                 ; return to calling routine

DISCiPLESeekF:
        mov     al,byte ptr cs:[di+DataOff]     ; get track to seek to

DISCiPLEResNext:
        mov     byte ptr cs:[di+TrackOff],al    ; reset track register
        mov     byte ptr cs:[di+HWTrackoff],al  ; reset hardware track reg.
        and     byte ptr cs:[di+StatusOff],0    ; signal no errors
        cmp     byte ptr cs:[di+TotTracksOff],0 ; unformatted?
        je      DISCiPLEResFSErr                ; jump if it is
        mov     bx,TrackInfoOff
        mov     cl,byte ptr cs:[di+TotTracksOff] ; get no of tracks
        mov     ch,0

DISCiPLEResFResS:
        cmp     byte ptr cs:[di+bx],dl          ; is it desired track?
        je      DISCiPLEResFResS1               ; jump if it is
        add     bx,6                            ; look at next track
        loop    DISCiPLEResFResS

DISCiPLEResFSErr:
        test    byte ptr cs:[di+CommandOff],4   ; Verify?
        jnz     DISCiPLEResFSEr1                ; jump if it is
        jmp     near ptr DISCiPLEResSRet

DISCiPLEResFSEr1:
        or      byte ptr cs:[di+StatusOff],16   ; signal seek error
        jmp     DISCiPLEResSRet                 ; return to calling routine

DISCiPLEResFResS1:
        add     bx,2                            ; file pointer
        push    dx                              ; store desired track
        mov     cx,word ptr cs:[di+bx]
        mov     word ptr cs:[di+FilePOff],cx
        push    cx
        mov     cx,word ptr cs:[di+bx+2]
        mov     word ptr cs:[di+FilePOff+2],cx
        mov     dx,cx
        pop     cx                              ; DX:CX=file pointer
        mov     bx,word ptr cs:[di+HandleOff]   ; get file handle
        mov     ah,042h                         ; move file pointer
        mov     al,0
        int     21h                             ; DOS CALL
        pop     dx                              ; restore desired track
        mov     ax,cs
        mov     ds,ax                           ; DS=code segment
        mov     dx,offset DISCiPLEBuffer+5120   ; dx=load address
        push    dx
        mov     bx,word ptr cs:[di+HandleOff]
        mov     cx,7                            ; 7 bytes to load
        mov     ah,03fh                         ; READ FILE
        int     21h                             ; DOS CALL
        pop     bx                              ; restore load address
        mov     al,byte ptr cs:[bx]
        cmp     byte ptr cs:[di+TrackOff],al    ; Is it the correct track?
        if e jmp DISCiPLEResSRet                ; jump if it is
        or      byte ptr cs:[di+StatusOff],16   ; signal SEEK ERROR
        jmp     DISCiPLEResSRet

DISCiPLEResDisk:                                ; reset FLOPPY
        mov     ch,0                            ; track 0
        mov     byte ptr cs:[di+HWTrackOff],ch
        mov     byte ptr cs:[di+TrackOff],ch
        mov     byte ptr cs:[di+StatusOff],ch
        or      byte ptr cs:[di+StatusOff],4    ; track 0
        jmp     DISCiPLESekD1                   ; jump for seek

DISCiPLESekDisk:
        mov     ah,byte ptr cs:[di+DataOff]     ; get track no.

DISCiPLESekD1:
        push    di                              ; store base address
        push    ax                              ; store track number
        mov     ah,0
        int     13h
        pop     ax                              ; restore track number
        push    ax
        mov     al,byte ptr cs:[di+DriveOff]    ; drive number
        mov     dl,byte ptr cs:[di+CommandOff]  ; get command byte
        and     dl,4                            ; keep verify bit
        mov     cl,2                            ; rotate
        ror     dl,cl                           ; move verify bit to bit 1
        mov     bl,54                           ; pause 3 seconds for seek
        call    L1772Seek                       ; carry out seek
        jc      DISCiPLESekD1Err                ; jump if verify error
        mov     al,0                            ; signal all ok
        mov     byte ptr cs:[di+StatusOff],al   ; status OK
        cmp     byte ptr cs:[di+TrackOff],0     ; track 0?
        jne     DISCiPLESekD2                   ; jump if not
        or      byte ptr cs:[di+StatusOff],4    ; signal track 0

DISCiPLESekD2:
        pop     ax
        pop     di
        jmp     DISCiPLEResSRet                 ; jump to calling routine

DISCiPLESekD1Err:
        mov     ah,0
        int     13h
        pop     ax                              ; restore track number
        pop     di                              ; restore disk base address
        push    di                              ; store disk base address
        mov     al,byte ptr cs:[di+DriveOff]    ; drive number
        mov     dl,byte ptr cs:[di+CommandOff]  ; get command byte
        and     dl,4                            ; keep verify bit
        mov     cl,2                            ; rotate
        ror     dl,cl                           ; move verify bit to bit 1
        mov     bl,54                           ; wait 3 seconds for seek
        call    L1772Seek                       ; carry out seek
        jc      DISCiPLESekD1Err2
        pop     di
        jmp     DISCiPLEResSRet

DISCiPLESekD1Err2:
        pop     di
        or      byte ptr cs:[di+StatusOff],16   ; signal seek error

DISCiPLEResSRet:
        pop     es
        pop     ds
        pop     di
        pop     si
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret

DISCiPLEResSeek         endp
;*************** END OF PROCEDURE DISCiPLEResSeek *************************



;************************** DISCiPLEReWrTrk *******************************

DISCiPLEReWrTrk         proc

        pushf
        push    ax
        push    bx
        push    cx
        push    dx
        push    si
        push    di
        push    ds
        push    es
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     al,byte ptr cs:[di]
        test    al,16
        je      DISCiPLEReWrTrk                         ; read track********
        mov     ax,0
        mov     word ptr cs:[DISCiPLEFormTot],ax
        mov     word ptr cs:[DISCiPLEFormSkip],ax
        mov     byte ptr cs:[DISCiPLEFormMode],al
        mov     byte ptr cs:[DISCiPLESecSize],al
        mov     byte ptr cs:[DISCiPLEA1Cnt],al
        mov     byte ptr cs:[DISCiPLEIDLen],al
        mov     ax,offset DISCiPLEBuffer+5120
        mov     word ptr cs:[DISCiPLEDataAddress],ax
        mov     ax,6601
        mov     word ptr cs:[DISCiPLEDataLength],ax


DISCiPLEReWrTrkRet:
        pop     es
        pop     ds
        pop     di
        pop     si
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        popf
        ret


DISCiPLEReWrTrk         endp

;***************** END OF PROCEDURE DISCiPLEReWrTrk ***********************


;***************************** SetInt01E **********************************

SetInt01E       proc

        mov     ax,0
        mov     word ptr cs:[DISCiPLEDataLength],ax
        mov     ax,0351e                                ; get int 1e
        int     021
        mov     word ptr cs:[DISCiPLEOldInt1e],es
        mov     word ptr cs:[DISCiPLEOldInt1e+2],bx
        mov     ax,cs
        mov     es,ax
        mov     ds,ax
        mov     dx,offset DISCiPLENewInt1e
        mov     ax,0251e                                ; set int 1e
        int     021
        ret

SetInt01E       endp




ResetInt01E     proc
        
        mov     ax,word ptr cs:[DISCiPLEOldInt1e]
        mov     ds,ax
        mov     dx,word ptr cs:[DISCiPLEOldInt1e+2]
        mov     ax,0251e
        int     021
        ret

ResetInt01E     endp
