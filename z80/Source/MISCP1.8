;
;   This file is part of the registered Spectrum emulator package 'Z80'
;   version 2.01, and may not be distributed.  You may use this source for
;   other PC based Spectrum or Z80 emulators only after permission.  It is
;   however permitted to use this source file or parts thereof for Spectrum
;   or Z80 emulators on non-PC based machines, provided that the source is
;   acknowledged.
;
;                                                       Gerton Lunter, 3/5/93

startup segment para public

; Routines om het spectrum segment in en uit te pakken

scrunge:
;Komt terug met in CX de totale lengte v.h. gescrungde segment
        push ax
        push bx
        push dx
        push es
        push ds
        cld
        mov ds,cs:specseg
        push ds
        pop es
        mov di,16384
        mov si,16384
        mov cx,49152
        call noblock
        xor al,al
        stosb
        mov al,0ed
        stosb
        stosb
        xor al,al
        stosb
        mov cx,di
        sub ch,64
        pop ds
        pop es
        pop dx
        pop bx
        pop ax
        ret

;
;si wijst naar eerste nog in te lezen karakter
;bl bevat bloklengte (0-255)
;ah bevat blok karakter
;di wijst naar eerste vrije karakter
;cx bevat nog te scrungen bytes
;
scrungeit2:
        cmp bl,255
        jz putblock2
        lodsb
        cmp al,ah
        jnz scr_nogood
        inc bl
        loop scrungeit2
        jmp putblock2
scr_nogood:
        dec si
putblock2:
        cmp ah,0ed
        jnz no_ed2
        cmp bl,2
        jae putblock3
        mov al,ah
        stosb
        jcxz scr_done
        movsb                           ;om ED 00 00 00 00 ... -->
        loop noblock                    ;   ED ED ED nn 00 tegen te gaan.
        jmp scr_done
no_ed2: cmp bl,4
        jbe putnormal
putblock3:
        mov al,0ed
        stosb
        stosb
        mov al,bl
        stosb
        mov al,ah
        stosb
        jcxz scr_done
        jmp noblock
putnormal:
        mov al,ah
putnorm2:
        stosb
        dec bl
        jnz putnorm2
        jcxz scr_done
noblock:                        ;Minimaal 1 over (cx >= 1)
        lodsb
        mov ah,al
        mov bl,1
        loop scrungeit2
        jmp putblock2
scr_done:
        ret




descrungeit:                    ;Out: c=error
        push ax
        push bx
        push cx
        push dx
        push es
        push ds
        cld
        mov ds,cs:specseg
        push ds
        pop es
        mov di,16384+3
        mov cx,49151+3
find_end4:
        dec di
        inc cx
find_end3:
        dec di
        inc cx
find_end2:
        mov al,0
        inc cx
        dec di
find_end:
        repnz scasb
        jnz not_found
        dec cx
        jcxz not_found
        mov al,0ed
        scasb
        jnz find_end2
        dec cx
        jcxz not_found
        scasb
        jnz find_end3
        dec cx
        jcxz not_found
        xor al,al
        scasb
        jnz find_end4
        lea si,[di-5]
        mov di,0ffff
        mov cx,si
        add cx,1-04000
        std
        rep movsb
        cld
        mov si,di
        inc si
        mov di,16384
        mov cx,49152
        call descr_loop
        cmp di,1
        cmc
descr_end:
        pop ds
        pop es
        pop dx
        pop cx
        pop bx
        pop ax
        ret

;In: cld, es:di wijst naar begin outputbuffer, es:ffff is einde, ds:si
;    wijst naar begin inputbuffer, es:ffff is einde, cx is aantal bytes.
;out: c=error
;     di->end of descrunged block
descr_loop:
        cmp si,16384
        jb not_found
        cmp di,16384
        jb not_found
        cmp b[si],0ed
        jz maybe_shiftcode
        movsb
        loop descr_loop
        clc
        ret
maybe_shiftcode:
        cmp b[si+1],0ed
        jz shiftcode
        movsb
        loop descr_loop
        clc
        ret
shiftcode:
        inc si
        inc si
        lodsb
        mov bl,al
        lodsb
descr_putblock2:
        stosb
        dec cx
        jz descr_the_end
        dec bl
        jnz descr_putblock2
        cmp cx,49152
        ja not_found
        inc cx
        loop descr_loop
        clc
        ret
not_found:
        stc
        ret
descr_the_end:
        dec bl
        jnz not_found
        ret                     ;nc:ok



emulate_kbd_interrupt:
        pushf
        push cs
        mov bx,offset eki_ret
        push bx
        push ax
        push bx
        push cx
        push dx
        jmp short keyb_normal_entry
eki_ret:
        ret

KEYBOARD:
        PUSH AX
        test cs:byte keyscan,1
        je keyb_nokeyscan
        mov al,020
        out 020,al
        in al,060
        cmp al,0e0
        jz return_keyscan
        cmp al,0e1
        jz return_keyscan
        or al,cs:break
        cmp al,0f0
        mov byte cs:break,0
        if z mov byte cs:break,080
        test al,080
        if z or cs:byte keyscan,2
        cmp al,040
        if z or cs:byte keyscan,4       ;F6
return_keyscan:
        in al,061
        push ax
        or al,080
        out 061,al
        pop ax
        out 061,al
        pop ax
        sti
        iret
keyb_nokeyscan:
        cmp cs:byte modflg,0
        je keyb_normal
        pushf
        call cs:d[offset kbdadr]
        mov ah,1
        int 016
        jz keyb_nokey
        mov cs:modflg,2                 ;Signaleer 'Toets ingedrukt in real mode'
        in al,021
        and al,0fe                      ;Zet timer aan (als ie uitstaat)
        out 021,al
keyb_nokey:
        pop ax
        sti
        iret
keyb_normal:
        MOV AL,020
        OUT 020,AL
        PUSH BX
        PUSH CX
        PUSH DX
        IN AL,060
keyb_normal_entry:
        CMP AL,0E0
        JZ e0GET_OUT
        CMP AL,0E1
        JZ GET_OUT
        test byte cs:e0flag,0ff
        mov byte cs:e0flag,0
        jz e0flag_inaktief
        mov ah,al
        and ah,07f
        cmp ah,02a
        jz get_out
        cmp ah,036
        jz get_out
e0flag_inaktief:
        CMP AL,0F0
        JNZ NO_BRK
        MOV BYTE CS:BREAK,080
        JMP GET_OUT
NO_BRK:
        OR AL,CS:BREAK          ;MAAK ER EEN 'BREAK' VAN ALS ER 0F0 IS GEWEEST
        MOV AH,AL
        AND AL,080
        MOV CS:BREAK,AL         ;ZET IN BREAK 080 ALS BRK
        MOV AL,AH
        CMP AL,CS:LASTKEY
        MOV CS:LASTKEY,AL
        JZ GET_OUT_NOBRK_2
        AND AL,07F              ;HAAL BRKBIT ERAF
        CMP AL,053
        JA GET_OUT_NOBRK_2
        TEST AL
        JZ GET_OUT_NOBRK_2
        CALL KEY_TRANS
        MOV BYTE CS:BREAK,0
GET_OUT:
        CALL MATRIX_ERROR       ;EMULEER ZX SPECTRUM KEYBOARD MATRIX
        cmp byte cs:winkey,0
        jnz dont_reset_kbd
        IN AL,061
        PUSH AX
        OR AL,080
        OUT 061,AL
        POP AX
        OUT 061,AL
dont_reset_kbd:
        POP DX
        POP CX
        POP BX
        POP AX
        sti
        IRET
GET_OUT_NOBRK_2:
        MOV byte CS:BREAK,0
        JMP GET_OUT
e0get_out:
        mov byte cs:e0flag,0ff
        jmp get_out

KEY_TRANS:
        PUSH SI
        MOV BX,offset KEYBTAB1
        CS:XLATB
        TEST AL
        JZ GET_OUT_NOBRK
        TEST AL,011000000XB
        JZ NORMAL_CHAR
        MOV BL,AL
        AND BX,011111XB
        MOV SI,BX
        ROL BX,1
        TEST byte CS:[SI+SHFTSTATES],1
        JZ FIRSTTIME                    ;LAAT EERST OUDE TOETS 'INTERN' LOS
        PUSH WORD CS:BREAK
        MOV byte CS:BREAK,080           ;LAAT LOS
        PUSH BX
        PUSH SI
        CALL CS:[BX+KEY_ROUTINES]
        POP SI
        POP BX
        POP WORD CS:BREAK
FIRSTTIME:
        CMP byte CS:BREAK,080
        JZ NOCHANGE_AT_BREAKTIME
        MOV AL,CS:SHIFTSTATE
        OR AL,1                         ;GEEFT AAN 'KEY PRESSED'
        MOV CS:[SI+SHFTSTATES],AL
NOCHANGE_AT_BREAKTIME:
        PUSH SI
        CALL CS:[BX+KEY_ROUTINES]
        POP SI
        CMP byte CS:BREAK,080
        IF Z MOV byte CS:[SI+SHFTSTATES],0   ;'KEY RELEASED'
        JMP GET_OUT_NOBRK

NORMAL_CHAR:
        CMP AL,8                ;SHIFT
        JNZ NOSH
        MOV AH,CS:BREAK
        MOV CS:SHIFTSTATE,AH
NOSH:
        MOV CL,AL
        MOV AH,080
        SHR CL,1
        SHR CL,1
        SHR CL,1
        ROL AH,CL
        CALL SETKBIT
GET_OUT_NOBRK:
        MOV byte CS:BREAK,0
        POP SI
        RET


SETKBIT:
;ZET EEN BIT IN IN_TAB, AFH.V. BREAK. ENTRY: AH=MASK(COL), AL0-2=ROW
        MOV BL,AL
        AND BX,7                ;BX=OFFSET IN_TAB
        ADD BX,OFFSET IN2_TAB
        TEST byte CS:BREAK
        JNZ RESET_BIT
        OR CS:[BX],AH
        RET
RESET_BIT:
        NOT AH
        AND CS:[BX],AH
        RET

set_joystick:
;Zet een bit in in_tab of in kempston_state, afhankelijk van joymode,
;de code in AL (0,1,2,3,4 = links,rechts,onder,boven,schieten) en BREAK.
        xor ah,ah
        mov bx,ax
        mov al,cs:joymode
        add bx,ax
        shl ax,1
        shl ax,1
        add bx,ax
        shl bx,1
        mov ax,cs:[bx+joy_tab]
        push ax
        cmp byte cs:joymode,0
        if z call setshft
        pop ax
        cmp byte cs:joymode,1
        jnz setkbit                     ;kempston krijgt 'sonderbehandlung'
        test byte cs:break
        jnz reset_kempston_bit
        or cs:[kempston_state],al
        ret
reset_kempston_bit:
        not al
        and cs:[kempston_state],al
        ret

joy_tab:
        dw 01003,0404,01004,0804,0104
        dw 2,1,4,8,16
        dw 0103,0203,0403,0803,01003
        dw 01004,0804,0404,0204,0104

KEY_ROUTINES:
        DW KR0,KR1,KR2,KR3,KR4,KR5,KR6,KR7,KR8,KR9,KR10,KR11,KR12,KR13,KR1BIS,kr15
        DW KR16,KR17,KR18,KR19,KR20,KR21,KR22,KR23,KR24,KR25,KR26,KR27,kr28,kr29
;Voor elke key routine is er een shiftstate in z80.8 gereserveerd!!!

KR0:
        MOV AX,0100             ;ESC (=EDIT)
        CALL SETKBIT
        MOV AX,0103
        JMP SETKBIT

KR1:    MOV AX,0207             ;- OF _
        CALL SETKBIT
        MOV AL,1                ;KR1
KR1A:   CALL TESTSHFT
        MOV AX,0806             ;J (-)
        IF NZ MOV AX,0104       ;0 (_)
        JMP SETKBIT
KR1BIS: MOV AX,0207
        CALL SETKBIT
        MOV AL,14
        JMP KR1A

KR2:    MOV AX,0207             ;+ OF =
        CALL SETKBIT
        MOV AL,2
        CALL TESTSHFT
        MOV AX,0206             ;L (=)
        IF NZ MOV AH,4          ;K (+)
        JMP SETKBIT

KR3:    MOV AX,0100             ;BACKSPACE (=SHFT 0)
        CALL SETKBIT
        MOV AX,0104
        JMP SETKBIT

KR4:    MOV AX,0207             ; ; OF :
        CALL SETKBIT
        MOV AL,4
        CALL TESTSHFT
        MOV AX,0205             ;O
        IF NZ MOV AX,0200       ;Z
        JMP SETKBIT

KR5:    MOV AX,0207             ;" OF '
        CALL SETKBIT
        MOV AL,5
        CALL TESTSHFT
        MOV AX,0105             ;P
        IF Z MOV AX,0804
        JMP SETKBIT

KR6:    cmp byte cs:azerty,0ff
        jz kr6_az
        MOV AX,0207             ;, OF <
        CALL SETKBIT
        MOV AL,6
        CALL TESTSHFT
        MOV AX,0807             ;N
        IF NZ MOV AX,0802       ;R
        JMP SETKBIT
kr6_az: mov ax,0207             ;; or .
        call setkbit
        mov al,6
        call testshft
        mov ax,0205             ;O
        if nz mov ax,0407       ;M
        jmp setkbit


KR7:    cmp byte cs:azerty,0ff
        jz kr7_az
        MOV AX,0207             ;. OF >
        CALL SETKBIT
        MOV AL,7
        CALL TESTSHFT
        MOV AX,0407             ;M
        IF NZ MOV AX,01002      ;T
        JMP SETKBIT
kr7_az: mov ax,0207             ;: or /
        call setkbit
        mov al,7
        call testshft
        mov ax,0200             ;Z
        if nz mov ah,010        ;V
        jmp setkbit


KR8:    cmp byte cs:azerty,0ff
        jz kr8_az
        MOV AX,0207             ;/ OF ?
        CALL SETKBIT
        MOV AL,8
        CALL TESTSHFT
        MOV AX,01000            ;V
        IF NZ MOV AH,08         ;C
        JMP SETKBIT
kr8_az: mov ax,0207
        call setkbit            ;, or ?
        mov al,8
        call testshft
        mov ax,0807             ;N
        if nz mov ax,0800       ;C
        jmp setkbit

KR9:    MOV AX,0207             ;*
        CALL SETKBIT
        MOV AX,01007
        JMP SETKBIT

KR10:   MOV AX,0100             ;CAPSLOCK
        CALL SETKBIT
        MOV AX,0203             ;2
        call setkbit
        test byte cs:break
        jnz ret
;        PUSH ES
;        XOR AX,AX
;        MOV ES,AX
;        XOR ES:B[0417],040
;        CALL SET_KBD_LEDS
;        POP ES
        ret

KR11:   TEST byte CS:BREAK           ;NUMLOCK
        JNZ RET
        test cs:b[in2_tab+7],2       ;CTRL/ALT: dan pauze dwz niks doen
        jnz ret
        NOT byte CS:NUMLCK
;        PUSH ES
;        XOR AX,AX
;        MOV ES,AX
;        XOR ES:B[0417],020
;        CALL SET_KBD_LEDS
;        POP ES
        RET

KR12:   TEST byte CS:BREAK           ;SCROLL LOCK
        JNZ RET
        TEST CS:B[IN2_TAB+7],2       ;CTRL/ALT: dan naar DOS
        JZ kr12_no_ctrlalt
        mov byte cs:c_active,0fa
        mov byte cs:c_action_code,0fa     ;zet C flags op aktief, zodat straks bij
        ret                          ;timerinterrupt C-routine wordt aangeroepen
                                     ;(zie xtra.c, label ENTRY)
kr12_no_ctrlalt:
        TEST CS:B[IN2_TAB],1
        jz kr12_no_shift
        MOV byte CS:NMI,0FF     ;ALS SHFT+SCRL_LOCK, DAN NMI
        ret
kr12_no_shift:
;        PUSH ES
;        XOR AX,AX
;        MOV ES,AX
;        XOR ES:B[0417],010      ;toggle scrolllock status
;        CALL SET_KBD_LEDS
;        POP ES
        ret

SET_KBD_LEDS:
;        push es
;        xor ax,ax
;        mov es,ax
;        in al,060
;        mov cx,02000
;set_kbd_leds_delay_twee:
;        loop set_kbd_leds_delay_twee
;        MOV AL,0ED
;        OUT 060,AL
;        PUSH CX
;        MOV CX,02004
;        MOV AL,ES:B[0417]
;        SHR AL,CL
;        and al,7
;SET_KBD_LEDS_DELAY:
;        LOOP SET_KBD_LEDS_DELAY
;        OUT 060,AL
;        POP CX
;        pop es
        RET

KR13:   mov al,3                ;omhoog (keypad 8)
        jmp set_joystick

KR15:   xor al,al               ;links (keypad 4)
        jmp set_joystick

KR16:   mov al,1                ;rechts (keypad 6)
        jmp set_joystick

KR17:   MOV AX,0207             ;+ (OF =)
        CALL SETKBIT
        MOV AL,17
        CALL TESTSHFT
        MOV AX,0406             ;L (+)
        IF NZ MOV AH,2          ;K (=)
        JMP SETKBIT

KR18:   mov al,2                ;omlaag (keypad 2)
        jmp set_joystick

kr19:   mov al,4                     ;INS/DEL/5/TAB: schieten.
        jmp set_joystick



SETSHFT:
        mov al,CS:NUMLCK
        cmp byte cs:rommod,2
        if a xor al,cs:curs128
        test al
        JZ RET
        MOV AX,0100
        JMP SETKBIT

TESTSHFT:
        MOV BL,AL
        XOR BH,BH
        TEST byte CS:BREAK
        JZ NOBRK
        CMP byte CS:[SHFTSTATES+BX],1
        JZ WAS_SHFT
        CMP AL,AL
        RET
WAS_SHFT:
        CMP byte CS:SHIFTSTATE,0
        IF Z OR CS:B[IN2_TAB],1
        RET                             ;ALTIJD NZ
NOBRK:
        AND CS:B[IN2_TAB],0FE
        CMP byte CS:[SHFTSTATES+BX],081
        RET

MATRIX_ERROR:
        PUSH SI
        PUSH DI
        PUSH DS
        PUSH ES
        CLD
        PUSH CS
        PUSH CS
        POP DS
        POP ES
        MOV SI,offset IN2_TAB
        MOV DI,offset IN_TAB
        MOVSW
        MOVSW
        MOVSW
        MOVSW
        MOV SI,offset IN_TAB
        MOV DX,7
MATRIX_LOOP:
        LODSB
        MOV AH,AL
        MOV CX,DX
        MOV DI,SI
M_INNER_LOOP:
        MOV AL,[DI]             ;HAAL VERDEROPLIGGENDE WAARDE
        TEST AL,AH              ;GELIJKE TOETSEN?
        JZ NO_EQ_KEY            ;GEEN GELIJKE TOETS INGEDRUKT
        OR AL,AH                ;OR VERDEROPLIGGENDE WAARDE MET HUIDIGE WAARDE
        MOV AH,AL
NO_EQ_KEY:
        STOSB                   ;ZET NIEUWE WAARDE WEG & INC DI
        LOOP M_INNER_LOOP
        NOT AH
        OR AH,011100000XB
        MOV [SI-1],AH
        DEC DX
        JNZ MATRIX_LOOP
        NOT B[SI]
        OR B[SI],011100000XB
        POP ES
        POP DS
        POP DI
        POP SI
        RET

MSTOSB:
        xor al,cs:b[offset checksum]
        ADD AL,CS:[BP]
        xor al,cs:b[offset checksum+1]
        INC BP
        CMP BP,OFFSET inbuf+256
        IF Z MOV BP,OFFSET inbuf
        STOSB
        ret

SCRUNGEIT:
        CLD
        PUSH CS
        POP ES
        MOV SI,081
        LODSB
        CMP AL,020
        IF NZ DEC SI
        MOV DI,OFFSET INBUF
SCRCPY: LODSB
        STOSB
        CMP AL,0D
        JNZ SCRCPY
        MOV AX,SEG OPC0
        MOV DS,AX
        MOV ES,AX
        XOR SI,SI
        XOR DI,DI
        MOV CX,0FFEF
        MOV BP,OFFSET INBUF
SCR0:   CMP W[SI],03D8A
        JNZ NOBLK
;        CMP W[SI+2],0DB32
;        JNZ NOBLK
        CMP W[SI+2],0E3FF
        JNZ NOBLK
        CMP W[SI+4],09090
        JNZ NOBLK
        CMP W[SI+6],09090
        JNZ NOBLK
        CMP B[SI+8],090
        JNZ NOBLK
        ADD SI,9
        SUB CX,8
        MOV AL,0
        call mstosb
        MOV AL,092
        call mstosb
        MOV AL,090
        call mstosb
        LOOP SCR0

NOBLK:  CMP W[SI],0
        JNZ __NOZERO
        CMP W[SI+2],0
        JNZ __NOZERO
        MOV DX,0
COUNTZERO:
        CMP DX,0100
        JZ EOBFOUND
        CMP CX,-1
        JZ EOBFOUND
        LODSB
        INC DX
        DEC CX
        TEST AL,AL
        JZ COUNTZERO
EOBFOUND:
        DEC DL
        INC CX
        DEC SI
        MOV AL,DL
        call mstosb
        MOV AL,092
        call mstosb
        MOV AL,090
        call mstosb
        JCXZ SCR_FINISHED
        JMP SCR0
__NOZERO: CMP W[SI],09092
        JZ NOPSFOUND
        LODSB
        call mstosb
        DEC CX
        IF NZ JMP SCR0
        JMP SCR_FINISHED
NOPSFOUND:
        MOV AL,1
        call mstosb
        LODSB
        call mstosb
        LODSB
        call mstosb
        DEC CX
        DEC CX
        JMP SCR0
SCR_FINISHED:
        MOV AX,BP
        STOSW
        MOV CS:ROMADR,DI
        mov ah,062
        int 021
        mov ds,bx
        mov ds,[02c]
        xor si,si
getprogname:
        lodsb
        and al,al
        jnz getprogname
        lodsb
        and al,al
        jnz getprogname
        inc si
        inc si
        mov dx,si
        mov ax,03d02
        int 021
        jc interr
        mov bx,ax
        mov ah,03f
        mov cx,10
        push cs
        pop ds
        mov dx,exeheader
        int 021
        jc interr
        mov ax,04202
        mov dx,-0fff0
        mov cx,-1
        int 021
        push es
        pop ds
        mov ah,040
        xor dx,dx
        mov cx,di
        int 021
        jnc noerr
interr: mov dx,ierr
        jmp print
noerr:  mov ax,04201
        xor cx,cx
        xor dx,dx
        int 021
        push dx
        push ax
        mov cx,ax
        xchg dl,dh
        shr dx,1
        and cx,511
        sub ax,cx
        xchg ah,al
        shr ax,1
        add ax,dx               ;ax:cx is lengte
        test cx,cx
        if nz inc ax
        mov cs:w[offset exeheader+2],cx
        mov cs:w[offset exeheader+4],ax
        mov ax,04200
        xor cx,cx
        xor dx,dx
        int 021
        mov ah,040
        mov cx,10
        push cs
        pop ds
        mov dx,offset exeheader
        int 021
        jc interr
        mov ax,cs
        add ax,cs:w[offset exeheader+8]         ;header size
        sub ax,seg _first_func
        mov dl,4
        xor cx,cx
times16:
        shl ax,1
        rcl cx,1
        dec dl
        jnz times16
        add ax,offset romadr
        adc cx,0
        mov dx,ax
        mov ax,04200
        int 021
        push cs
        pop ds
        mov dx,offset romadr
        mov cx,2+256
        mov ah,040
        int 021
        pop dx
        pop cx
        mov ax,04200
        int 021
        mov ah,040
        xor cx,cx
        int 021
        mov ah,03e
        int 021
        if c jmp interr
        mov ax,04c00
        int 021


;
;The following routine is called from the actual emulator code, when in
;Windows compatibility mode. The code calling it is assembled by rreg_makeblock.
;
inter_handler:
        mov cs:w[tstates],-17470        ;reset T state counter
        pushf
        mov bx,seg emulate
        push bx
        mov bx,offset emulate
        push bx
        push ax
        jmp win_comp_entry

endint1_x: jmp endint1

TIMER:  STI
        PUSH AX
        MOV AL,020
        OUT 020,AL
        MOV AL,CS:INTTEL
        INC AL
        CMP AL,CS:MAXTEL
        JB NOTMAX
        MOV AL,0
NOTMAX: MOV CS:INTTEL,AL
        jnz endint1_x
        cmp byte cs:doublec,0
        jnz endint1_x                   ;NOG NIET TIJD VOOR EEN IRPT
win_comp_entry:                         ;entry point in windows comp. mode
        PUSH BX                         ; (see below)
        PUSH CX
        PUSH DX
        PUSH BP
        cmp byte cs:rommod,3
        jb timer_noenv
        cmp byte cs:adlib,0ff
        je timer_env
        cmp byte cs:intsnd,0ff
        jne timer_noenv
timer_env:
        cmp byte cs:silence,0
        jne timer_noenv
        mov ax,cs:envaddlo
        add cs:envnumlo,ax
        mov ax,0
        adc ax,cs:envaddhi
        test ax,ax
        jz timer_noenv
        call update_channels            ;ZIE MDRV.8
timer_noenv:
        MOV BP,SP
        CMP W[BP+12],SEG EMULATE        ;KWAM INTRPT VAN SPEC.EMUL?
        IF NZ JMP ENDINT
        inc byte cs:mdrv_counter
        cmp byte cs:mdrv_counter,5
        jnz no_mdrv_action
        mov byte cs:mdrv_counter,0
        call mdrv_writegap
no_mdrv_action:
        cmp cs:byte modflg,2            ;Toets ingedrukt in real mode?
        if z jmp do_modchg
        cmp cs:byte spctel,0
        jz tim_nospace
        dec cs:byte spctel
        if z or byte cs:[offset in_tab+7],1         ;Laat SPACE los
tim_nospace:
        TEST BYTE CS:TIMFLAG
        IF Z JMP ENDINT                 ;SPRING ERUIT ALS GEEN INTERRUPTS ETC.
                                        ;ZIJN TOEGESTAAN
        cmp byte cs:winkey,0            ;Windows compatibility mode?
        if z jmp tim_normal
        mov ah,2                        ;get shift state
        int 016
        mov ah,al
        shr ah,1
        or al,ah
        and al,5                        ;or left & right shift, and ctrl & alt.
        cmp cs:wkbd_shift,al
        jz tim_noshiftchange
        mov cs:wkbd_shift,al
        shr al,1
        push ax
        mov al,02a*2                    ;left shift
        cmc
        rcr al,1
        call emulate_kbd_interrupt
        pop ax
        shr al,1
        shr al,1
        mov al,01d*2                    ;ctrl
        cmc
        rcr al,1
        call emulate_kbd_interrupt
tim_noshiftchange:
        mov ah,1
        int 016
        jz tim_nokeys
        xor ah,ah
        int 016
        mov al,ah
        xchg ah,cs:wkbd_lastscan
        mov byte cs:wkbd_count,3        ;auto repeat: hold down appr. 100 ms
        cmp al,ah
        jz tim_ok
        mov byte cs:wkbd_count,5        ;first key depress: hold down 250 ms
        test ah
        jz tim_ok
        push ax
        mov al,ah
        or al,080
        call emulate_kbd_interrupt      ;release previous key
        pop ax
tim_ok:
        call emulate_kbd_interrupt
        jmp tim_noshiftchange
tim_nokeys:
        cmp byte cs:wkbd_count,1
        jnz tim_normal
        mov byte cs:wkbd_count,0
        xor al,al
        xchg al,cs:wkbd_lastscan
        test al
        jz tim_normal
        or al,080
        call emulate_kbd_interrupt      ;release key after approx 250 ms
tim_normal:
        TEST BYTE CS:C_ACTIVE
        IF NZ JMP DO_C                  ;BIJ 'F2' OF 'DI/HALT'
        CMP BYTE CS:NMI,0FF
        IF Z JMP DO_NMI
        CMP BYTE CS:NMI,080
        IF Z JMP DO_RESET
        MOV AL,CS:VIERTEL
        INC AL
        AND AL,3
        MOV CS:VIERTEL,AL
        TEST BYTE CS:DOUBLE
        JZ DO_NORMAL_SPEED              ;GEWONE IRUPT SNELHEID: 50X PER SEC
        MOV BYTE CS:RFSHFLG,0FF
        cmp al,0
        jz do_irupt                     ;timeframe 0: alleen interrupt
        cmp al,2
        if nz jmp endint                ;timeframe 2: irpt en video
        cmp cs:byte modflg,0            ;als in real mode geen vid update
        jnz do_irupt
        CALL VIDEO_UPDATE
        call joystick_update
        CALL UPDATE_DTR
        CALL UPDATE_BUFSTATUS
        JMP DO_IRUPT
DO_NORMAL_SPEED:
        MOV AH,0FF
        CMP AL,3
        IF Z INC AH
        TEST AL
        IF Z INC AH
        MOV CS:RFSHFLG,AH               ;in 0ff geeft 0ff in frame 0 en 3
        JZ DO_IRUPT                     ;FRAME 0:IRUPT GENEREREN
        cmp al,CS:SYNCMOD
        IF NZ JMP ENDINT                ;FRAME 2:VIDEO UPDATEN (1,3:NIKS DOEN)
        cmp cs:byte modflg,0
        if nz jmp endint
        CALL VIDEO_UPDATE
        call joystick_update
        CALL UPDATE_DTR
        CALL UPDATE_BUFSTATUS
        JMP ENDINT
do_modchg:
        mov byte cs:c_active,0ff
        mov byte cs:c_action_code,0f4
        jmp do_c
DO_IRUPT:
        TEST BYTE CS:IFF,0FF
        IF Z JMP ENDINT                 ;NU KLAAR ALS INTERRUPTS DISABLED

;nu een interrupt genereren. Ook flag zetten voor HALT instructie

DO_RESET:
DO_NMI:
        IF Z DEC BYTE CS:NMI             ;ALS NMI, DAN 0FF WORDT 0FE (OF 07F)
DO_C:
;
;GA DOOR TOT DE INSTRUCTIE AFGELOPEN IS:
;
        cmp byte cs:winkey,0
        je single_step
        cmp b[di],118                   ;step over possible HALT instruction
        if e inc di
        jmp tim_winkey
single_step:
        PUSH ES
        XOR AX,AX
        MOV ES,AX
        LES bx,ES:[4]
        MOV CS:oldint3a,bx
        MOV CS:oldint3s,ES
        mov es,ax
        MOV ES:W[4],DO_INSTRUCTION
        MOV ES:[6],CS
        POP ES
        POP BP
        POP DX
        POP CX
        POP BX
        POP AX
        CALL SAVE_REGS
        MOV BYTE CS:WORKSP,0
DO_INSTRUCTION:
        STI
        PUSH BP
        PUSH ES
        push ax
check_instr:
        MOV BP,SP
        OR b[BP+11],01          ;ZET TRAPFLAG (WEER) AAN
        AND b[BP+11],0FD        ;ZET IF UIT
        LES BP,[BP+6]           ;HAAL SEG/ADR VAN VOLGENDE INSTRUCTIE
        cmp bp,offset haltwait
        jz found_halt
        mov ax,es:[bp]
        cmp ax,03d8a            ;mov bh,[di]
        jz found_end
        cmp al,09c              ;pushf
        jz do_pushf
        cmp al,09d              ;popf
        jz do_popf
        TEST BYTE CS:TIMFLAG
        JZ LEAVEIT
        MOV ax,ES
        CMP ax,SEG EMULATE
        JNZ LEAVEIT
NEXT_INSTR:
        pop ax
        POP ES
        POP BP
        IRET                    ;NAAR DO_INSTRUCTION
DO_PUSHF:
        PUSHF                   ;allocate one word on the stack
        MOV BP,SP
        mov ax,[bp+2]           ;old ax
        mov [bp],ax
        MOV ax,[BP+4]           ;OUDE ES
        MOV [BP+2],ax
        MOV ax,[BP+6]           ;OUDE BP
        MOV [BP+4],ax
        MOV ax,[BP+8]           ;OUDE IP
        INC ax                  ;VOLGENDE INSTRUCTIE
        MOV [BP+6],ax
        MOV ax,[BP+10]          ;OUDE CS
        MOV [BP+8],ax
        MOV ax,[BP+12]          ;OUDE FLAGS
        MOV [BP+10],ax
        and ah,0fe              ;reset TF of pushed flags
        or ah,2                 ;set IF of pushed flags
        mov [bp+12],ax
        JMP check_instr
DO_POPF:
        MOV BP,SP
        OR W[BP+12],0100       ;ZET TF AAN VAN TE POPPEN FLAGS
        JMP next_instr
found_halt:                     ;If the break is just after a HALT _and_
        test byte cs:c_active   ;we're going to C, then make sure an interrupt
        if nz dec di            ;is issued when C is finished.
        jmp short found_end_2
LEAVEIT:
        MOV BYTE CS:WORKSP,0FF  ;signal: don't activate interrupt/c
        JMP SHORT FOUND_END_2
FOUND_END:
        CMP ES:[BP+2],0E3FF     ;JMP BX
        JNZ next_instr
FOUND_END_2:
        pop ax
        POP ES
        POP BP
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        PUSH BP
        PUSH ES
        XOR AX,AX
        MOV ES,AX
        MOV AX,CS:oldint3a
        MOV ES:[4],AX
        MOV AX,CS:oldint3s
        MOV ES:[6],AX
        POP ES
        MOV BP,SP
        TEST BYTE CS:WORKSP             ;Do not activate c or generate irpt
        JNZ C_ACT                       ; if worksp<>0
tim_winkey:
        MOV BP,SP                       ;sic!
        mov word cs:trapadr,offset emulate
        mov word cs:trapseg,seg emulate
        TEST BYTE CS:C_ACTIVE
        JZ NOT_C_ACT
        MOV W[BP+10],OFFSET ENTER_C
        MOV W[BP+12],SEG ENTER_C
        JMP SHORT C_ACT
NOT_C_ACT:
        MOV W[BP+10],OFFSET IRUPT       ;ZET ADRES VAN INTERRUPT-ROUTINE OP STACK
        MOV W[BP+12],SEG IRUPT
C_ACT:
        AND W[BP+14],0FEFF              ;ZET TF UIT
        OR W[BP+14],0200                ;ZET IF AAN
        MOV BYTE CS:C_ACTIVE,0          ;ACTION CODE VOOR 'C' IN C_ACTION_CODE
ENDINT:
        POP BP
        POP DX
        POP CX
        POP BX
endint1:
        cmp byte cs:modflg,0
        je endint_normal
        pop ax
        iret
endint_normal:
        MOV AX,CS:TIMNUM
        STC
        ADC AX,CS:ADDNUM
        MOV CS:TIMNUM,AX
        POP AX
        jc normal_timinter
        IRET
normal_timinter:
        cmp byte cs:wkbd_count,0        ;decrease windows compatibility kbd
        if ne dec byte cs:wkbd_count    ; counter (see above)
        cmp byte cs:winkey,0            ;Windows comp. mode?
        if e JMP CS:D[TIMADR]           ;If not jump to old timer routine
        iret                            ;Otherwise just return to caller!




;
;De volgende routine berekent de gewenste vertragingsfactor voor SLOWMOD
;gegeven de maximale relatieve snelheid (tov echte Spectrum) in promilles
;in RELSPD0 en een gewenste snelheid in AX. Na afloop is SLOWMOD goedgezet.
;Een aanroep van HOESNEL geeft in AX de snelheid in promilles terug.
;Deze wijkt iha af van de gewenste snelheid.
;Een aanroep van RREG_EMUL is nog nodig om de snelheidsverandering
;werkelijkheid te maken.
;
speed_convert:
        mov bx,offset slowmod
        mov cx,4
spdc_loop:
        push ax
        push bx
        push cx
        call spdc_cx_tstates
        pop cx
        pop bx
        pop ax
        add bx,2
        inc cx
        cmp cx,23
        jbe spdc_loop
        ret
spdc_cx_tstates:
        push bx
        cmp ax,70
        if b mov ax,70
        mov dx,cs:relspd0
        cmp dx,ax
        ja speed_slower
speed_fastest:
        xor ax,ax
        jmp short spd_gotit
speed_slower:
        mov bx,ax               ;k = (1/65536) T (n/512) (174483/v' - 174483/v)
        mov ax,43621            ; bxcst = n/512
        mul cx
        add ax,ax
        adc dx,dx
        add ax,ax
        adc dx,dx
        push ax
        push dx
        div bx                  ; 174483 = 65536*(1000*18.2*512/3.5M)
        add dx,dx
        cmp dx,bx
        if a inc ax
        mov bx,ax
        mov ax,cs:relspd0
        test byte cs:mflag,1
        jz no_rreg
        mov dx,50412            ;65536* (1/1.3), for R reg. emulation
        mul dx
        mov ax,dx
no_rreg:
        mov cx,ax
        pop dx
        pop ax
        div cx
        sub bx,ax
        add dx,dx
        cmp dx,cx
        if a dec bx
        mov ax,bx
        mul word cs:bxcst
        mov ax,dx
        cmp ax,2
        jbe speed_fastest
        sub ax,4
        if c xor ax,ax
        inc ax
spd_gotit:
        pop bx
        test ax
        jnz spd_notzero
        mov ax,1
        test byte cs:debugflg,0ff
        jne spd_notzero
        test byte cs:winkey
        jne spd_notzero
        xor ax,ax
spd_notzero:
        mov cs:w[bx],ax
        ret


hoesnel:
;
;Nops needed for slowdown from v to v' for a T T-state instruction is
;k=N*18.2*(1000T/v' - 1000T/v)/3.5*10^6
;where v,v' are max,desired speed in promilles and N is the number of nops
;the computer executes in a 1/18.2 s timeslice. BXCST contains N/512.
;So, given k, the actual speed is
;v'=(v*c/[k*v/N + c] where c=T*1000*18.2/(3.5*10^6)=1744831/(512*65536)
;with T=10, which is a reasonable choice (above average (T=6) so it 'feels'
;the slowdown in the slower instructions, but not too high since it must
;reflect the starting treshold, the JMP to the slowdown routine)
;  The first jump takes about the time of 4 NOPs. k=0 corresponds to no
;slowdown, k=1 to JMP & no nops etc.
;
        mov ax,cs:relspd0
        test byte cs:mflag,1
        jz no_rreg2
        mov dx,50412            ;65536* (1/1.3), for R reg. emulation
        mul dx
        mov ax,dx
no_rreg2:
        mov bx,ax
        mov ax,cs:w[offset slowmod+12]          ;10 T state instruction
        test ax
        if nz add ax,3          ;treshold
        mul bx
        push bx                 ;save v (adjusted for R register emulation)
        mov cl,12               ;*65536/32 (=2^11)
        mov bx,cs:bxcst
shl_numer:
        add ax,ax
        adc dx,dx
        jc numer_toobig
        cmp dx,bx
        jae numer_toobig
        dec cl
        jnz shl_numer
        inc cl
        clc
numer_toobig:                   ;cl: 1+number of bits dxax is to be shiftlefted
        rcr dx,1
        rcr ax,1
        div bx
        push cx
        mov bx,54526            ;=(65536*512*10*1000*18.2/3.5M)/32
        dec cl
        if nz shr bx,cl
        pop cx
        add ax,bx
        pop dx                  ;v
        pushf
        if c rcr ax,1
        mov bx,ax
        mov ax,54526
        mul dx
        popf
        jnc hoesnel_nodiv2
        shr dx,1
        rcr ax,1
hoesnel_nodiv2:
        div bx
        add dx,dx
        cmp dx,bx
        if a inc ax
        dec cl
        if nz shr ax,cl
        push ax
        mov bx,ax
        mov ax,91               ;1000* (18.2/200)
        xor dx,dx
        div bx
        inc ax
        mov cs:maxtel,al
        mul bx
        mov bx,ax
        xor ax,ax
        mov dx,91
        div bx
        mov cs:addnum,ax
        pop ax
        ret



startup ends
