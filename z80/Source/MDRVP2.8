

;
;These routines emulate INs
;
in_ula: mov ah,0ff
        TEST BYTE ES:RFSHFLG
        jz in_finished          ;GEEF 0FF ALS IN REFRESH
        MOV AH,ES:INTEL
        INC AH
        cmp ah,2
        if e xor ah,ah
        MOV ES:INTEL,AH
        MOV AH,0FF
        jnz in_finished
        ADD ES:ATRSCR,24135
        jnc IN_attr
        MOV BX,ES:INTEL2
        ADD BX,7+3*256
        CMP BX,22528
        IF AE SUB BX,6144
        MOV AH,[BX]
        MOV ES:INTEL2,BX
        MOV BH,AH
        RETf
in_attr:
        MOV BX,ES:INTEL3
        ADD BX,4
        CMP BH,91
        IF AE SUB BH,3
        MOV AH,[BX]
        MOV ES:INTEL3,BX
in_finished:
        MOV BH,AH
        RETf


;
;These routines emulate INs
;
not_keyboard_far:
        cmp bl,0fd
        if z jmp in_128         ; ***** HMc MOD *****
        cmp byte ptr es:_disctype,16 ; +D hardware? ***** HMc *****
        jnc check4plusdin       ; ***** HMc *****
        cmp bl,0fb              ; IN 251 ***** HMc *****
        if z jmp zxprintin      ; jump if it is ***** HMc *****
        cmp bl,0bb              ; DISCiPLE page-in command?  ***** HMc *****
        jne check4disciple      ; jump if it is not ***** HMc *****
        cmp byte ptr es:_discinhibit,0   ; inhibit button in? GL mod
        je pagediscin0         ; jump if not.  GL mod
        cmp byte ptr es:_discinhibitflg,0     ; ROM paging disabled? ***** HMc *****
        jne  not_keyboard_far2   ; jump if it is ***** HMc *****

pagediscin0:
        jmp pagediscin          ; jump if it was  ***** HMc *****

check4disciple:
        push bx                 ; ***** HMc *****
        and bl,00011111b        ; ***** HMc *****
        cmp bl,00011011b        ; DISCiPLE out?  ***** HMc *****
        pop bx                  ; ***** HMc *****
        jne not_keyboard_far2   ; jump if not ***** HMc *****
        jmp far DISCiPLEIn      ; DISCiPLE in command  ***** HMc *****

check4plusdin:                  ; ***** HMc *****
        cmp bl,0e7h             ; page plus d in ***** HMc *****
        jne check4plusdin2      ; jump if not ***** HMc *****
        jmp pagediscin          ; jump if it is ***** HMc *****

check4plusdin2:                 ;On +D, no ZX printer is emulated, so let +D handle IN 251's (GL)
;        cmp bl,0fb              ; IN 251 ***** HMc *****
;        jne check4plusdin3      ; jump if it is not ***** HMc *****
;        cmp di,0f2c             ; IN 251 could be for ZX PRINTER, or ***** HMc *****
;        jnc check4plusdin3      ; IN data of PLUS D!  Therefore these checks ***** HMc *****
;        cmp byte ptr es:discflg,0ff ; are to see which is which! ***** HMc *****
;        je check4plusdin3       ; ***** HMc *****
;        jmp zxprintin           ; jump if it is ***** HMc *****
;
;check4plusdin3:                 ;  ***** HMc *****
        cmp bl,0f7              ; PRINTER IN ***** HMc *****
        jne check4plusdin4      ; jump if it is not ***** HMc *****
        jmp far PLUSDIn247      ; jump if it is ***** HMc *****

check4plusdin4:                 ; ***** HMc *****
        push bx                 ; ***** HMc *****
        and bl,11100111b        ; keep bits ***** HMc *****
        cmp bl,11100011b        ; +D ins? ***** HMc *****
        pop bx                  ; ***** HMc *****
        jne not_keyboard_far2   ; ***** HMc *****
        jmp far PLUSDIn         ; PLUS D in command ***** HMc *****

not_keyboard_far2:              ; ***** HMc *****
        test bl,255-31
        if z jmp in_kempston    ;and MGT printer busy, and PIO data A
not_kempston_after_all:
        mov ah,bl
        NOT BL
        AND BL,000011000XB
        AND BL,ES:B[IF1_ON]
        if nz jmp IF1_IN_POORT
        test ah,2               ;xxFD, only A15/14/1 decoded, are '128 ports
        if z jmp in_128
        cmp ah,0df              ;AMS mouse button
        je ams_mousebutton
        cmp ah,0bf              ;switch on multiface
        je switchon_m128_f
        cmp ah,03f              ;switch off multiface (or PIO data B)
        je switchoff_m128_f
        test ah,1               ;Bit 0=0, signalling keyboard?
        if nz jmp in_ula        ;No, then in from the screen data
        add sp,4                ;dump far return address
        jmp far in0_keyboard    ;continue in the normal keyboard in routine

switchon_m128_f:
        call switchon_m128
        mov ah,07f
        test byte es:hstate,8                ;screen bit
        if ne or ah,080
        mov bh,ah
        retf

switchoff_m128_f:
        call switchoff_m128
        cmp byte cs:amsmouse,0ff
        jne smf_noams
        mov ah,cs:rommod
        and ah,2
        je smf_amsmouse
        cmp ah,2
        jne smf_noams
smf_amsmouse:
        mov ah,cs:amsdatab
        mov bh,ah
        retf
smf_noams:
        mov ah,0ff
        mov bh,ah
        retf

ams_mousebutton:
        mov ah,0ff
        cmp byte cs:amsmouse,0ff
        if e mov ah,cs:amsdfvalue
        mov bh,ah
        retf

pagediscin:                             ; ***** HMc *****
        push ax                         ; ***** HMc *****
        cmp byte es:rommod,3            ; M.G.T.+48K?  ***** HMc *****
        if z mov byte es:discflg,0ff    ; set paged-in flag ***** HMc *****
        cmp byte es:rommod,6            ; M.G.T.+128K?  ***** HMc *****
        if z mov byte es:discflg,0ff    ; set paged-in flag ***** HMc *****
        cmp byte es:discflg,0ff         ; M.G.T. paged-in? ***** HMc *****
        jne pagediscin1                 ; jump if not  ***** HMc *****
        mov ax,1                        ; M.G.T. ROM  ***** HMc *****
        call swap_mem                   ; page ROM  ***** HMc *****
        mov ax,0ff00                    ;Low 8k=ram (0), Hi 8k=rom (0ff)
        cmp byte es:_disctype,8         ;0=disc,8=unidos,16=plus d
        if nc xchg al,ah                ;Not so with unidos (?) or plus d
        mov es:rompage1,ax
pagediscin1:                            ; ***** HMc *****
        pop ax                          ; ***** HMc *****
        retf                            ; return  ***** HMc *****


in_kempston:
        test bl,24
        if z jmp not_kempston_after_all
        cmp byte es:[disc_on],0ff       ; M.G.T. connected?  ***** HMc *****
        jne in_kempston1                ; jump if not  ***** HMc *****

        mov ah,byte cs:[offset dtr]     ;Get 'busy' flag of RS232 channel
        and ah,64
        and byte ptr es:b[discprnstatus],128 ; keep net status ***** HMc *****
        or byte ptr es:b[discprnstatus],ah ; save busy status ***** HMc *****

;        push ax                         ; ***** HMc *****
;        push dx                         ; ***** HMc *****
;        mov ah,2                        ; get printer status ***** HMc *****
;        mov dx,cs:zxprint               ; GL
;        int 017                         ; PRINTER SERVICES ***** HMc *****
;        and ah,128                      ; keep not busy flag ***** HMc *****
;;        xor ah,128                      ; change to busy flag ***** HMc *****
;        shr ah,1                        ; move to bit 6 ***** HMc *****
;        and byte ptr es:b[discprnstatus],128 ; keep net status ***** HMc *****
;        or byte ptr es:b[discprnstatus],ah ; save busy status ***** HMc *****
;        pop dx                          ; ***** HMc *****
;        pop ax                          ; ***** HMc *****

        mov ah,es:b[kempston_state]     ; get kempston joystick status  ***** HMc *****
        or  ah,es:b[discprnstatus]      ; get disciple PRINTER & Net Status  ***** HMc *****
        mov bh,ah                       ; ***** HMc *****
        retf                            ; ***** HMc *****
in_kempston1:
        cmp byte cs:amsmouse,0ff
        jne in_kempston2
        mov ah,cs:rommod
        and ah,2
        je in_kemp_amsmouse
        cmp ah,2
        jne in_kempston2
in_kemp_amsmouse:
        mov ah,cs:amsdataa
        mov bh,ah
        retf
in_kempston2:
        MOV AH,ES:B[KEMPSTON_STATE]     ;HAAL STATUS KEMPSTON JOYSTICK OP.
        MOV BH,AH
        RETf



IF1_IN_POORT:
        mov ah,al
        in al,021
        push ax
        and al,0fe              ;voor evt. aanroepen van DOS
        out 021,al
        CALL IN_IF1             ;see above
        pop bx
        mov al,bl
        out 021,al
        mov al,bh
        MOV BH,AH
        RETf


zxprintin:                      ;Modified for v3.04
        mov ah,cs:zxprstatus    ;8=IO error -> zx printer not attached
        xor ah,010+080          ;010=!off line, 080=!busy, 020=out of paper
        mov bh,081              ;means: stylus is here, encoder says go ahead
        test ah,1+010+020+080
        je zxprintin_nobusy
        mov bh,1                ;means: wait for stylus (but encoder says OK)
        cmp cs:zxprbusy,0ff     ;if -xj not given, then return 'no zx prtr'
        if ne mov bh,0ff
zxprintin_nobusy:
        test ah,8
        if ne mov bh,0ff        ;means: zx printer not attached (bit 6=1)
        mov ah,bh
        retf


in_128: cmp bh,0ff
        mov bh,0ff
        jnz in_128_retf
        mov bl,cs:lastfffd
        and bl,15
        cmp bl,14
        jne in_128_normal
READ_BIT128:
        and bh,03f
        cmp byte cs:dtr,0ff
        if nz or bh,64
        retf
in_128_normal:
        mov bh,0
        mov bh,cs:[offset sstate+bx]
in_128_retf:
        retf

switchon_m128:
        cmp byte cs:_m128_on,0
        je ret
        cmp byte cs:rommod,2        ;samram?
        je ret
        mov byte cs:m128flg,0ff
        mov word cs:rompage1,0ff    ;lower 8k rom; hi 8k ram
        mov ax,11
        call swap_mem
        ret

switchoff_m128:                     ;DESTROYS BX!! (via pagin_n_rom_far)
        xor al,al
        xchg byte cs:m128flg,al
        test al
        je ret
        mov al,cs:if1flg
        or al,cs:discflg
        jne switchoff_if1disc
        call far pagin_n_rom_far
        ret
switchoff_if1disc:
        mov word cs:rompage1,-1     ;all rom
        mov ax,1
        call swap_mem
        ret







;
;Now the routines that emulate OUTs follow:
;

no_speaker_far:
        cmp bl,0fd
        if z jmp out_128
        cmp byte ptr es:disc_on,0ff     ; DISCipLE/+D connected? ***** HMc *****
        jne no_speaker_far2             ; jump over MGT stuff if not
        cmp byte ptr es:_disctype,16    ; PLUS D hardware? ***** HMc *****
        jnc check4plusdout              ; jump if it is ***** HMc *****
        cmp bl,0bb                      ; page disciple out? ***** HMc *****
        if z jmp pagediscout            ; jump to check ***** HMc *****
        cmp bl,0fb                      ; ***** HMc 8/94 *****
        if z jmp zxprinter_out          ; ***** HMc 8/94 *****; GL mod 21/10/94
        push bx                         ; ***** HMc *****
        and bl,00011111b                ; DISCiPLE command?
        cmp bl,00011011b                ; ***** HMc *****
        pop bx                          ; ***** HMc *****
        jne no_speaker_far2             ; if not handle other things
        jmp far DISCiPLEOut             ; DISCiPLE out  ***** HMc *****
        
check4plusdout:                         ; ***** HMc *****
        cmp bl,0e7                      ; page +D out? ***** HMc *****
        if z jmp pagediscout            ; jump if it is ***** HMc *****
        cmp bl,0ef                      ; select drive&side? ***** HMc *****
        if z jmp far PLUSDOut239        ; jump if it is ***** HMc *****
        cmp bl,0f7                      ; printer out? ***** HMc *****
        if z jmp discprinterout         ; ***** HMc *****
        push bx                         ; ***** HMc *****
        and bl,11100111b                ; keep bits ***** HMc *****
        cmp bl,11100011b                ; +D out? ***** HMc *****
        pop bx                          ; ***** HMc *****
        jne no_speaker_far2             ; jump if not ***** HMc *****
        jmp far PLUSDOut                ; +D out ***** HMc *****

no_speaker_far2:                        ; ***** HMc *****
        TEST BL,011100000XB
        jne no_31
        cmp byte es:rommod,2
        je samram_out_31                ; ***** HMc MOD *****
        cmp byte es:disc_on,0ff         ;disciple connected?
        jne no_31
        jmp far DISCiPLEOut31           ; ***** HMc *****
NO_31:
        cmp bl,0fb
        jz zxprinter_out
        test bl,2                       ;0xxFD, only A15, A14 and A1 decoded,
        if z jmp out_128                ; is the '128 port (Two Weeks in Paradise 128)
        NOT BL
        TEST BL,011000XB
        jz check_ams
        push ax
        in al,021
        push ax
        and al,0fe
        out 021,al
        CALL OUT_IF1
        pop ax
        out 021,al
        pop ax
        retf

check_ams:
        cmp bl,0a0                      ;= NOT 5f = PIO ctrl A
        je ams_ctrla
        cmp bl,080                      ;= NOT 7f = PIO ctrl B
        je ams_ctrlb
        retf
ams_ctrla:
        xor bx,bx
        jmp ams_ctrl
ams_ctrlb:
        mov bx,1
ams_ctrl:
        test ah,1                       ;set interrupt vector
        je ams_c_ivec
        test ah,8                       ;set interrupt enable flag
        je ams_c_ief                    ;otherwise 1111=set mode
        rol ah,1
        rol ah,1
        and ah,3
        mov cs:[amsmodea+bx],ah
        retf
ams_c_ief:
        and ah,080
        rcl ah,1
        sbb ah,ah
        mov cs:[amsienablea+bx],ah
        retf
ams_c_ivec:
        mov cs:[amsiveca+bx],ah
        retf


zxprinter_out:
        jmp far zxprintout

samram_out_31:                          ; ***** HMc *****
        TEST ES:B[IN31TAB+2],0FF        ;is er een out 31,5 geweest?
        jnz end_out
        MOV BL,AH
        AND BX,01111XB
        SHR BX,1
        SBB AH,AH
        CMP ES:[BX+IN31TAB],AH
        MOV ES:[BX+IN31TAB],AH
        jz end_out
        push ax
        cmp bl,6
        jz samram_beep
        cmp bl,5
        jz switch_ram
        TEST ES:BYTE IF1FLG,0FF         ;is the if1 rom active?
        JnZ end_out_popax               ;if so, don't switch any roms
        cmp bl,1
        jz enable_normal
        cmp bl,3
        jz enable_shadow
end_out_popax:
        pop ax
END_OUT:
        retf

samram_beep:
        MOV AL,1                ;ZET BIEPER AAN/UIT
        OUT 042,AL              ;pitch
        OUT 042,AL
        IN AL,061
        AND AX,0000001111111100XB
SILENT2 EQU $-1
        OR AL,AH
        OUT 061,AL
        pop ax
        retf

ENABLE_NORMAL:
        and ah,ah               ;nonzero: page normal rom
        mov ah,es:[in31tab+3]   ;which samram rom should be paged?
        jz enable_shadow_2
        mov ax,0
        call swap_mem
        pop ax
        retf

enable_shadow:
        TEST ES:B[IN31TAB+1],0FF
        JNZ end_out_popax            ;exit if standard rom is on
enable_shadow_2:
        and ah,ah
        mov ax,2
        if nz inc al            ;ordinary samrom or 2nd samrom
        call swap_mem
        pop ax
        retf

SWITCH_RAM:
        test ah,ah              ;which bank?
        mov ax,0204
        if nz mov al,6
        push ax
        call swap_mem
        pop ax
        add ax,0101             ;2nd 16K block
        call swap_mem
        pop ax
        retf


PAGEIN_IF1_ROM:
        push ax
        TEST BYTE ES:IF1_ON
        JnZ pagein_if1          ; ***** HMc *****
        cmp byte es:disc_on,0ff ; is DISCiPLE present?  ***** HMc *****
        jnz pir_retf            ; jump if not present  ***** HMc *****
        mov byte es:discflg,0ff ; ***** HMc *****
        test byte es:m128flg,0ff
        jne pir_retf
        mov ax,0ff00            ;Low 8k=ram (0), Hi 8k=rom (0ff)
        cmp byte es:_disctype,8 ;0=disc,8=unidos,16=plus d
        if nc xchg al,ah        ;Not so with unidos (?) or plus d
        mov es:rompage1,ax
        jmp pagein_if1c         ; ***** HMc *****

Pagein_if1:
        mov byte es:if1flg,0ff
        test byte es:m128flg,0ff
        jne pir_retf
        mov word es:rompage1,-1 ;all ROM

Pagein_if1C:                    ; ***** HMc *****
        mov ax,1
        call swap_mem
pir_retf:
        pop ax
        RETf


pagediscout:                            ; ***** HMc *****
        cmp es:rommod,3                 ; 48K+DISCiPLE?  ***** HMc *****
        je pagediscout1                 ; jump if it is  ***** HMc *****
        cmp es:rommod,6                 ; 128K+DISCiPLE?  ***** HMc *****
        if ne jmp END_OUT               ; jump if it is not  ***** HMc *****

pagediscout1:                           ; ***** HMc *****
        push ax                         ; DESTROYS BX!
        call far pagin_n_rom_far        ; ***** HMc *****
        pop ax
        jmp END_OUT                     ; ***** HMc *****


discprinterout:                         ; ***** HMc *****
;        cmp byte ptr es:disc_on,0ff     ; ***** HMc 8/94 *****
;        if ne jmp far zxprintout        ; ***** HMc 8/94 *****
;        cmp byte ptr es:discflg,0ff     ; ***** HMc 8/94 *****
;        if ne jmp far zxprintout        ; ***** HMc 8/94 *****

        mov al,ah
        call write_savereg

;        push ax                         ; ***** HMc *****
;        push dx                         ; ***** HMc *****
;        mov al,ah                       ; byte to output ***** HMc *****
;        mov dx,cs:zxprint               ; GL
;        mov ah,0                        ; send byte ***** HMc *****
;        int 017                         ; PRINTER SERVICES ***** HMc *****
;        pop dx                          ; ***** HMc *****
;        pop ax                          ; ***** HMc *****
        retf





out_128:
        cmp byte cs:rommod,4    ; ***** HMc MOD *****
        jb not_in_128mode
        or bh,03f
        cmp bh,0bf
        jz out_128_soundchip
        cmp bh,0ff
        jz out_128_soundreg
        jmp out_128_banksw      ; trigger on all A15=0 (and low=FD) addresses
not_in_128mode:
        retf

out_128_soundreg:
        and ah,0f
        mov cs:lastfffd,ah
        MOV WORD CS:RS_OUT,0
out_128_return:
        retf

out_128_soundchip:
        mov bl,cs:lastfffd
        and bx,0f                       ;was: cmp bl,f/ja out_128_rtrn/clear bh
        mov cs:b[offset sstate+bx],ah
        cmp bl,14
        if e jmp out_128_rs232
        cmp byte cs:silence,0
        jnz out_128_return
        cmp byte cs:intsnd,0ff
        if z jmp out_128_internal
        cmp byte cs:adlib,0
        jz out_128_return
        cmp bl,6
        jb out_128_s_freq
        je out_128_noise
        cmp bl,7
        if z jmp out_128_s_control
        cmp bl,11
        if b jmp out_128_amplitude
        cmp bl,13
        if e jmp out_128_envcontrol
        if b jmp out_128_envperiod
        retf

out_128_noise:
        cmp byte cs:cmschips,0ff
        jnz out_128_nn
        push ax
        push cx
        mov cl,3
        shl ah,cl
        if z mov ah,8
out_128_schuif:
        shl ah,1
        jc out_128_klaar
        inc cl
        jmp out_128_schuif
out_128_klaar:
        inc cl
        cmp cl,8
        jnz out_128_n_ok
        mov cl,7
        xor ah,ah
out_128_n_ok:
        not ah
        mov al,8
        call cms_write          ;tone
        mov ah,cl
        mov al,010              ;octave
        call cms_write
        pop cx
        pop ax
out_128_nn:
        retf

;'128 sound chip: Frequency = 110830 / register value (from 1 to 4095) Hz
;Adlib sound chip: Frequency = 50000 * 2^-20 * reg.value (0-1023) * 2^octave (0-7)
;So Adlib reg = 2324273 / '128 reg (hex 237731)
out_128_s_freq:
        push ax
        push dx
        and bl,6
        push bx
        mov bx,cs:b[offset sstate+bx]
        and bx,4095                     ;keep only 12 bits
        cmp bx,17
        if be mov bx,18
        cmp bx,35
        jbe out_128_highfreq
        mov ax,07731
        mov dx,023
        div bx                  ;AX now contains the F number for octave 0
        shr bx,1
        cmp bx,dx
        adc ax,0                ;round to nearest value
        mov dl,0
out_128_sf_three:
        test ah,0f0             ;Is there a one in position 12 or higher?
        je out_128_sf_one
        add dl,3*4              ;octave * 4
        shr ax,1
        shr ax,1
        shr ax,1
        jmp out_128_sf_three
out_128_sf_one:
        test ah,0fc             ;Is there a one in position 10 or higher?
        je out_128_sf_shifted
        add dl,4
        shr ax,1
        jmp out_128_sf_one
out_128_sf_shifted:
        pop bx                  ;bl=channel number * 2
        push ax                 ;save F number
        mov ah,al               ;transfer data to ah
        shr bl,1
        mov al,bl
        add al,0a0              ;add offset for register
        call adlib_writep
        pop ax                  ;ah contains the upper two bits of F number
        or ah,dl                ;include the octave number
        mov al,bl
        add al,0b0              ;add offset
        or ah,32                ;voice channel
        call adlib_write
        pop dx
        pop ax
        retf
out_128_sf_out:
        pop bx
        pop dx
        pop ax
        retf
out_128_highfreq:
        mov ax,046ee            ;2324273/128
        xor dx,dx
        div bx
        mov dl,7*4              ;octave 7
        jmp out_128_sf_shifted




out_128_s_control:
        push ax
        push di
        xor di,di
        mov bl,ah
        mov bh,ah
        xor bh,cs:b[offset s_oldctrl]
        mov cs:b[offset s_oldctrl],bl
out_128_c_loop:
        mov ax,di
        add al,043
        shr bh,1
        jnc out_128_c_nochange
        shr bl,1
        jnc out_128_c_active
        mov ah,63
        call adlib_writep               ;switch off channel (amplitude 0)
        jmp short out_128_c_nochange_1
out_128_c_active:
        mov ah,cs:b[offset sstate+8+di]
        test ah,16
        if nz mov ah,cs:b[offset envcur]
        and ah,15
        shl ah,1
        shl ah,1
        xor ah,63
        call adlib_writep               ;switch on channel
        shl bl,1
out_128_c_nochange:
        shr bl,1
out_128_c_nochange_1:
        inc di
        cmp di,3
        jb out_128_c_loop
        test bh,7
        je out_128_c_nonoise
        call upd_noise
out_128_c_nonoise:
        pop di
        pop ax
        retf

out_128_rs232:
        push ax
        shr ah,1
        shr ah,1
        shr ah,1
        sbb al,al
        mov cs:cts128,al
        mov word cs:rs_in,0
        SHR AH,1
        cmc
        RCR WORD CS:RS_OUT,1
        TEST WORD CS:RS_OUT,080
        JZ out_128_r
        MOV AL,CS:B[OFFSET RS_OUT+1]
        not al
        CALL WRITE_SAVEREG
        MOV WORD CS:RS_OUT,0
out_128_r:
        pop ax
        RETf


upd_noise:                              ;destroys ax and bx
        cmp byte cs:adlib,0
        jz ret
        push cx
        xor ah,ah
        mov cl,cs:b[offset sstate+7]
        or cl,0ff-56
        not cl
        shr cl,1
        shr cl,1
        shr cl,1
        mov bx,offset sstate+8          ;amp regs
upd_n_1:
        shr cl,1
        jnc upd_n_2
        mov al,cs:b[bx]
        test al,16
        if nz mov al,cs:envcur
        and al,15
        cmp al,ah
        if a mov ah,al
upd_n_2:
        inc bx
        test cl
        jnz upd_n_1
        test byte cs:cmschips
        jne upd_noise_cms
;keer drie
        mov al,ah
        add ah,ah
        add ah,al
        xor ah,63
        mov al,054                      ;operator 17, reg. 14h, snaredrum volume
        call adlib_write
        pop cx
        ret
upd_noise_cms:
        mov al,192
        mul ah
        mov al,ah
        add al,al
        add al,al
        add al,al
        add al,al
        or ah,al
        xor al,al
        call cms_write                  ;amplitude of noise
        pop cx
        ret



out_128_amplitude:                      ;registers 8-10
        push bx
        cmp bl,10
        sbb bl,6                        ;8,9,10 -> 1,2,4
        test cs:b[offset sstate+7],bl
        pop bx
        push ax
        jnz out_128_amp_off
        add bl,043-8
        test ah,16
        jz out_128_amp_normal
        mov ah,cs:envcur
out_128_amp_normal:
        and ah,15
        jz out_128_off
        xor ah,15
        shl ah,1
        shl ah,1
out_128_off2:
        mov al,bl
        call adlib_writep
out_128_amp_off:
        call upd_noise
        pop ax
        retf
out_128_off:
        mov ah,03f
        jmp out_128_off2

out_128_envcontrol:
        push ax
        test ah,4
        mov al,0
        if z mov al,15
        mov cs:b[envcur],al
        and al,2
        xor al,2
        dec al
        mov cs:b[envadd],al
        test ah,8
        jz out_128_notcont
        mov al,ah
        test ah,2
        if nz not al
        test ah,4
        if nz not al
        and al,1
        dec al
        and al,0f
        mov cs:b[env2nd],al
        and al,2
        xor al,2
        dec al
        test ah,1
        if nz xor al,al
        mov cs:b[env2add],al
        and ah,0ff-4
        cmp ah,10
        mov al,0
        if z dec al
        mov cs:b[envtog],al
        jmp short out_128_env_upd
out_128_notcont:
        mov cs:b[env2nd],0
        mov cs:b[env2add],0
        mov cs:b[envtog],0
out_128_env_upd:
        mov word cs:envnumlo,0
        xor ax,ax
        push dx
        call upd_chan2
        pop dx
        pop ax
        retf

;Envelope timer is being counted down with a freq. of 111760 Hz
;on the '128. Each tick, the amplitude is changed by 1/16th of the total amount.
;The emulator's internal timer operates at 200 Hz
out_128_envperiod:
        push ax
        push dx
        mov bx,cs:w[offset sstate+11]
        cmp bx,37
        jb out_128_ep_ret
        cmp bx,559
        jb out_128_ep_fast
        mov ax,0cccd                    ;dxax=36621517=111760*65536/200
        mov dx,022e
        div bx
        mov cs:envaddlo,ax
        mov word cs:envaddhi,0
out_128_ep_ret:
        pop dx
        pop ax
some_retf:
        retf
out_128_ep_fast:
        mov ax,0eccd                    ;dxax=2288845, 1/16th of above
        mov dx,022
        div bx
        mov bx,16
        mul bx
        mov cs:envaddlo,ax
        mov cs:envaddhi,dx
        jmp out_128_ep_ret


out_128_banksw:                         ;is also called from _reset_page5
        cmp byte cs:rommod,4            ;HMc
        jb some_retf                    ;return if emulator not in 128 mode
        push ax
        mov al,cs:hstate
        test al,32
        jnz out_128_popax               ;If bit 5=1, ignore output to this port
        mov cs:hstate,ah
        xor al,ah
        test al,7
        jz out_128_nobanksw
        push ax
        mov al,ah
        and al,7
        mov ah,3                        ;swap in area c000-ffff
        add al,ah                       ;internal 3-10 is ram pages 0-7
        call swap_mem
        pop ax
out_128_nobanksw:
        xor bx,bx
        test ah,8
        je out_128_screen               ;Jump if screen in bank 5
        mov bx,08000
        cmp byte cs:[ramstate+3],10
        je out_128_screen               ;Jump if page 7 (screen) is in bank 3
        mov bx,0ffff                    ;Signal: Screen hidden
out_128_screen:
        mov cs:vgahcrscroffset,bx
        test al,16
        jz out_128_popax
        test byte cs:if1flg,0ff         ;is if1 rom switched on?
        jnz out_128_popax
        test byte cs:m128flg,0ff        ;is multiface paged?
        jnz out_128_popax
        mov al,ah
        and ax,16
        xor al,16                       ;ordinary specrom is page 0
        shr al,1
        shr al,1
        shr al,1                        ;swap in rom area, page 0 or 2.
        call swap_mem
out_128_popax:
        pop ax
        retf



;
;this routine is called from the timer. AL holds # steps
;
update_channels:
        mov ah,cs:envadd
        test ah
upd_chan2:
        jz upd_ampok            ;hold
        if s neg al
        add al,cs:envcur        ;add to amplitude
        mov cs:envcur,al
        test al,0f0
        jz upd_ampok            ;no overflow
        if s not al
        and al,15               ;leftover
        inc al
        mov dx,word cs:[offset env2nd]        ;and env2add
        mov cs:w[offset envcur],dx            ;copy 2nd period info
        test byte cs:envtog
        jz update_channels
        neg byte cs:env2add
        xor byte cs:env2nd,0f
        jmp update_channels
upd_ampok:
        cmp byte cs:adlib,0ff
        jnz upd_int
        mov ah,cs:envcur
        and ah,15
        shl ah,1
        shl ah,1
        xor ah,63
        test byte cs:[offset sstate+8],16
        jz upd_noe_1
        test byte cs:[offset sstate+7],1        ;is channel a on?
        jnz upd_noe_1
        mov al,043
        push ax
        call adlib_writep
        pop ax
upd_noe_1:
        test byte cs:[offset sstate+9],16
        jz upd_noe_2
        test byte cs:[offset sstate+7],2        ;is channel b on?
        jnz upd_noe_2
        mov al,044
        push ax
        call adlib_writep
        pop ax
upd_noe_2:
        push ax
        test byte cs:[offset sstate+10],16
        jz upd_noe_3
        test byte cs:[offset sstate+7],4        ;is channel c on?
        jnz upd_noe_3
        mov al,045
        call adlib_writep
upd_noe_3:
        push bx
        call upd_noise
        pop bx
        pop ax
        ret
upd_int:
        push cs
        call update_internal
        ret


out_128_internal:
        cmp bl,6
        jb out_128_s_freq_int
        je out_128_i_retf
        cmp bl,7
        jz update_internal
        cmp bl,11
        jb update_internal
        cmp bl,13
        if e jmp out_128_envcontrol
        if b jmp out_128_envperiod
out_128_i_retf:
        retf
out_128_s_freq_int:
update_internal:
        push ax
        push bx
        push cx
        push dx
        push si
        mov si,-1
        mov bx,0
        mov ah,cs:b[offset sstate+7]
        mov cx,20
ui_1:
        mov al,cs:b[offset sstate+8+bx]
        and al,31
        test al,16
        if ne mov al,cs:envcur
        shl al,1
        shr ah,1
        jc ui_turnedoff
        shl bx,1
        mov dx,cs:w[offset sstate+bx]
        shr bx,1
        cmp dx,034f
        if b inc al
        cmp dx,0240
        if b inc al
        cmp dx,01a8
        if b inc al
        cmp dx,0100
        if b inc al
        cmp dx,0d4
        if b inc al
        cmp dx,020
        if b dec al
        cmp dx,0f
        if b dec al
        cmp dx,si
        if b add al,3
        cmp al,cl
        jbe ui_turnedoff
ui_turnedon:
        mov cl,al
        mov si,dx
ui_turnedoff:
        inc bx
        cmp bx,3
        jb ui_1
        cmp si,-1
        jz beep_off
;Freq '128 chip = 110830 / regvalue (1..4095)
;Freq pc chip = 1192755 / regvalue (1..65535)
;256 * 1192755 / 110830 =2755
        mov ax,si
        mov dx,2755
        mul dx
        mov al,ah
        out 042,al
        mov al,dl
        out 042,al
        in al,061
        or al,3
        jmp ui_finished
beep_off:
        in al,061
        and al,011111100xb
        mov ah,byte cs:newbor
        and ah,010
        add ah,-16
        sbb ah,ah
        and ah,2
        or al,ah
ui_finished:
        out 061,al
        pop si
        pop dx
        pop cx
        pop bx
        pop ax
        retf









allocate_memory:
        mov ah,048
        mov bx,750              ;12000 bytes, >8192
        test word cs:_nohcrmem  ;Should HCR mem buffers be allocated?
        if nz mov bx,512        ;take 8192 bytes if not
        int 021
        if c jmp not_enough
        mov cs:vgahcrborbuf,ax  ;12000 byte VGA hi color res border buffer
        sub ax,1024
        mov cs:vidbufseg,ax     ;vidbufseg:16384 points to 8192 byte buffer
        mov ah,048
        mov bx,256              ;4096 bytes to hold terminal screen at startup
        int 021
        if c jmp not_enough
        mov cs:w[offset scrnbuffer],0
        mov cs:w[offset scrnbuffer+2],ax
        mov ah,048
        mov bx,1090             ;>32*21f
        int 021
        if c jmp not_enough
        mov cs:mdrvseg,ax
        test word cs:_nohcrmem
        jne novgahcr
        mov ah,048
        mov bx,2048
        int 021
        if c jmp not_enough
        mov cs:vgahcrbuf,ax     ;32k VGA hi color res. buffer
        mov es,ax
        xor di,di
        cld
        xor ax,ax
        mov cx,16384
        rep stosw               ;also important for op code mapping!
novgahcr:
        mov ah,048
        mov bx,cs:outlogbuflen
        shr bx,1
        shr bx,1
        shr bx,1
        shr bx,1
        int 021
        if c jmp not_enough
        mov cs:outlogbufseg,ax
        mov ah,048
        mov bx,cs:vocbuflen     ;48k or 8192 bytes
        shr bx,1
        shr bx,1
        shr bx,1
        shr bx,1
        int 021
        if c jmp not_enough
        mov cs:vocbufseg,ax     ;48k voc file buffer
        cmp byte cs:expmem,0ff
        if nz jmp no_exp_mem2
        xor ax,ax
        mov es,ax
        mov ax,es:[067*4+2]
        mov es,ax
        mov ax,es:[0a]
        cmp ax,'E'+256*'M'
        jnz no_exp_mem
        xor ax,es:[0c]
        xor ax,es:[0e]
        xor ax,es:[010]
        cmp ax,07d08
        jnz no_exp_mem
        mov ah,041
        int 067
        test ah,ah
        jnz no_exp_mem
        mov cs:specseg,bx
        mov cs:romseg,bx
        mov ah,043              ;allocate
        mov bx,12               ;12 16K pages
        int 067
        test ah,ah
        jnz no_exp_mem
        mov cs:emshandle,dx
        push dx
        mov dx,emsmes
        mov ah,9
        push cs
        pop ds
        int 021
        pop dx
        mov ax,04400            ;map memory
ems_loop:
        push ax
        xor bx,bx               ;logical page 0
        int 067
        test ah,ah
        jnz ems_err
        pop ax
        inc al
        cmp al,4
        jb ems_loop
        mov bx,0400             ;16K samram-speedup-buffer
        mov ah,048
        int 021                 ;(see instructions ED F*)
        jnc enough_mem
        mov ah,045
        int 067
        jmp not_enough
enough_mem:
        mov cs:samseg,ax
        mov byte cs:sambank,0
        ret
no_exp_mem:
        push cs
        pop ds
        mov ah,9
        mov dx,noemsmes
        int 021
no_exp_mem2:
        mov bx,04000            ;64K Z80 mem, 48K roms, 128K ram banks (128), multiface rom
        mov ah,048
        int 021
        if c jmp not_enough     ;in z80p2.8
        mov cs:specseg,ax
        add ax,01000
        mov cs:romseg,ax
        ret
ems_err:
        mov ah,045
        int 067                 ;deallocate handle
        mov dx,offset emserr
        jmp enderr


restore_ems:
        mov dx,cs:emshandle
        test dx,dx
        jz ret
        xor bx,bx
restore_ems_1:
        push bx
        mov al,bl
        mov bl,cs:b[offset ramstate+bx]
        mov ah,044
        int 067
        pop bx
        inc bx
        cmp bx,4
        jb restore_ems_1
        ret

;
;The following subroutine actually pages the various roms, and swaps
;the ram pages. AL (0-11) specifies the page to swap in, AH (0-3) specifies
;the Z80 bank the page is to be swapped into. It destroys only the AX register.
;
swap_mem:
        push bx
        mov bl,ah
        xor bh,bh
        cmp cs:b[offset ramstate+bx],al
        if z jmp swap_mem_same
        cmp al,11
        if a jmp swap_mem_same
        push dx
        mov dx,cs:emshandle
        test dx,dx
        jz swap_noems
        mov cs:b[offset ramstate+bx],al
        mov bl,al
        xor bh,bh
        mov al,ah
        mov ah,044
        int 067
        pop dx
        pop bx
        ret
swap_noems:
        pop dx
        push si
        push di
        push cx
        push es
        push ds

        mov ch,8192/256         ;16 K bytes
        cmp cs:disc_on,0ff    ; ***** HMc *****
        je no_ems1            ; ***** HMc *****
        cmp ax,1                ;swap in if1 rom?
        jnz not_if1swap
        mov ch,4096/256
        mov cl,cs:b[offset ramstate]    ;fetch previously active rom
        test byte cs:if1sw      ;0ff means: switch entire 16K of if1 rom
        je no_ems2              ; ***** HMc MOD *****
no_ems1:                        ; ***** HMc *****
        mov cx,8192+255         ; ***** HMc *****
no_ems2:                        ; ***** HMc *****
        mov cs:actrom2,cl       ;0ff if entire 16K switched, otherwise other rom
        jmp not_rompage
not_if1swap:
        test ah                 ;Pageing a rom?
        jnz not_rompage
        cmp al,cs:actrom2       ;Is 2nd part of rom OK already?
        if z mov ch,4096/256    ;If so, only switch back first 8K of it
        mov cs:actrom2,al
not_rompage:
        xor cl,cl
        ror ah,1
        ror ah,1
        mov di,ax
        and di,0c000

;        cmp cs:disc_on,0ff    ; ***** HMc *****
;        je not_rompage1         ; ***** HMc *****
;        cmp ah,040              ;the ram banks must be swapped, not just
;        jb just_pagein          ; paged.
;not_rompage1:                   ; ***** HMc *****
;        push ax
;        mov al,cs:b[ramstate+bx]       ;Get old pagenumber, save new
;        cmp cs:disc_on,0ff    ; ***** HMc *****
;        je not_rompage2         ; ***** HMc *****
;        cmp al,2                ;Do not save changes in ROM (r.s.=0,1)
;        js just_pagein_popax    ;Also, ignore data in inactive pages (r.s.=ff)
;not_rompage2:                   ; ***** HMc *****

        push ax                     ;save new page number
        mov al,cs:b[ramstate+bx]    ;get old
        cmp al,1                    ;Ignore data in bank 0 (always ROM) and
        js just_pagein_popax         ; in inactive pages (0ff)
        je sm_testbank1             ;Bank 1 is ram with disciple, otherwise rom
        cmp al,3
        je sm_testsamram            ;bank 3 is rom with samram, otherwise ram
        jb just_pagein_popax         ;bank 2 is always rom (if it is anything at all)
        jmp short sm_keepram

sm_testbank1:
        test byte cs:disc_on
        je just_pagein_popax         ;if no disciple, bank 1 is rom
        jmp short sm_keepram

sm_testsamram:
        cmp byte cs:rommod,3        ;samram?
        je just_pagein_popax         ;if not, bank 3 is page 0 of '128, so continue

sm_keepram:
        mov bh,al               ;save old pagenumber in bh, is made zero below
        add al,al
        add al,al
        mov ah,0
        xchg al,ah
        add ax,cs:romseg
        mov es,ax
        xor si,si
        push di
        push cx
        xchg si,di              ;es:di = es:00 -> buffer, specseg:si -> z80 bank
        mov ds,cs:specseg
        cld
        push si
        rep movsw
        pop si
        test bl,1               ;This is not fully symmetrical, but well, it works.
        je swm_nodouble         ;It cannot be perfect in this mem. mode anyway, so I don't
        mov di,si               ; worry about this imperfection
        xor di,08000
        mov al,cs:b[ramstate+1]         ;was old page active twice?
        cmp al,cs:b[ramstate+3]
        je swm_double
        cmp bh,cs:b[ramstate+2]         ;could also have been active in bank 2
        jne swm_nodouble
        mov di,08000                    ;Note: it's impossible to have 3 banks
swm_double:                             ;paged at the same time
        cmp bh,2
        js swm_nodouble                 ;exclude the cases where the old page
        push ds                         ;was 0ff (inactive) or a ROM (0, see save)
        pop es
        mov cx,02000
        rep movsw               ;copy contents to other active bank too
swm_nodouble:
        pop cx
        pop di
        xor bh,bh
just_pagein_popax:
        pop ax
just_pagein:
        mov cs:b[ramstate+bx],al        ;By the way, 'memstate' would have been
        mov es,cs:specseg               ; a better name...
        mov bh,al
        add al,al
        add al,al
        mov ah,0
        xchg al,ah
        add ax,cs:romseg
        mov ds,ax
        cld
        test bl,1
        je swm_nodouble2
        mov si,di
        xor si,08000
        mov al,cs:b[ramstate+1]
        cmp al,cs:b[ramstate+3]
        je swm_double2
        cmp bh,cs:b[ramstate+2]
        jne swm_nodouble2
        mov si,08000
swm_double2:                            ;page is also active elsewhere
        cmp bh,2
        js swm_nodouble2
        push es
        pop ds
        rep movsw                       ;copy the page from the other active bank
        jmp short swm_exit
swm_nodouble2:
        xor si,si
        rep movsw               ;get the page from the internal banks
swm_exit:
        pop ds
        pop es
        pop cx
        pop di
        pop si
swap_mem_same:
        pop bx
        ret


swap_mem_far:
        call swap_mem
        retf


;
;The following important subroutine loads a .Z80 or a .SNA file from disk.
;Input is AX, which is zero is the file to load is a .Z80 file, or 1 if
;it is a .SNA file; bit 1=1 if no settings are to be changed (MFlag and
;Joytable), and BX which holds the handle of the file. The subroutine
;loads and unpacks the file, and after that it loads the romfile again if
;necessary. The spectrum segment is updated (right rom is put into place,
;ram banks are loaded). If AX is nonzero upon completion, there was (probably)
;an error in the .Z80 file format. (it could also have been a disk error)
;Exits with file open, file pointer pointing to end, or to 'SLT' letters of
;SLT separator.
;
load_z80_file:
        push ds
        push ax
        push bx
        mov word cs:vgahcrscroffset,0
        call reset_headervars           ;reset variables that are in v3 headers of .z80 files
        call mdrv_clearbuffer           ;the 16384 byte mdrv buffer is used
        push cs                         ; in load_version2_z80file
        pop ds
        pop bx
        mov ax,0108                     ;standard page layout for spec and samram
        call swap_mem
        mov ax,0204
        call swap_mem
        mov ax,0305
        call swap_mem
        pop ax
        mov dx,offset rfa
        test al,1
        if nz jmp load_sna_file
        push ax
        mov cx,30                       ;length v1 header
        mov ah,03f
        int 021
        pop dx                          ;dl=mode byte
        if c jmp lzf_error_close
        cmp ax,30
        if nz jmp lzf_error_close
        mov al,cs:rr_bit7
        cmp al,255
        if z mov al,1
        MOV AH,AL
        AND AH,1
        NEG AH
        MOV cs:RR_BIT7,AH
        SHR AL,1
        MOV cs:NEWBOR,AL
        cmp word cs:rpc,0
        if z jmp load_version23_z80file
        cmp cs:rommod,3         ;mgt, or 128k with anything? (i.e. hardware modes
        if ae mov cs:rommod,1   ; not existing in v1) Then switch on 48k+if1
        mov byte cs:hstate,0    ;default state of 74ls259
        mov byte cs:if1flg,0
        push ax                 ;save 'compression' bit
        push bx
        call load_romfile
        pop bx
        mov ds,cs:specseg
        mov dx,04000            ;POINT NAAR SCHERM
        mov cx,0c000            ;MAXIMAAL 49152 BYTES=48K
        mov ah,03f
        int 021                 ;LAAD PROGRAMMA
        pop cx                  ;compr. bit in cl & 16
        if c jmp lzf_error_close
        push ax                 ;length of data file
        mov ah,03e              ;close handle
        int 021
        pop ax
        TEST cl,16
        JZ niet_uitpakken
        CALL DESCRUNGEIT
        jmp uitpakken_klaar
niet_uitpakken:
        cmp ax,49152
        if nz stc
UITPAKKEN_KLAAR:
        pop ds
        mov ax,1
        jc ret
        xor ax,ax
        cmp cs:rommod,2
        jne ret
        push ds
        jmp ims_pages_ok        ;to convert hstate to outs to address 31
        ret

load_sna_file:
        mov cx,27
        mov ah,03f
        int 021
        if c jmp lzf_error_close
        cmp ax,27
        if nz jmp lzf_error_close
        mov byte cs:rommod,0    ;no if1
        mov byte cs:if1flg,0    ;not paged in
        push bx
        call load_romfile
        pop bx
        mov ds,cs:specseg
        mov dx,04000            ;wijs naar scherm
        mov cx,0c000            ;lees 48K bytes
        mov ah,03f
        int 021                 ;LAAD PROGRAMMA
        if c jmp lzf_error_close
        cmp ax,cx
        if ne jmp lzf_error_close
;        mov ah,03e              ;close handle
;        int 021
        push es
        push si
        push cs
        pop ds
        push cs
        pop es
        mov al,b[offset rfa+19]     ;IFF2
        and al,4
        if nz mov al,0ff
        mov b[offset rfa+19],al
        mov b[offset rfa+27],al     ;IFF1
        mov ah,b[offset rfa+26]     ;border
        cmp ah,7
        if a mov ah,0
        mov al,b[offset rfa+20]     ;R
        shl ax,1
        mov b[offset rfa+26],ah
        mov bx,w[offset rfa+23]     ;SP
        cmp bx,16384
        ja sna_normal
        mov w[offset rfa+28],072    ;PC -> RETN
        jmp sna_continue
sna_normal:
        push ds
        mov ds,w[offset specseg]
        mov ax,w[bx]
        pop ds
        mov w[offset rfa+28],ax     ;PC
        inc bx
        inc bx
        mov w[offset rfa+23],bx
sna_continue:
        mov si,xtabsna
        mov cx,27
        xor bh,bh
        xor dh,dh
invxloop:
        lodsb
        mov bl,al
        lodsb
        mov dl,al
        mov al,[offset rfa+bx]
        xchg bx,dx
        xchg al,[offset rfa+bx]
        xchg bx,dx
        mov [offset rfa+bx],al
        loop invxloop
        call reset_headervars
        pop si
        pop es
        pop ds
        xor ax,ax               ;already done in reset_headervars, but ok
        call swap_mem
        xor ax,ax
        ret

xtabsna:
        db 0,22,1,21,2,13,3,14,4,9,5,10,6,28,7,29,8,23,9,24,10,22,11,20,12,26
        db 13,20,14,26,15,22,16,28,17,26,18,24,19,21,21,23,22,29,23,29,24,28
        db 25,26,26,28,28,29

reset_headervars:               ;used in loading old .z80 files and .sna files
        mov byte cs:if1flg,0    ;Not necessary; done in LOAD_ROMS
        mov byte cs:discflg,0   ;Disciple not paged. (done in LOAD_ROMS)
        mov byte cs:m128flg,0   ;Multiface rom not paged
        mov word cs:rompage1,-1 ;Lower 16k is all ROM
        mov ax,0
        call swap_mem           ;Make rom correspond to settings -
        push ds                 ; better be sure than sorry
        push es
        push cs
        pop es
        push cs
        pop ds
        mov si,offset _udef_joy
        mov di,offset joytable
        mov cx,5
        cld
        rep movsw
        mov si,offset _udef_keys
        mov cx,5
        rep movsw
        pop es
        pop ds
        ret

popandret:
        pop ds
        ret
load_version23_z80file:
        push dx                 ;save mode byte
        mov dx,offset length
        mov cx,2
        mov ah,03f
        int 021
        pop dx
        if c jmp lzf_error_close
        mov cx,headerlen-2
        xchg word cs:length,cx  ;reset variable, and get value loaded
        cmp ax,2
        if nz jmp lzf_error_close
        mov ax,cx
#if oldversionload
        cmp ax,21
        jz loadthistoo
#endif
        cmp ax,headerlen-2      ;Z80 V3
        je loadthistoo          ;jump if it is
        cmp ax,23               ;Z80 V2, V2.01
        mov ax,2
        jne popandret           ;unknown version
loadthistoo:
        mov al,cs:rommod
        xor ah,ah
        mov dh,cs:mflag
        push dx                 ;save mode byte and MFLAG
        push ax                 ;and rommod
        mov dx,offset rpc2
        mov ah,03f
        int 021
        pop si                  ;rommod to si
        pop dx
        if c jmp lzf_error_close
        cmp ax,cx
        if nz jmp lzf_error_close
        cmp ax,headerlen-2              ;V3
        je  loadthistoo1                ;jump if it is
        cmp byte ptr cs:rommod,3        ; old 128K mode? ***** HMc *****
        jb loadthistoo1                 ; jump if not ***** HMc *****
        add byte ptr cs:rommod,1        ; convert old 128K mode to new ***** HMc *****
loadthistoo1:
        mov ax,word cs:rpc2
        mov cs:word rpc,ax
        test dl,2
        je lzf_usenewsettings
        mov cs:mflag,dh                 ;reset MFLAG to old value
        cmp cs:rommod,2                 ;samram?
        je lzf_useoldsettings           ;never change samram mode
        cmp cs:rommod,3
        if e dec cs:rommod              ;temporarily use code '2' for 48k+mgt
        and cs:rommod,4                 ;only keep 128k/48k bit
        and si,3                        ;only keep none/if1/mgt bit
        or cs:rommod,si
        cmp cs:rommod,2
        if e inc cs:rommod              ;reset to code '3' again
        jmp lzf_useoldsettings
lzf_usenewsettings:
        push ds
        push es
        push cs
        pop es
        push cs
        pop ds
        mov di,offset _udef_joy
        mov si,offset joytable
        mov cx,5
        cld
        rep movsw
        mov di,offset _udef_keys
        mov cx,5
        rep movsw
        pop es
        pop ds
lzf_useoldsettings:
        push bx
        call load_romfile
        pop bx
        mov cs:b[offset ramstate+1],0   ;Pretend the rom is paged in all ram pages
        mov cs:b[offset ramstate+2],0   ;This will prevent SWAP_MEM from freshing
        mov cs:b[offset ramstate+3],0   ;up the internal buffers with old data
load_memblocks:
        push cs
        pop ds
        mov ah,03f
        mov cx,3
        mov dx,offset mlength
        int 021
        if c jmp lzf_error_close
        test ax,ax
        if z jmp blocks_loaded
        cmp ax,3
        if nz jmp lzf_error_close
        xor dx,dx
        mov cx,cs:mlength
        test cx,cx
        if z jmp blocks_loaded          ;v3.04: stop if .SLT extension encountered
        cmp cx,64
        if c jmp lzf_error_close
        cmp cx,16384
        if a jmp lzf_error_close
        push ds
        mov ax,cs:mdrvseg
        mov ds,ax
        mov ah,03f
        int 021
        pop ds
        if c jmp lzf_error_close
        cmp ax,cx
        if nz jmp lzf_error_close
        push bx
        call unpack_16k
        pop bx
        if c jmp lzf_error_close
        jmp load_memblocks
blocks_loaded:
        cmp byte cs:rommod,4            ; ***** HMc MOD *****
        if ae jmp init_mem_128
        mov ax,0305
        call swap_mem
        mov ax,0108                     ;standard page layout
        call swap_mem
        mov ax,0204
        call swap_mem
ims_pages_ok:
        mov bx,offset in31tab
        mov cx,8
ims1:   mov cs:b[bx],0
        inc bx
        loop ims1
        push cs
        pop es
        mov al,cs:hstate
        mov cx,31
        mov bh,0
        and al,255-4            ;Do not switch off the '259 yet
ims2:   shr al,1                ;This pages the 2nd 32K rambank if neccesary
        push bx
        rcl bh,1
        call far out_bc_far     ;without effect if samram not active
        pop bx
        inc bh
        cmp bh,8
        jne ims2
        mov bh,5
        test byte cs:hstate,4
        if nz call far out_bc_far
        pop ds
        xor ax,ax
        ret
init_mem_128:
        mov ax,0300             ;to prevent troubles when in non-ems mode
        call swap_mem
        mov ax,2                ;'128 rom; active at reset
        call swap_mem
        mov ax,0108             ;page 5
        call swap_mem
        mov ax,0205             ;page 2
        call swap_mem
        mov ax,0303             ;page 0
        call swap_mem
        mov bh,cs:hstate
        mov byte cs:hstate,0    ;in accordance with above
        push cs
        pop es
        mov cx,07ffd
        call out_bc_far         ;now switch the rom and rambanks
        pop ds
        xor ax,ax
        ret

lzf_error_close:
        pop ds
;        mov ah,03f
;        int 021
        mov ax,1
        ret

unpack_16k:
        push ds
        push es
        mov al,cs:mpage
        mov ah,3
        call swap_mem
        mov es,cs:specseg
        mov di,0c000
        mov ax,cs:mdrvseg
        sub ax,0c00
        mov ds,ax               ;Long Live Real Mode!
        mov si,0c000
        mov cx,04000
        cld
        call descr_loop         ;c=error
        cmc
        if c cmp di,1
        cmc
        pop es
        pop ds
        ret

pack_16k:
        push ds
        push es
        mov al,cs:mpage
        mov ah,3
        call swap_mem
        mov ds,cs:specseg
        mov si,0c000
        mov ax,cs:mdrvseg
        sub ax,0c00
        mov es,ax
        mov di,0c000
        mov cx,04000
        cld
        call noblock
        mov cx,di
        sub cx,0c000
        pop es
        pop ds
        ret

;
;The next subroutine saves a version 2 Z80 file to disk. On entry, BX
;holds the handle. AX<>0 on exit if a write error occurred.
;Imode must hold the correct bits on entry (see _maakinstelbits)
;
save_z80_file:
        push bx
        call mdrv_clearbuffer           ;i'm going to use the mdrv buffer
        cmp byte cs:rommod,2
        jnz szf_nosam
        mov bx,offset in31tab
        mov cx,8
szf_sam_bits:
        mov al,cs:b[bx]
        ror ax,1
        inc bx
        loop szf_sam_bits
        mov byte cs:hstate,ah           ;store the state of the 74ls259 chip
szf_nosam:
        pop bx
        mov word cs:length,headerlen-2  ; ***** HMc MOD *****
        mov ax,cs:rpc
        mov cs:rpc2,ax
        mov cs:rpc,0
        mov byte cs:zero,0
        push cs
        pop ds
        push es
        push cs
        pop es
        mov si,offset _udef_joy
        mov di,offset joytable
        cld
        mov cx,5
        rep movsw
        mov si,offset _udef_keys
        mov cx,5
        rep movsw
        pop es
        mov dx,offset rfa
        mov cx,headerlen+30             ;old + new header
        mov ah,040
        int 021
        if c jmp szf_error
        cmp ax,headerlen+30             ; ***** HMc MOD *****
        if nz jmp szf_error
        mov ax,cs:rpc2
        mov cs:rpc,ax
        mov al,cs:b[offset ramstate]    ;save ram pageing state
        push ax
        mov al,cs:b[offset ramstate+1]
        push ax
        mov al,cs:b[offset ramstate+2]
        push ax
        mov al,cs:b[offset ramstate+3]
        push ax
        mov ax,0100
        call swap_mem                   ;page the rom in all rambanks to store
        mov ax,0200                     ;the memory in internal rambanks
        call swap_mem                   ;(Or: waste of time in ems mode)
        mov ax,0300
        call swap_mem
        mov byte cs:mpage,3             ;normal: 4,5,8. Sam: 4-8. 128: 3-10
szf_saveloop:
        mov al,cs:mpage
        cmp al,3
        jnz szf_s_no3
        cmp byte cs:rommod,4            ; 48K? ***** HMc MOD *****
        jb szf_next                     ; jump if it is  ***** HMc *****
szf_s_no3:
        cmp al,9
        jb szf_s_less9
        cmp byte cs:rommod,4            ; 48K? ***** HMc MOD *****
        jb szf_next                     ; jump if it is ***** HMc *****
szf_s_less9:
        cmp al,6
        jb szf_do_save
        cmp al,7
        ja szf_do_save
        cmp byte cs:rommod,2
        jb szf_next
        cmp byte cs:rommod,3            ; ***** HMc *****
        je szf_next                     ; ***** HMc *****
szf_do_save:
        push bx
        call pack_16k           ;pack page MPAGE in mdrvseg:0000. CX=length
        pop bx
        mov cs:mlength,cx
        push cs
        pop ds
        mov dx,offset mlength
        mov cx,3
        mov ah,040
        int 021
        if c jmp szf_error1
        cmp ax,3
        if nz jmp szf_error1
        mov cx,cs:mlength
        mov ds,cs:mdrvseg
        xor dx,dx
        mov ah,040
        int 021
        if c jmp szf_error1
        cmp ax,cx
        if nz jmp szf_error1
szf_next:
        mov al,cs:mpage
        inc al
        mov cs:mpage,al
        cmp al,11
        if b jmp szf_saveloop
        mov ah,03f
        int 021
        mov ax,0
        adc ax,0
szf_error_restore:
        mov bx,ax                       ;save error flag
        pop ax
        mov ah,3
        call swap_mem                   ;repage previously active pages
        pop ax
        mov ah,2
        call swap_mem
        pop ax
        mov ah,1
        call swap_mem
        pop ax
        mov ah,0
        call swap_mem
        mov ax,bx
        ret
szf_error1:
        mov ah,03f
        int 021
        mov ax,1                ;signal error
        jmp szf_error_restore   ;restore ems pages
szf_error:
        mov ah,03f
        int 021
        mov ax,1
        ret


startup ends

