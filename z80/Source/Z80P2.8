;
; Memory structure: _first_func is first label in first segment of program
;                   It starts at PSP+0100h, or seg PSP+010h
;                   Then rest, including stack.
;                   Then emulator segment of 64K, packed on disk
;                   Then 01b00 of introscreen data (in seg 'codf', not 'code',
;                        to persuade the linker to put the data at the end)
; Free memory: disciple buffer (used during startup to load z80.ini file)
;              vga buffers and tables (overlay other screen tables completely)
; During startup the intro screen is moved up in memory into temporary
;   memory block (introscrseg) which is freed before other memory is allocated
;   After loading the .INI file the intro screen is moved into the Disciple
;   buffer.
;

xherc   equ 0
plant   equ 0

MAIN:   PUSH DS
        PUSH CS
        POP DS
        MOV DX,MES1
        MOV AH,9
        INT 021
        mov dx,shwmes
        mov ah,9
        int 021
        mov dx,hmes
        mov ah,9
        int 021
        POP DS
        PUSH ES
        PUSH DS
        MOV AX,SEG _FIRST_FUNC
        MOV BX,SEG emulate
        ADD BX,01000+0400+01b0+0100     ;64k + 16K + screen + bit extra
        SUB BX,AX
        PUSH DS
        POP ES
        MOV AH,04A
        INT 021                         ;SETBLOCK
        IF C JMP NOT_ENOUGH
        call calcchecksum
        CMP CS:ROMADR,0
        IF Z JMP SCRUNGEIT
        mov bx,01b0                     ;temporary storage for intro screen
        mov ah,048                      ;get memory
        int 021
        if c jmp not_enough
        mov cs:introscrseg,ax
        mov es,ax
        MOV AX,SEG OPC0
        MOV DS,AX
        MOV SI,CS:ROMADR
        cld
        xor di,di
        mov cx,01b00
        rep movsb
        mov si,cs:romadr
        mov es,ax
        std
        DEC SI
        MOV DI,0FFEE
        MOV CX,0FFEF
        lodsb
        xchg ah,al
        lodsb
        xchg ax,bp
MLODSB  MACRO
        DEC BP
        CMP BP,OFFSET INBUF
        IF B MOV BP,OFFSET INBUF+255
        LODSB
        xor al,cs:b[offset checksum+1]
        SUB AL,CS:B[BP]
        xor al,cs:b[offset checksum]
#EM
DESCRUNGE:
        MLODSB
DESCR_AGAIN:
        CMP AL,090
        JZ CHECK_BLOCK
        STOSB
        LOOP DESCRUNGE
        JMP DESCR_DONE
CHECK_BLOCK:
        MLODSB
        CMP AL,092
        JZ DO_BLOCK
        MOV ES:B[DI],090
        DEC DI
        DEC CX
        JMP DESCR_AGAIN
DO_BLOCK:
        MLODSB
        AND AL,AL
        JZ PUTBLOCK
        CMP AL,1
        JZ PUT9092
        MOV AH,AL
        mov al,0cc
PUTZERO:
        STOSB
        cmp ah,3
        if z mov al,00
        DEC CX
        DEC AH
        JNZ PUTZERO
        JCXZ DESCR_DONE
        JMP DESCRUNGE
PUT9092:
        MOV AL,090
        STOSB
        mov al,092
        STOSB
        DEC CX
        DEC CX
        JMP DESCRUNGE
PUTBLOCK:
        DEC DI
        MOV AX,09090
        STOSW
        STOSW
        MOV AL,0E3
        STOSW
        MOV AX,0FF3d
        STOSW
        MOV B[DI+1],08A
        SUB CX,9
        JMP DESCRUNGE
DESCR_DONE:
        PUSH CS
        POP DS
        MOV AX,SEG OPC0
        MOV ES,AX
        MOV SI,FIXUP_TABLE
        CLD
FIXUP2: LODSW
        AND AX,AX
        JZ FIXUP3
        MOV BX,AX
        MOV ES:[BX],CS
        JMP FIXUP2
FIXUP3: POP DS
        XOR AX,AX
        MOV ES,AX
        mov ax,es:w[0417]
        mov cs:kstate,ax
;        and ax,080
;        mov ES:W[0417],ax
;        call set_kbd_leds
        POP ES
        PUSH DS
        call get_cbaddrs
        PUSH CS
        POP DS
        MOV NUMLCK,0
        MOV TTYPE,0          ;GEEN PLANTRONICS TERM. TYPE GESCAND
        MOV DOUBLE,0         ;NORMALE IRUPT SNELHEID
        MOV mflag,0          ;fast r register emulation; fast ldir emulation
        mov coloremu,0       ;no hi color resolution emulation
        mov _usercoloremu,0
        mov linecounter,1
        mov viertel,2        ;to make sure hi res vars are inited 1st time
        MOV FLASH,0          ;GEEN FLASH EMULATIE
        MOV HERCFLG,0        ;GEEN HERCULES
#if xherc
        MOV XTDHERC,0        ;GEEN XTD HERCULES
#endif
        MOV CGA,0            ;GEEN CGA
        MOV EGA,0            ;GEEN EGA
        mov vga,0
        mov trivga,0
        mov greyvga,0
        MOV EGAPAL,0         ;NORMAAL PALET
        MOV SILENCE,0        ;GEEN STILLE SPECTRUM
        mov cmschips,0       ;Do not use CM/S chips on soundblaster
        mov intsnd,0ff       ;128 sound through internal speaker if no adlib
        MOV ISSUE2,0         ;GEEN ISSUE 2 GEEMULEERD
        MOV OUTMODE,0        ;RS232 <-> NIETS (VOOR DEF ZIE LOAD_ROMS)
        MOV OUTNUM,0         ;LPT1
        MOV INMODE,0         ;RS232 <-> NIETS
        MOV IF1SW,0          ;8K IF1 BANKSWITCH
        MOV ROMMOD,1         ;IF1
        MOV JOYMODE,0        ;CURSOR JOYSTICK
        MOV KEMPSTON_STATE,0 ;JOYSTICK IN MIDDENSTAND
        MOV ZANDJOY,0FF      ;AUTODETECTIE ZANDJOY & ANALOGE JOYSTICK
        mov msmouse,0
        mov _tapewindow,0ff
        mov curs128,0
        MOV TAPEIF,1
        MOV SYNCMOD,2        ;STANDAARD VIDEO SYNC.
        MOV KEYSCAN,0        ;NORMALE KEYBOARD SCANNING
        MOV SPCTEL,0         ;ZIE LOAD_BLOCK IN CIF.8
        mov _tstates,224     ;or 17472
        mov _tstatehi,0
        mov _lasttlo,224
        mov _lastthi,0
        mov expmem,0ff       ;try to use expanded memory
        mov ax,01600
        int 02f
        and al,07f           ;00 or 80: Windows not running
        mov winkey,al        ;Nonzero = Windows running (version number)
        mov comsdat,0
        mov comsclk,0
        mov readwrt,0
        mov erase,0
        mov motors,0         ;all mdrv motors off
        mov dataread,0
        mov datawritten,0
        mov cts,0
        mov cts128,0
        mov word cs:envaddlo,0
        mov word cs:envaddhi,0
        MOV C_ACTIVE,0
        MOV MODFLG,0
        MOV JOYXY,0
        MOV PUTOUT,OFFSET OUTBUF
        MOV GETOUT,OFFSET OUTBUF
        MOV PUTIN,OFFSET INBUF
        MOV GETIN,OFFSET INBUF
        MOV CS:_curspd,5000
        MOV CS:ATRADR,ATTRP1
        POP DS
;        MOV bX,01000+011+(stack_size)/8        ;64K for emulator, 0100 PSP
        mov bx,01000+011                    ;do not include screen!
        ADD bX,SEG emulate
        sub bx,SEG _FIRST_FUNC
        MOV CS:PROGSEG,DS
        push ds
        pop es
        MOV AH,04A
        INT 021                 ;Allocate as much memory as is needed for the
        xor ax,ax               ;program alone (no roms, etc.)
        mov es,ax
        mov ax,es:[0408]
        test ax,ax
        if z mov ax,03f8
        inc ax
        mov cs:tapeio,ax
        mov ah,048
        mov bx,01000            ;Allocate temporary 64K chunk to emulate in
        int 021
        if c jmp not_enough
        mov cs:specseg,ax
        CALL GET_SPD
        mov es,cs:specseg       ;Free 64K chunk
        mov ah,049
        int 021
        MOV AX,DX               ;'RONDE-TELLER' BC
        MOV DX,0BFF0            ;LENGTE VAN EEN 'RONDE'
        MUL DX
        ADD AX,DI               ;TEL PC HIER BIJ OP
        ADC DX,0
        SUB AX,SI               ;TREK BEGINPC HIERVAN AF
        SBB DX,0
        shl ax,1
        rcl dx,1
        cmp dx,87               ;max approx 6553.6 %
        if a jmp too_fast
        MOV CX,88
        DIV CX
        cmp cs:winkey,0
        je getspd_ok            ;Normal DOS environment
        cmp cs:winkey,4
        jae getspd_ok           ;Windows 95 DOS box: also OK
        shr ax,1                ;For unknown reason, measuring bxcst does not
        mov cs:bxcst,ax         ; work properly in Windows 3.1 DOS box
getspd_ok:
        MOV BX,CS
        MOV DS,BX
        PUSH AX
        MOV AH,9
        MOV DX,MES4
        INT 021
        POP AX
        PUSH AX
        MOV CH,0
        mov bx,10000
        call print_digit
        MOV BX,1000
        CALL PRINT_DIGIT
        MOV BX,100
        CALL PRINT_DIGIT
        MOV BX,10
        MOV CH,1
        CALL PRINT_DIGIT
        PUSH AX
        MOV AH,2
        MOV DL,'.'
        INT 021
        POP AX
        MOV BX,1
        CALL PRINT_DIGIT
        MOV AH,9
        MOV DX,MES5
        INT 021
        POP BX                  ;BX IS REL. SNELHEID IN PROMILLES
        MOV CS:RELSPD0,BX       ;SLA DEZE SNELHEID OP
        call get_progpath
        mov es:b[di],0
        push di
        push cs
        pop ds
        mov si,offset specchars
        mov di,offset _progpath
        mov ax,seg _progpath
        mov es,ax
        mov cx,128
        rep movsb
        push cs
        pop es
        pop di
        mov si,ini_filename
        mov cx,9
        rep movsb
        mov dx,offset specchars
        mov ax,03d00
        int 021
        jc ini_not_found
        mov dx,offset DISCiPLEBuffer
        mov bx,ax
        mov ax,seg DISCiPLEBuffer
        mov ds,ax
        mov cx,8000
        mov ah,03f
        int 021
        jc ini_not_found
        test ax
        jz ini_not_found
        cmp ax,8000
        jz ini_too_long
        mov si,offset DISCiPLEBuffer
        mov bx,ax
        mov b[si+bx],01a
        mov bx,1                ;line counter
        call param_iniloop
ini_not_found:
        MOV DS,CS:PROGSEG
        MOV SI,080              ;command line
        CMP BYTE [SI],0
        IF Z JMP LOAD_ROMS
        INC SI
        call param_loop
        jmp load_roms
        ret
ini_too_long:
        push cs
        pop ds
        mov dx,initoolong
        mov ah,9
        int 021
        jmp ini_not_found


param_iniloop:
        lodsb
        cmp al,9
        jz param_iniloop
        cmp al,020
        jz param_iniloop
        cmp al,0a
        jnz nonewline
        inc bx
        jmp param_iniloop
nonewline:
        cmp al,0d
        jz param_iniloop
        cmp al,'%'
        jz param_skip
        cmp al,01a
        jz ret
        cmp al,'-'
        jz param_i_par
        cmp al,'/'
        jz param_i_par
ini_err:
        push bx
        mov dx,inierr
        CALL PRINT
        pop ax
        MOV CH,0
        MOV BX,1000
        CALL PRINT_DIGIT
        MOV BX,100
        CALL PRINT_DIGIT
        MOV BX,10
        CALL PRINT_DIGIT
        MOV CH,1
        mov bx,1
        call print_digit
        MOV DX,L0D0A
        CALL PRINT
        MOV AX,04C01
        INT 021

param_skip:
        lodsb
        cmp al,01a
        jz ret
        cmp al,0a
        jnz param_skip
        inc bx
        jmp param_iniloop

param_i_par:
        push bx
        LODSB
        AND AL,0DF
        MOV BX,OFFSET OPLIST
OPLOOPini:
        CMP AL,CS:[BX]
        JZ CALLiniOPTION
        ADD BX,4
        CMP CS:W[BX],0
        JNZ OPLOOPini
        pop bx
        jmp ini_err

CALLiniOPTION:
        CALL CS:[BX+2]
        pop bx
        JMP PARAM_iniloop





PARAM_LOOP:
        LODSB
        CMP AL,9
        JZ PARAM_LOOP
        cmp al,020
        jz param_loop
        DEC SI
        CMP AL,0D
        jz ret
        cmp al,01a
        jz ret
        CMP AL,'/'
        IF Z JMP PARAMS
        CMP AL,'-'
        IF Z JMP PARAMS
        ret

PARAMS2:
        LODSB                   ;NIEUW KARAKTER
        DEC SI                  ;POINT WEER NAAR NIEUW KARAKTER
        CMP AL,32
        JZ PARAM_LOOP
        CMP AL,9                ;TAB
        JZ PARAM_LOOP
        TEST AL
        jz ret
        CMP AL,0D
        jz ret
        cmp al,01a
        jz ret
        CMP AL,'-'
        JZ PARAMS
        CMP AL,'/'
        JZ PARAMS
        DEC SI                  ;USE 'DUMMY SWITCHAR' (OUDE OPTIE)
PARAMS:
        LODSB                   ;switchchar
        LODSB                   ;NIEUWE OPTIE
        AND AL,0DF
        MOV BX,OFFSET OPLIST
        MOV DX,PERR
OPLOOP:
        CMP AL,CS:[BX]
        JZ CALLOPTION
        ADD BX,4
        CMP CS:W[BX],0
        JNZ OPLOOP
        JMP ENDERR

CALLOPTION:
        CALL CS:[BX+2]
        JMP PARAMS2

OPLIST: DW 'N',PNORM,'S',PSAMR,01F,PHELP,'D',PDOUBLE,'R',PRREG,'F',PFLSH
        DW 'L',PLDR,'H',PHERC,'X',PXXX,'C',PCGA,'G',PSILENCE,'O',PSERN
        DW 'I',PISERN,'A',PPARN,'W',PFILEOUT,'U',PFILEIN,'E',PEGA,'T',PTTAPE,
        DW 'V',PVGA
#if plant
        dw 'P',PPLANT,'Q',PQPLANT
#endif
        dw 'K',PJINPUT,'J',PJOYSTICK,'Z',PSPEED
        DW 012,PISSUE2,'Y',PSYNC,'B',PTAPE,'M',PMDRV,011,P128,010,DISCOPTS
        DW 019,PMGT,0

PHELP:  MOV DX,HELPMES
        push cs
        pop ds
        mov ah,9
        int 021
        mov ax,04400
        mov bx,1
        int 021
        and dl,082
        cmp dl,082
        pushf
        if z call helpkey
        mov dx,helpmes2
        mov ah,9
        int 021
        popf
        pushf
        if z call helpkey
        mov dx,helpmes3
        mov ah,9
        int 021
        popf
        pushf
        if z call helpkey
        mov dx,helpmes4
        mov ah,9
        int 021
        popf
        if z call helpkey
        mov dx,helpmes5
        mov ah,9
        int 021
        mov ax,04c00
        int 021
helpkey:
        mov dx,keymes1
        mov ah,9
        int 021
helpkey2:
        mov ah,0b
        int 021
        and al,al
        jz helpkey2
        mov ah,7
        int 021
        mov dx,keymes2
        mov ah,9
        int 021
        ret
PDOUBLE:xor CS:DOUBLE,0FF
        RET
PNORM:  cmp cs:rommod,3                 ; 48+DISCiPLE?   ***** HMc *****
        ja pnorm1                       ; jump if 128  ***** HMc *****
        mov cs:rommod,0                 ; make 48K only  ***** HMc *****
        ret                             ; return  ***** HMc *****
PMGT:
        mov dx,discerr
        jmp enderr
pnorm1: mov cs:rommod,4                 ; make 128K only  ***** HMc *****
        ret                             ; return  ***** HMc *****
PSAMR:  cmp cs:rommod,2
        MOV CS:ROMMOD,2
        if z mov cs:rommod,1
        RET
p128:   lodsw
        cmp ax,'82'
        if nz sub si,2
        cmp cs:rommod,2
        je p1280                        ; if 48K+If1+SAMRAM  ***** HMc *****
        jb p1282
        cmp cs:rommod,3                 ; if 128K  ***** HMc *****
        ja p1281                        ; then mode > 48  ***** HMc *****
        mov cs:rommod,6                 ; 48+DISC > 128+DISC  ***** HMc *****
        ret
p1280:  mov cs:rommod,5                 ; ***** HMc *****
        ret                             ; ***** HMc *****
p1281:  sub cs:rommod,4
        cmp cs:rommod,2                 ; if was 6, 128+DISC  ***** HMc *****
        if z mov cs:rommod,3            ; then 3, 48+DISC  ***** HMc *****
        ret
p1282:  add cs:rommod,4                 ; mode > 128  ***** HMc *****
        ret
PIF1BSW:xor CS:IF1SW,0FF
        RET
PRREG:  xor CS:mflag,1
        RET
PFLSH:  xor CS:FLASH,0FF
        RET
PLDR:   xor CS:mflag,2
        RET
PISSUE2:xor CS:ISSUE2,0FF
        RET
PXXX:   CALL GETCHR
        cmp al,'A'
        if z jmp padlib
        cmp al,'B'
        if z jmp pgreyvga
        cmp al,'C'
        if z jmp pcms
        cmp al,'D'
        if z jmp pdebug
        cmp al,'E'
        if z jmp pexpmem
        cmp al,'F'
        if z jmp pif1bsw
        cmp al,'G'
        if z jmp polall
#if xherc
        CMP AL,'H'
        if Z jmp PXTDHERC
#endif
        cmp al,'I'
        if z jmp pinternal
        cmp al,'J'
        if z jmp pzxprbusy
        cmp al,'K'
        if z jmp pm128
        cmp al,'L'
        if z jmp pzxprint           ;M,P in xswitch in xtra.c
        cmp al,'N'
        if z jmp pblasterrate
        cmp al,'O'
        if z jmp pblaster
        cmp al,'Q'
        if z jmp psetbase
        cmp al,'R'
        if z jmp pnewrom
        cmp al,'S'
        if z jmp pcurs128
        cmp al,'T'
        if z jmp ptiny
        cmp al,'U'
        if z jmp psupertiny
        cmp al,'V'
        if z jmp p400vga
        cmp al,'W'
        if z jmp pwinkey
        cmp al,'X'
        if z jmp phicolour
        cmp al,'Y'
        if z jmp ptrace
        cmp al,'Z'
        if z jmp pazerty
        dec si                  ;point to the option again
        push ds
        push si
        mov ds,seg _double
        mov ax,sp
        push ss
        push ax
        call far _xswitch
        pop bx
        pop bx
        pop si
        pop ds
        mov dx,xerr1
        cmp ax,1
        if z jmp enderr
        mov dx,terr6
        cmp ax,6
        if z jmp enderr
        ret
#if xherc
PXTDHERC:
        xor CS:XTDHERC,0FF
        xor cs:hercflg,0ff
        ret
PHERC:  xor CS:HERCFLG,0FF
        cmp cs:xtdherc,0ff
        jnz ret
        mov cs:xtdherc,0
        mov cs:hercflg,0ff
        RET
#else
pherc:  xor cs:hercflg,0ff
        ret
#endif
PCGA:   xor CS:CGA,0FF
        RET
p400vga:xor cs:trivga,0ff
PVGA:   xor CS:VGA,0FF
        RET
PEGA:   xor CS:EGA,0FF
        RET
#if plant
PPLANT: cmp cs:atradr,attrp1
        jnz notplant
        cmp cs:plantr,0ff
        jnz notplant
        mov cs:plantr,0
        ret
notplant:
        MOV CS:PLANTR,0FF
        mov cs:atradr,attrp1
        RET
PQPLANT:cmp cs:atradr,attrp1g
        MOV CS:PLANTR,0FF
        MOV CS:ATRADR,ATTRP1G
        jnz ret
        mov cs:atradr,attrp1
        mov cs:plantr,0
        RET
#endif        
pnewrom:
        mov dx,offset _progpath+1   ;dummy
        call transfer_open_name
        if c jmp pnr_err
        mov cs:xrhandle,ax
        ret
pazerty:
        mov bx,offset keybtab1
        mov al,cs:[bx+01e]
        xchg al,cs:[bx+010]
        mov cs:[bx+01e],al
        mov al,cs:[bx+02c]
        xchg al,cs:[bx+011]
        mov cs:[bx+02c],al
        xor cs:azerty,0ff
        jz qwerty
        mov al,cs:[bx+12]
        xchg al,cs:[bx+13]
        xchg al,cs:[bx+50]
        xchg al,cs:[bx+39]
        mov cs:[bx+12],al       ;to make it invertible
        ret
qwerty: mov al,cs:[bx+12]
        xchg al,cs:[bx+39]
        xchg al,cs:[bx+50]
        xchg al,cs:[bx+13]
        mov cs:[bx+12],al
        ret
pexpmem:
        xor cs:expmem,0ff
        ret
padlib:
        xor cs:adlib,0ff
        ret
pwinkey:
        cmp cs:winkey,0
        mov cs:winkey,0
        if z mov cs:winkey,0ff
        ret
pgreyvga:
        xor cs:greyvga,0ff
        ret
pm128:
        xor cs:_m128_on,0ff
        ret
pzxprint:
        call getn
        mov cs:zxprint,ax
        ret
pnr_err:
        mov dx,romfile_nf
        jmp enderr
pcms:
        xor cs:cmschips,0ff
        ret
polall:
        xor cs:outlogall,0ff
        ret
pblaster:
        mov dx,regerr
        jmp enderr
pblasterrate:
        mov dx,regerr
        jmp enderr
psetbase:
        lodsb
        cmp al,' '
        je psetbase
        cmp al,9
        je psetbase
        dec si
        xor bx,bx
pcms_2: call pdebug_chr
        jnc pcms_2
        dec si
        mov dx,baseerr
        cmp bx,0200
        if c jmp enderr
        cmp bx,0300
        if ae jmp enderr
        test bl,0f
        if ne jmp enderr
        mov cs:baseadr,bx
        ret
pinternal:
        xor cs:intsnd,0ff
        ret
pcurs128:
        xor cs:curs128,0ff
        ret
PSILENCE:
        xor CS:SILENCE,0FF
        RET
phicolour:
        xor cs:_usercoloremu,0ff
        ret
pzxprbusy:
        xor cs:zxprbusy,0ff
        ret
psupertiny:
        xor cs:_nohcrmem,-1
ptiny:
        mov cs:vocbuflen,8192
        mov cs:outlogbuflen,960         ;divisible by 80
        ret
ptrace:
        xor cs:tracing,0ff
        ret
PJOYSTICK:
        CALL GETCHR
        CMP AL,'2'
        JE PJOY_SINCLAIR
        cmp al,'U'
        je pjoy_userdef
        cmp al,'C'
        je pjoy_cursor
        CMP AL,'K'
        IF NE JMP ERR
        MOV CS:JOYMODE,1
        RET
PJOY_SINCLAIR:
        mov cs:joymode,3
        ret
pjoy_cursor:
        mov cs:joymode,0
        ret
pjoy_userdef:
        mov cs:joymode,2
        mov bx,offset _udef_joy         ;left
        call getudefjoykey
        mov bx,offset _udef_joy+2       ;right
        call getudefjoykey
        mov bx,offset _udef_joy+6       ;up
        call getudefjoykey
        mov bx,offset _udef_joy+4       ;down
        call getudefjoykey
        mov bx,offset _udef_joy+8       ;fire
getudefjoykey:
        lodsb
        cmp al,' '
        je getudefjoykey
        cmp al,9
        je getudefjoykey
        cmp al,'A'
        jb guj_1
        cmp al,'Z'
        ja guj_1
        or al,32                        ;make lowercase if necessary
guj_1:  push bx
        mov bx,offset _udef_joy_table
        mov cx,40
guj_2:  cmp al,cs:[bx+2]
        je guj_3
        add bx,4
        loop guj_2
        mov dx,joyerr
        jmp enderr
guj_3:  mov cx,cs:[bx]
        pop bx
        mov cs:[bx],cx
        mov cs:[bx+20],al
        ret

pkeybscan:
        call gethexword
        mov dx,pkbscanerr
        cmp bh,058
        if a jmp enderr
        cmp bl,0c0+29
        if a jmp enderr
        mov al,bl
        mov bl,bh
        xor bh,bh
        mov cs:[bx+keybtab1],al
        ret
pdebug:
        call gethexword
        mov cs:debugadr,bx
        mov cs:debugflg,0ff
        ret
gethexword:
        xor bx,bx
        call pdebug_chr
        jb pdbg_err
        call pdebug_chr
        jb pdbg_err
        call pdebug_chr
        jb pdbg_err
        call pdebug_chr
        jb pdbg_err
        ret
pdebug_chr:
        lodsb
        cmp al,'a'
        if ae and al,0df
        cmp al,'0'
        jb ret
        cmp al,'F'+1
        cmc
        jb ret
        cmp al,'9'
        jbe pdbg_ok
        cmp al,'A'
        jb ret
        add al,'0'-'A'+10
pdbg_ok:
        sub al,'0'
        mov cl,4
        shl bx,cl
        or bl,al
        ret
pdbg_err:
        mov dx,dbgerr
        jmp enderr
pttape:
        push ds
        push si
        mov ds,seg _double
        mov ax,sp
        push ss
        push ax
        call far _tswitch
        pop bx
        pop bx
        pop si
        pop ds
        mov dx,terr1
        cmp ax,1
        if z jmp enderr
        mov dx,terr2
        cmp ax,2
        if z jmp enderr
        mov dx,terr3
        cmp ax,3
        if z jmp enderr
        mov dx,terr4
        cmp ax,4
        if z jmp enderr
        mov dx,terr5
        cmp ax,5
        if z jmp enderr
        mov dx,terr6
        cmp ax,6
        if z jmp enderr
        ret
PJINPUT:
        CALL GETCHR
        cmp al,'A'
        jz pamsmouse
        cmp al,'M'
        jz pjmouse
        CMP AL,'K'
        JE PJKEYBOARD
        cmp al,'1'
        je pj1joystick
        cmp al,'2'
        je pj2joysticks
        cmp al,'X'
        if e jmp pkeybscan
        CMP AL,'Z'
        IF NE JMP ERR
        mov al,1
        jmp pjinputput
PJKEYBOARD:
        xor al,al
pjinputput:
        cmp cs:zandjoy,al
        MOV CS:ZANDJOY,al
        jnz ret
        mov cs:zandjoy,0ff
        RET
pj1joystick:
        mov cs:secondjoy,0
        ret
pj2joysticks:
        mov cs:secondjoy,0ff
        ret
pjmouse:
        xor cs:msmouse,0ff
        jmp short pmouse
pamsmouse:
        xor cs:amsmouse,0ff
pmouse: xor ax,ax
        int 033
        inc ax
        jne pnomsmouse
        mov ax,2                ;hide mouse
        if e dec ax             ;show mouse
        int 033
        mov cx,0
        mov dx,0200
        mov ax,7
        int 033                 ;set column range
        mov cx,0
        mov dx,0200
        mov ax,8
        int 033                 ;row range
        mov cx,0100
        mov dx,0100
        mov ax,4                ;set pos
        int 033
        ret
pnomsmouse:
        mov cs:msmouse,0
        mov cs:amsmouse,0
        mov dx,mouseerr
        call print
        ret
pmdrv:  lodsb
        cmp al,' '
        jz pmdrv
        dec si
        mov dx,mdrverr
        call getchr
        sub al,'1'
        jb pmdrverr
        cmp al,8
        jae pmdrverr
        xor ah,ah
        mov bx,ax
pmdrv_1:
        lodsb
        cmp al,' '
        jz pmdrv_1
        dec si
        push si
pmdrv_search:
        lodsb
        cmp al,' '
        jz pmdrv_end
        cmp al,0d
        jz pmdrv_end
        cmp al,01a
        jz pmdrv_end
        cmp al,9
        jnz pmdrv_search
pmdrv_end:
        dec si
        pop cx
        push w[si]
        mov b[si],0
        push si
        push cs
        mov ax,offset mhandles
        push ax
        push ds
        push cx
        push bx
        mov ax,seg _double
        mov ds,ax
        call far _mswitch
        pop bx
        pop bx
        pop ds
        pop bx
        pop bx
        pop si
        pop w[si]
        test ax,ax
        jnz ret
pmdrverr:
        mov dx,mdrverr
        jmp enderr
PSYNC:  LODSB
        CMP AL,020
        JZ PSYNC
        CMP AL,9
        JZ PSYNC
        CMP AL,0D
        IF Z JMP ERR
        cmp al,01a
        if z jmp err
        AND AL,0DF
        CMP AL,'L'
        JZ PSYNCLO
        CMP AL,'H'
        IF NZ JMP ERR
        mov al,1
        jmp psyncput
PSYNCLO:mov al,3
psyncput:
        cmp cs:syncmod,al
        mov cs:syncmod,al
        jnz ret
        mov cs:syncmod,2
        RET
PSPEED:
        MOV DX,REGERR
        JMP ENDERR
PFILEIN:
        MOV DX,OFFSET _INPUTFILE
        CALL TRANSFER_OPEN_NAME
        MOV DX,INFILE_NF
        IF C JMP ERR2
        MOV CS:INNUM,AX
        MOV CS:INMODE,3
        MOV CS:RSCOUNT,0
        RET
PFILEOUT:
        CALL CHK_DUPOUT
        MOV DX,OFFSET _OUTPUTFILE
        CALL TRANSFER_OPEN_NAME
        MOV DX,OUTFILE_NF
        IF C JMP ERR2
        MOV CS:OUTNUM,AX
        MOV CS:OUTMODE,3
        RET
PSERN:  CALL CHK_DUPOUT
        CALL GETN
        CMP AL,4
        IF AE JMP ERR
        MOV CS:OUTMODE,2
        MOV CS:OUTNUM,AX
        MOV CS:RSOUTCOUNT,0
        ret
PTAPE:
        mov dx,regerr
        jmp enderr
CHECKCOM:
        ADD AX,AX
        PUSH ES
        PUSH AX
        MOV AX,040
        MOV ES,AX
        POP BX
        CMP ES:W[BX],0
        POP ES
        IF Z JMP NOCOMPORT
        RET
PPARN:  CALL CHK_DUPOUT
        CALL GETN
        MOV CS:OUTMODE,1
        MOV CS:OUTNUM,AX
        ADD AX,AX
        PUSH ES
        XOR BX,BX
        MOV ES,BX
        MOV BX,AX
        CMP ES:W[BX+0408],0
        POP ES
        if Z jmp NOLPTPORT
        RET
PISERN: CALL GETN
        CMP AL,4
        IF AE JMP ERR
        MOV CS:INMODE,2
        MOV CS:INNUM,AX
        JMP SHORT CHECKCOM
GETN:   LODSB
        cmp al,020
        je getn
        cmp al,9
        je getn
        CMP AL,'1'
        JB GETNERROR
        CMP AL,'4'
        JA GETNERROR
        SUB AL,'1'
        XOR AH,AH
        RET
getnn:  lodsb
        cmp al,020
        je getnn
        cmp al,9
        je getnn
        xor bx,bx
        dec si
getnn1: lodsb
        dec si
        sub al,'0'
        jc ret
        cmp al,9
        ja ret
        xor ah,ah
        xchg ax,bx
        mov dx,10
        mul dx
        add bx,ax
        inc si
        jmp getnn1
GETCHR: LODSB
        CMP AL,'a'
        JB GTCH_NOLOWER
        CMP AL,'z'
        JA GTCH_NOLOWER
        AND AL,0DF
GTCH_NOLOWER:
        CMP AL,'0'
        JB GETNERROR
        CMP AL,'9'
        JBE RET
        CMP AL,'A'
        JB GETNERROR
        CMP AL,'Z'
        JBE RET
GETNERROR:
        POP DX
ERR:
        MOV DX,PERR
ERR2:
        JMP ENDERR
CHK_DUPOUT:
        CMP CS:OUTMODE,0
        JZ RET
        MOV DX,DUPOUT
        JMP ERR2
NOCOMPORT:
        MOV DX,NCPERR
        JMP ENDERR
NOLPTPORT:
        MOV DX,NLPERR
        JMP ENDERR
TRANSFER_OPEN_NAME:
        PUSH ES
        MOV AX,SEG _INPUTFILE
        MOV ES,AX
        PUSH DX
        PUSH DX
        POP BX
TN1:    LODSB
        CMP AL,' '
        JZ TN1
        DEC SI
TRANSFER_NAME:
        LODSB
        CMP AL,' '
        JZ EOFN
        CMP AL,9
        JZ EOFN
        CMP AL,'-'
        JZ EOFN
        CMP AL,'/'
        JZ EOFN
        CMP AL,0
        JZ EOFN
        CMP AL,0D
        JZ EOFN
        cmp al,01a
        jz eofn
        MOV ES:[BX],AL
        INC BX
        JMP TRANSFER_NAME
EOFN:   MOV ES:B[BX],0
        DEC SI
        POP DX
        cmp dx,offset _progpath     ;dummy output filename holder
        je open_create              ;(I know, VERY bad programming)
        CMP DX,OFFSET _outputfile
        JNZ OPEN_F
open_create:
        MOV AH,03C
        MOV CX,020
        PUSH DS
        PUSH ES
        POP DS
        INT 021
        JMP SHORT OPENED
OPEN_F: MOV AX,03D00
        PUSH DS
        PUSH ES
        POP DS
        INT 021
OPENED: POP DS
        POP ES
        JNC RET
        MOV AX,0
        RET

;********************* HMc BLOCK ******************************************
DISCOPTS:
           CALL GETCHR                  ; get next character
           and al,0df                   ; make capital
           cmp al,'E'                   ; EPSON printer?
           if e jmp DISCEpson                 ; jump if it is
           cmp al,'H'                   ; HP PCL printer?
           if e jmp DISCHPPCL                 ; jump if it is
           cmp al,'F'
           je discff
           cmp al,'M'
           je discmap
           cmp al,010
           je discnoierr
           mov dx,discerr
           jmp enderr

DISCDisc:
           mov al,0                     ; DISCiPLE (EPSON)
           jmp DISCCont1

DISCUni:
           mov al,9                     ; UNIDOS
           jmp DISCCont1

DISCPlus:
           mov al,16                    ; PLUS D (EPSON)

DISCCont1:
           mov byte ptr cs:[_DISCType],al
           ret

discinter:
           mov word cs:disccnt0,-1      ;effectively disable disciple interrupts
           ret

discff:
           call haalpromille            ;# lines before FF
           mov cx,10
           xor dx,dx
           div cx                       ;Undo final multiplication in haalprom.
           mov cx,8
           mul cx                       ;# graphic lines = 8 times # char lines
           mov word cs:zxprinterlines,ax
           mov word cs:zxprinterlinescount,ax
           ret

discmap:
        MOV DX,OFFSET _progpath     ;dummy, and signalling 'create'
        CALL TRANSFER_OPEN_NAME     ;(do NOT take over this style of programming)
        MOV DX,mapfile_nf
        IF C JMP ERR2
        mov cs:mapfilehandle,ax
        mov cs:mapflg,0ff
        RET

discnoierr:
            mov dx,offset regerr
            jmp enderr


DISCEpson:
           mov al,byte ptr cs:_disctype ; get disc type
           cmp al,9                     ; UNIDOS?
           je DISCEpson1                ; jump if it is
           and al,0fe
           mov byte ptr cs:_disctype,al

DISCEpson1:
           mov al,0ff
           jmp DISCCont2

DISCHPPCL:
           mov al,byte ptr cs:_disctype ; get disc type
           cmp al,9                     ; UNIDOS?
           je DISCHPPCL1                ; jump if it is
           and al,0fe
           inc al                       ; change to HP PCL
           mov byte ptr cs:_disctype,al

DISCHPPCL1:
           mov al,0

DISCCont2:
           mov byte ptr cs:[_zxptype],al
           ret


;********************** END OF HMc BLOCK **********************************



LOAD_ROMS:                              ;...but first do some initialising
        PUSH DS
        PUSH SI
        mov ah,0de                      ;get/set Novell broadcast mode
        mov dl,4                        ;get mode in al
        int 021
        mov cs:novellbroadcastmode,al
        mov ah,0de
        mov dl,1                        ;discard user messages
        int 021
        call get_cputype
        call adlib_init
        call install_blaster            ;Exits emulator when no sb found
        CALL INITJOYSTICK               ;initialiseer joystick uitlezing
        mov dx,cs:tapeio
        push dx
        call far _getissue2default
        pop dx
        CMP CS:OUTMODE,0
        IF Z MOV CS:OUTMODE,1           ;DEFAULT LPT1 (OUTNUM=0)
        mov ax,cs:introscrseg
        mov ds,ax
        xor si,si
        mov di,offset disciplebuffer
        mov ax,seg disciplebuffer
        mov es,ax
        mov cx,01b00
        cld
        rep movsb                       ;move intro screen into disciple buffer
        push ds
        pop es
        mov ah,049
        int 021                         ;free temporary chunk
        call allocate_memory
        call init_memory
        call load_romfile
        MOV ax,CS:VIDBUFSEG     ;VIDEO BUFFER SEGMENT ADRES
        MOV ES,AX
        MOV CX,4096
        MOV DI,16384
        XOR AX,AX
        REP STOSW               ;8192 BYTES 0 IN BUFFER
        push es
        mov ax,03523
        int 021
        push es
        push bx
        mov ax,seg breakhandler
        mov ds,ax
        mov dx,offset breakhandler
        mov ax,02523
        int 021
        call init_video
        cmp byte cs:gmod,5      ;vga
        if ne mov cs:_usercoloremu,0
        call intro
        CALL INIT_EMULATOR      ;Must be before load_z80_file but after
        pop dx                  ; init_video (otherwise get_tt fails)
        pop ds
        mov ax,02523
        int 021
        pop es
        CALL RESET              ;ZET Z80 PARAMS BIJ RESET
        POP SI
        POP DS
        mov cs:c_action_code,0f9        ;Load snapshot, startup code
        mov di,offset _prognaam
        mov ax,seg _prognaam
        push es
        push ax
        pop es
        mov cx,129
        cld
        rep movsb
        pop es
install_etc:
        mov ax,cs:specseg
        MOV DS,AX
        CALL SAVE_VECTORS
        MOV BYTE CS:INTTEL,0
        CLI
        cmp byte cs:winkey,0
        jnz dont_install
        MOV WORD ES:[32],TIMER
        MOV ES:[34],CS
;        MOV WORD ES:[36],KEYBOARD      ;Keyboard does work under win 3.1 (v3.04)
;        MOV ES:[38],CS
        mov word es:[76],newint13       ; new int 13 routine  ***** HMc *****
        mov word es:[78],seg newint13   ; new int 13 routine  ***** HMc *****
dont_install:
        MOV WORD ES:[36],KEYBOARD       ;Also under Windows (v3.04)
        MOV ES:[38],CS
        MOV WORD ES:[08C],CTRLC         ;IRET
        MOV ES:[08E],CS
        MOV WORD ES:[090],CRIT_ERR
        MOV ES:[092],CS
        MOV WORD ES:[108],CTRLC         ;IRET
        MOV ES:[110],CS
        MOV WORD ES:[52],SEGVIOLATION
        MOV ES:[54],CS
        mov word cs:trapadr,offset emulate_0
        mov word cs:trapseg,seg emulate_0
        CALL INSTALL_COM
        STI
        call adlib_turnon
        CALL INIT_EMULATOR
        call install_all
        cmp byte cs:winkey,0    ;But it should be done when playing VOC files,
        jne no_tim_inst         ; even though the timer isn't used at all.
        MOV AX,CS:ADDNUM
        OUT 040,AL
        MOV AL,AH
        OUT 040,AL
no_tim_inst:
        PUSH CS
        POP ES
        MOV CS:SP2,SP           ;ZET STACK POINTER VOOR TIMER
        CALL GET_REGS           ;HAAL REGISTERS
        jmp enter_c             ;Load snapshot if specified, and run emulator



too_fast:
        mov dx,toofasterr
ENDERR: CALL PRINT
        MOV DX,L0D0A
        CALL PRINT
        MOV AX,04C01
        INT 021
PRINT:  PUSH DS
        MOV DS,CS
        CALL PRINT_DS
        POP DS
        RET
PRINT_DS:
        PUSH AX
        MOV AH,09
        INT 021
        POP AX
        RET
NOT_ENOUGH:
        MOV DX,NEM
        JMP ENDERR


breakhandler:
        call text_mode
        mov dx,cs:emshandle
        mov ah,045
        test dx,dx
        if nz int 067
        xor ax,ax
        mov es,ax
;        mov ax,cs:kstate
;        and ax,0f0
;        mov es:[0417],ax
        stc
        retf





;The following routine loads in the necessary roms from ROMS.BIN according
;to the mode setting ('128 or sam). The if1 rom is always loaded, whether or
;not it is used. Also, there is always enough memory available for the largest
;mode (128 mode+multiface 128).
;If reset_romarea != 0, the Multiface 128 ram is wiped clean
;
load_romfile:
        cmp rommod,3
        if z mov rommod,1       ;48k+mgt -> 48k+if1
        cmp rommod,6
        if z mov rommod,5       ;128k+mgt -> 128k+if1
        mov ax,cs:romhandle
        test ax,ax
        jnz roms_found
        push cs                 ;First look for file 'plusdrom.bin'
        pop ds
        mov dx,pd_filename
        mov ax,03d00
        int 021
        jnc pd_found
        call get_progpath
        push cs
        pop ds
        mov si,pd_filename
        mov cx,15               ;enough
        cld
        rep movsb
        push es
        pop ds
        mov dx,offset specchars
        mov ax,03d00
        int 021
        jnc pd_found
        xor ax,ax               ;signal 'file not found'
        cmp cs:_disctype,16
        if e mov cs:_disctype,0
        cmp cs:_disctype,17
        if e mov cs:_disctype,1 ;if plus d selected in switches, reset to disciple
pd_found:
        mov cs:_pdhandle,ax
        push cs
        pop ds
        MOV DX,ROMS_FILENAME
        MOV AX,03D00
        INT 021
        JnC ROMS_FOUND
        call get_progpath
        push cs
        pop ds
        mov si,roms_filename
        mov cx,15
        rep movsb
        push es
        pop ds
        mov dx,offset specchars
        mov ax,03d00
        int 021
        push cs
        pop ds
        if c jmp roms_not_found
roms_found:
        mov cs:romhandle,ax
        push ax
        mov dx,cs:emshandle
        test dx,dx
        jz lr_noems
        mov ax,04400            ;page logical 0-3 to physical 0-3
        xor bx,bx
        int 067
        mov ax,04401
        inc bx
        int 067
        mov ax,04402
        inc bx
        int 067
        mov ax,04403
        inc bx
        int 067
lr_noems:
        pop bx
        mov ax,04200
        xor cx,cx
        xor dx,dx
        int 021
        mov ds,cs:romseg                ;=specseg if ems used
        xor dx,dx                       ;space for normal rom
        mov cx,04000
        call load_romblock
        push cs
        pop es
        mov si,03c00
        mov di,offset specchars
        mov cx,1024
        cld
        rep movsb
        push bx
        mov bx,cs:xrhandle      ;Get possible handle of external romfile
        test bx
        jz no_ext_rom
        xor dx,dx
        mov cx,04001
        mov ah,03f
        int 021
        mov dx,romfile_nf
        if c jmp enderr
        cmp ax,04000
        if ne jmp enderr
        mov ax,04200
        xor cx,cx
        xor dx,dx
        int 021                 ;Move to start of file again.
no_ext_rom:                     ; checks for M.G.T.  ***** HMc *****
        pop bx
        cmp cs:rommod,3         ; 48K + M.G.T.?  ***** HMc *****
        je load_discip          ; jump if it is  ***** HMc *****
        cmp cs:rommod,6         ; 128K + M.G.T.?  ***** HMc *****
        if ne jmp check4if1     ; jump if it is not

load_discip:                    ; ***** HMc *****

pdfileerror:
        call text_mode
        mov dx,pdmsg
        jmp enderr


load_discipcont:                ; move to it and load it ***** HMc *****
        cmp cs:curifrom,ax      ;Is this interface's rom already in place?
        mov cs:curifrom,ax      ;Signal: this interface's rom loaded (GL, v3.04)
        je reset_filepos        ;If so, don't reload so as not to disturb
                                ; disk image in 'rom' area (GL v3.04)
        mov ax,04200            ; move file point. from start ***** HMc *****
        int 021                 ; DOS CALL  ***** HMc *****
        mov dx,04000            ; IF1 ROM area  ***** HMc *****
        mov cx,04000            ; 16K of ROM to load  ***** HMc *****
        call load_romblock      ; load ROM  ***** HMc *****
reset_filepos:
        mov ax,04200            ; move file point. from start ***** HMc *****
        mov cx,0                ; of file to postion  ***** HMc *****
        mov dx,06000            ; 06000H (first SAMRAM ROM) ***** HMc *****
        int 021                 ; DOS CALL  ***** HMc *****
        jmp skippedif1          ; jump to check for SAMRAM  ***** HMc *****

check4if1:                      ; check for IF1  ***** HMc *****
        mov cs:curifrom,5       ;Code for: IF1 rom loaded (always reload; no probs)
        mov dx,04000            ;Space for if1 rom (2 x same 8K)
        mov cx,02000
        call load_romblock
        mov ax,04201
        mov cx,0ffff
        mov dx,-02000
        int 021                 ;Load the 8K rom once again
        mov dx,06000
        mov cx,02000
        call load_romblock

skippedif1:                     ; ***** HMc *****
        cmp cs:rommod,2
        jnz roms_nosam
        mov dx,08000            ;First and second samram rom
        mov cx,08000
        call load_romblock
        jmp short roms_init
roms_nosam:
        cmp cs:rommod,4         ; is it just a 48K?  ***** HMc MOD*****
        jb roms_init            ; jump if it is  ***** HMc ADDED NOTE*****
        mov ax,04201
        xor cx,cx
        mov dx,08000
        int 021                 ;Skip the two samram roms
        xor dx,dx               ;First '128 rom
        mov cx,04000
        call load_romblock
        mov dx,08000            ;Second '128 rom
        mov cx,04000
        call load_romblock
roms_init:                      ;romfile handle is not closed.
        mov dx,cs:emshandle
        test dx,dx
        jz lr_noems2
        xor bh,bh
        mov ax,04401
        mov bl,cs:b[offset ramstate+1]
        int 067
        mov ax,04402
        mov bl,cs:b[offset ramstate+2]
        int 067
        mov ax,04403
        mov bl,cs:b[offset ramstate+3]
        int 067
        mov ax,04400            ;bank 0
        mov bl,0b               ;page 11 (multiface)
        int 067
        jmp short lr_loadmultiface
lr_noems2:
        mov ax,cs:romseg
        add ax,11*0400
        mov ds,ax               ;ds:0 points to multiface rom
lr_loadmultiface:
        mov ax,04200
        mov cx,1
        mov dx,0e000            ;Multiface ROM at 01e000 (version 3.00 roms.bin)
        mov bx,cs:romhandle
        int 021                 ;Move
        mov dx,0
        mov cx,02000
        call load_romblock      ;load 8k multiface rom
        cmp byte cs:reset_romarea,0
        je lr_mf_noreset
        mov bx,8192
lr_mf_reset:
        mov w[bx],0
        add bx,2
        cmp bx,16384
        jb lr_mf_reset
lr_mf_noreset:
        mov byte cs:reset_romarea,0
        mov cs:word rompage1,-1 ;default state (all rom)
        mov cs:b[offset ramstate],0ff
        mov byte cs:actrom2,0ff
        mov ax,0                ;Normal rom at 0-3fff
        cmp byte cs:rommod,2
        jc ld_noems2c           ; ***** HMc *****
        cmp byte cs:rommod,3
        je ld_noems2c           ; ***** HMc *****
;        if ae mov al,2          ;e: Samram rom 1; a: '128 rom 2  ***** HMc REM *****
        mov al,2

ld_noems2c:
        call swap_mem
        cmp byte cs:m128flg,0ff
        if e call switchon_m128
        mov al,0ff              ;see also: load_z80_file
        mov ah,0ff              ; disciple on flag  ***** HMc *****
        cmp byte cs:rommod,0    ;mode: norm (no if1)
        if z xor ax,ax          ; no interfaces  ***** HMc MOD *****
        cmp byte cs:rommod,4    ;mode: 128 (no if1)  ***** HMc MOD *****
        if z xor ax,ax          ; no interfaces  ***** HMc MOD *****
        cmp byte cs:rommod,3    ; DISCiPLE?  ***** HMc *****
        if z xor al,al          ; no if1 + DISCiPLE  ***** HMc *****
        cmp byte cs:rommod,6    ; DISCiPLE?  ***** HMc *****
        if z xor al,al          ; no if1 + DISCiPLE  ***** HMc *****
        cmp byte cs:rommod,1    ; IF1?  ***** HMc *****
        if z xor ah,ah          ; no if1 + DISCiPLE  ***** HMc *****
        cmp byte cs:rommod,2    ; IF1?  ***** HMc *****
        if z xor ah,ah          ; no if1 + DISCiPLE  ***** HMc *****
        cmp byte cs:rommod,5    ; IF1?  ***** HMc *****
        if z xor ah,ah          ; no if1 + DISCiPLE  ***** HMc *****
        mov byte cs:if1_on,al
        mov byte cs:disc_on,ah  ; DISCiPLE connected  ***** HMc *****
        or al,ah                ; interfaces connected?  ***** HMc *****
        test al,al
        if z ret                ; return if not  ***** HMc *****
        cmp byte cs:if1flg,0
        jz Chkdiscac            ; check active DISCiPLE  ***** HMc MOD *****

Chkpageif1d:
        mov ax,1                ;Page if1 rom
        call swap_mem
        xor ax,ax
        ret

Chkdiscac:
        cmp byte cs:discflg,0ff ; disciple active?  ***** HMc *****
        if nz ret               ; return if not  ***** HMc *****
        mov ax,0ff00                    ;Low 8k=ram (0), Hi 8k=rom (0ff)
        cmp byte cs:_disctype,8         ;0=disc,8=unidos,16=plus d
        if nc xchg al,ah                ;Not so with unidos (?) or plus d
        mov es:rompage1,ax
        jmp chkpageif1d         ; page DISCiPLE  ***** HMc *****

load_romblock:
        mov ah,03f
        int 021
        jc roms_not_found
        cmp ax,cx
        je ret
ROMS_NOT_FOUND:
        mov dx,rommes
        jmp enderr



;Puts the path to the .EXE file in a buffer (specchars). The DI register
;points to just after the path (ready to receive a filename).
;
get_progpath:
        mov ds,cs:progseg
        mov ax,[02c]
        mov es,ax
        xor bx,bx
find_progpath:
        cmp es:w[bx],0
        jz found_progpath
        inc bx
        jmp find_progpath
found_progpath:
        add bx,3
        mov si,bx
find_endpath:
        inc bx
        cmp es:b[bx],0
        jnz find_endpath
find_backslash:
        dec bx
        cmp bx,si
        jz no_backslash
        cmp es:b[bx],'\'
        jnz find_backslash
no_backslash:
        sub bx,si
        inc si
        mov cx,bx
        push es
        pop ds
        push cs
        pop es
        mov di,offset specchars
        cld
        rep movsb
        ret





startup ends

