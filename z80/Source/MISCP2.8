startup segment para public

emulate_kbd_interrupt:
        pushf
        push cs
        mov bx,offset eki_ret
        push bx
        push ax
        push bx
        push cx
        push dx
        jmp short keyb_normal_entry
eki_ret:
        ret

KEYBOARD:
        PUSH AX
        test cs:byte keyscan,1
        je keyb_nokeyscan
        mov al,020
        out 020,al
        in al,060
        cmp al,0e0
        jz return_keyscan
        cmp al,0e1
        jz return_keyscan
        or al,cs:break
        cmp al,0f0
        mov byte cs:break,0
        if z mov byte cs:break,080
        test al,080
        if z or cs:byte keyscan,2
        cmp al,040
        if z or cs:byte keyscan,4       ;F6
return_keyscan:
        in al,061
        push ax
        or al,080
        out 061,al
        pop ax
        out 061,al
        pop ax
        sti
        iret
keyb_nokeyscan:
        cmp cs:byte modflg,0
        je keyb_normal
        pushf
        call cs:d[offset kbdadr]
        mov ah,1
        int 016
        jz keyb_nokey
        mov cs:modflg,2                 ;Signaleer 'Toets ingedrukt in real mode'
        in al,021
        and al,0fe                      ;Zet timer aan (als ie uitstaat)
        out 021,al
keyb_nokey:
        pop ax
        sti
        iret
keyb_normal:
        MOV AL,020
        OUT 020,AL
        PUSH BX
        PUSH CX
        PUSH DX
        IN AL,060
keyb_normal_entry:
        CMP AL,0E0
        JZ e0GET_OUT
        CMP AL,0E1
        JZ GET_OUT
        test byte cs:e0flag,0ff
        mov byte cs:e0flag,0
        jz e0flag_inaktief
        mov ah,al
        and ah,07f
        cmp ah,02a
        jz get_out
        cmp ah,036
        jz get_out
e0flag_inaktief:
        CMP AL,0F0
        JNZ NO_BRK
        MOV BYTE CS:BREAK,080
        JMP GET_OUT
NO_BRK:
        OR AL,CS:BREAK          ;MAAK ER EEN 'BREAK' VAN ALS ER 0F0 IS GEWEEST
        MOV AH,AL
        AND AL,080
        MOV CS:BREAK,AL         ;ZET IN BREAK 080 ALS BRK
        MOV AL,AH
        CMP AL,CS:LASTKEY
        MOV CS:LASTKEY,AL
        JZ GET_OUT_NOBRK_2
        AND AL,07F              ;HAAL BRKBIT ERAF
        CMP AL,053
        JA GET_OUT_NOBRK_2
        TEST AL
        JZ GET_OUT_NOBRK_2
        CALL KEY_TRANS
        MOV BYTE CS:BREAK,0
GET_OUT:
        CALL MATRIX_ERROR       ;EMULEER ZX SPECTRUM KEYBOARD MATRIX
        cmp byte cs:winkey,0
        jnz dont_reset_kbd
        IN AL,061
        PUSH AX
        OR AL,080
        OUT 061,AL
        POP AX
        OUT 061,AL
dont_reset_kbd:
        POP DX
        POP CX
        POP BX
        POP AX
        sti
        IRET
GET_OUT_NOBRK_2:
        MOV byte CS:BREAK,0
        JMP GET_OUT
e0get_out:
        mov byte cs:e0flag,0ff
        jmp get_out

KEY_TRANS:
        PUSH SI
        MOV BX,offset KEYBTAB1
        CS:XLATB
        TEST AL
        JZ GET_OUT_NOBRK
        TEST AL,011000000XB
        JZ NORMAL_CHAR
        MOV BL,AL
        AND BX,011111XB
        MOV SI,BX
        ROL BX,1
        TEST byte CS:[SI+SHFTSTATES],1
        JZ FIRSTTIME                    ;LAAT EERST OUDE TOETS 'INTERN' LOS
        PUSH WORD CS:BREAK
        MOV byte CS:BREAK,080           ;LAAT LOS
        PUSH BX
        PUSH SI
        CALL CS:[BX+KEY_ROUTINES]
        POP SI
        POP BX
        POP WORD CS:BREAK
FIRSTTIME:
        CMP byte CS:BREAK,080
        JZ NOCHANGE_AT_BREAKTIME
        MOV AL,CS:SHIFTSTATE
        OR AL,1                         ;GEEFT AAN 'KEY PRESSED'
        MOV CS:[SI+SHFTSTATES],AL
NOCHANGE_AT_BREAKTIME:
        PUSH SI
        CALL CS:[BX+KEY_ROUTINES]
        POP SI
        CMP byte CS:BREAK,080
        IF Z MOV byte CS:[SI+SHFTSTATES],0   ;'KEY RELEASED'
        JMP GET_OUT_NOBRK

NORMAL_CHAR:
        CMP AL,8                ;SHIFT
        JNZ NOSH
        MOV AH,CS:BREAK
        MOV CS:SHIFTSTATE,AH
NOSH:
        MOV CL,AL
        MOV AH,080
        SHR CL,1
        SHR CL,1
        SHR CL,1
        ROL AH,CL
        CALL SETKBIT
GET_OUT_NOBRK:
        MOV byte CS:BREAK,0
        POP SI
        RET


SETKBIT:
;ZET EEN BIT IN IN_TAB, AFH.V. BREAK. ENTRY: AH=MASK(COL), AL0-2=ROW
        MOV BL,AL
        AND BX,7                ;BX=OFFSET IN_TAB
        ADD BX,OFFSET IN2_TAB
        TEST byte CS:BREAK
        JNZ RESET_BIT
        OR CS:[BX],AH
        RET
RESET_BIT:
        NOT AH
        AND CS:[BX],AH
        RET

set_joystick:
;Zet een bit in in_tab of in kempston_state, afhankelijk van joymode,
;de code in AL (0,1,2,3,4 = links,rechts,onder,boven,schieten) en BREAK.
        xor ah,ah
        mov bx,ax
        mov al,cs:joymode
        add bx,ax
        shl ax,1
        shl ax,1
        add bx,ax
        shl bx,1
        mov ax,cs:[bx+joy_tab]
        push ax
        cmp byte cs:joymode,0
        if z call setshft
        pop ax
        cmp byte cs:joymode,1
        jnz setkbit                     ;kempston krijgt 'sonderbehandlung'
        test byte cs:break
        jnz reset_kempston_bit
        or cs:[kempston_state],al
        ret
reset_kempston_bit:
        not al
        and cs:[kempston_state],al
        ret

joy_tab:
        dw 01003,0404,01004,0804,0104
        dw 2,1,4,8,16
        dw 0103,0203,0403,0803,01003
        dw 01004,0804,0404,0204,0104

KEY_ROUTINES:
        DW KR0,KR1,KR2,KR3,KR4,KR5,KR6,KR7,KR8,KR9,KR10,KR11,KR12,KR13,KR1BIS,kr15
        DW KR16,KR17,KR18,KR19,KR20,KR21,KR22,KR23,KR24,KR25,KR26,KR27,kr28,kr29
;Voor elke key routine is er een shiftstate in z80.8 gereserveerd!!!

KR0:
        MOV AX,0100             ;ESC (=EDIT)
        CALL SETKBIT
        MOV AX,0103
        JMP SETKBIT

KR1:    MOV AX,0207             ;- OF _
        CALL SETKBIT
        MOV AL,1                ;KR1
KR1A:   CALL TESTSHFT
        MOV AX,0806             ;J (-)
        IF NZ MOV AX,0104       ;0 (_)
        JMP SETKBIT
KR1BIS: MOV AX,0207
        CALL SETKBIT
        MOV AL,14
        JMP KR1A

KR2:    MOV AX,0207             ;+ OF =
        CALL SETKBIT
        MOV AL,2
        CALL TESTSHFT
        MOV AX,0206             ;L (=)
        IF NZ MOV AH,4          ;K (+)
        JMP SETKBIT

KR3:    MOV AX,0100             ;BACKSPACE (=SHFT 0)
        CALL SETKBIT
        MOV AX,0104
        JMP SETKBIT

KR4:    MOV AX,0207             ; ; OF :
        CALL SETKBIT
        MOV AL,4
        CALL TESTSHFT
        MOV AX,0205             ;O
        IF NZ MOV AX,0200       ;Z
        JMP SETKBIT

KR5:    MOV AX,0207             ;" OF '
        CALL SETKBIT
        MOV AL,5
        CALL TESTSHFT
        MOV AX,0105             ;P
        IF Z MOV AX,0804
        JMP SETKBIT

KR6:    cmp byte cs:azerty,0ff
        jz kr6_az
        MOV AX,0207             ;, OF <
        CALL SETKBIT
        MOV AL,6
        CALL TESTSHFT
        MOV AX,0807             ;N
        IF NZ MOV AX,0802       ;R
        JMP SETKBIT
kr6_az: mov ax,0207             ;; or .
        call setkbit
        mov al,6
        call testshft
        mov ax,0205             ;O
        if nz mov ax,0407       ;M
        jmp setkbit


KR7:    cmp byte cs:azerty,0ff
        jz kr7_az
        MOV AX,0207             ;. OF >
        CALL SETKBIT
        MOV AL,7
        CALL TESTSHFT
        MOV AX,0407             ;M
        IF NZ MOV AX,01002      ;T
        JMP SETKBIT
kr7_az: mov ax,0207             ;: or /
        call setkbit
        mov al,7
        call testshft
        mov ax,0200             ;Z
        if nz mov ah,010        ;V
        jmp setkbit


KR8:    cmp byte cs:azerty,0ff
        jz kr8_az
        MOV AX,0207             ;/ OF ?
        CALL SETKBIT
        MOV AL,8
        CALL TESTSHFT
        MOV AX,01000            ;V
        IF NZ MOV AH,08         ;C
        JMP SETKBIT
kr8_az: mov ax,0207
        call setkbit            ;, or ?
        mov al,8
        call testshft
        mov ax,0807             ;N
        if nz mov ax,0800       ;C
        jmp setkbit

KR9:    MOV AX,0207             ;*
        CALL SETKBIT
        MOV AX,01007
        JMP SETKBIT

KR10:   MOV AX,0100             ;CAPSLOCK
        CALL SETKBIT
        MOV AX,0203             ;2
        call setkbit
        test byte cs:break
        jnz ret
;        PUSH ES
;        XOR AX,AX
;        MOV ES,AX
;        XOR ES:B[0417],040
;        CALL SET_KBD_LEDS
;        POP ES
        ret

KR11:   TEST byte CS:BREAK           ;NUMLOCK
        JNZ RET
        test cs:b[in2_tab+7],2       ;CTRL/ALT: dan pauze dwz niks doen
        jnz ret
        NOT byte CS:NUMLCK
;        PUSH ES
;        XOR AX,AX
;        MOV ES,AX
;        XOR ES:B[0417],020
;        CALL SET_KBD_LEDS
;        POP ES
        RET

KR12:   TEST byte CS:BREAK           ;SCROLL LOCK
        JNZ RET
        TEST CS:B[IN2_TAB+7],2       ;CTRL/ALT: dan naar DOS
        JZ kr12_no_ctrlalt
        mov byte cs:c_active,0fa
        mov byte cs:c_action_code,0fa     ;zet C flags op aktief, zodat straks bij
        ret                          ;timerinterrupt C-routine wordt aangeroepen
                                     ;(zie xtra.c, label ENTRY)
kr12_no_ctrlalt:
        TEST CS:B[IN2_TAB],1
        jz kr12_no_shift
        MOV byte CS:NMI,0FF     ;ALS SHFT+SCRL_LOCK, DAN NMI
        ret
kr12_no_shift:
;        PUSH ES
;        XOR AX,AX
;        MOV ES,AX
;        XOR ES:B[0417],010      ;toggle scrolllock status
;        CALL SET_KBD_LEDS
;        POP ES
        ret

SET_KBD_LEDS:
;        push es
;        xor ax,ax
;        mov es,ax
;        in al,060
;        mov cx,02000
;set_kbd_leds_delay_twee:
;        loop set_kbd_leds_delay_twee
;        MOV AL,0ED
;        OUT 060,AL
;        PUSH CX
;        MOV CX,02004
;        MOV AL,ES:B[0417]
;        SHR AL,CL
;        and al,7
;SET_KBD_LEDS_DELAY:
;        LOOP SET_KBD_LEDS_DELAY
;        OUT 060,AL
;        POP CX
;        pop es
        RET

KR13:   mov al,3                ;omhoog (keypad 8)
        jmp set_joystick

KR15:   xor al,al               ;links (keypad 4)
        jmp set_joystick

KR16:   mov al,1                ;rechts (keypad 6)
        jmp set_joystick

KR17:   MOV AX,0207             ;+ (OF =)
        CALL SETKBIT
        MOV AL,17
        CALL TESTSHFT
        MOV AX,0406             ;L (+)
        IF NZ MOV AH,2          ;K (=)
        JMP SETKBIT

KR18:   mov al,2                ;omlaag (keypad 2)
        jmp set_joystick

kr19:   mov al,4                     ;INS/DEL/5/TAB: schieten.
        jmp set_joystick



SETSHFT:
        mov al,CS:NUMLCK
        cmp byte cs:rommod,2
        if a xor al,cs:curs128
        test al
        JZ RET
        MOV AX,0100
        JMP SETKBIT

TESTSHFT:
        MOV BL,AL
        XOR BH,BH
        TEST byte CS:BREAK
        JZ NOBRK
        CMP byte CS:[SHFTSTATES+BX],1
        JZ WAS_SHFT
        CMP AL,AL
        RET
WAS_SHFT:
        CMP byte CS:SHIFTSTATE,0
        IF Z OR CS:B[IN2_TAB],1
        RET                             ;ALTIJD NZ
NOBRK:
        AND CS:B[IN2_TAB],0FE
        CMP byte CS:[SHFTSTATES+BX],081
        RET

MATRIX_ERROR:
        PUSH SI
        PUSH DI
        PUSH DS
        PUSH ES
        CLD
        PUSH CS
        PUSH CS
        POP DS
        POP ES
        MOV SI,offset IN2_TAB
        MOV DI,offset IN_TAB
        MOVSW
        MOVSW
        MOVSW
        MOVSW
        MOV SI,offset IN_TAB
        MOV DX,7
MATRIX_LOOP:
        LODSB
        MOV AH,AL
        MOV CX,DX
        MOV DI,SI
M_INNER_LOOP:
        MOV AL,[DI]             ;HAAL VERDEROPLIGGENDE WAARDE
        TEST AL,AH              ;GELIJKE TOETSEN?
        JZ NO_EQ_KEY            ;GEEN GELIJKE TOETS INGEDRUKT
        OR AL,AH                ;OR VERDEROPLIGGENDE WAARDE MET HUIDIGE WAARDE
        MOV AH,AL
NO_EQ_KEY:
        STOSB                   ;ZET NIEUWE WAARDE WEG & INC DI
        LOOP M_INNER_LOOP
        NOT AH
        OR AH,011100000XB
        MOV [SI-1],AH
        DEC DX
        JNZ MATRIX_LOOP
        NOT B[SI]
        OR B[SI],011100000XB
        POP ES
        POP DS
        POP DI
        POP SI
        RET

MSTOSB:
        xor al,cs:b[offset checksum]
        ADD AL,CS:[BP]
        xor al,cs:b[offset checksum+1]
        INC BP
        CMP BP,OFFSET inbuf+256
        IF Z MOV BP,OFFSET inbuf
        STOSB
        ret

SCRUNGEIT:
        CLD
        PUSH CS
        POP ES
        MOV SI,081
        LODSB
        CMP AL,020
        IF NZ DEC SI
        MOV DI,OFFSET INBUF
SCRCPY: LODSB
        STOSB
        CMP AL,0D
        JNZ SCRCPY
        MOV AX,SEG OPC0
        MOV DS,AX
        MOV ES,AX
        XOR SI,SI
        XOR DI,DI
        MOV CX,0FFEF
        MOV BP,OFFSET INBUF
SCR0:   CMP W[SI],03D8A
        JNZ NOBLK
;        CMP W[SI+2],0DB32
;        JNZ NOBLK
        CMP W[SI+2],0E3FF
        JNZ NOBLK
        CMP W[SI+4],09090
        JNZ NOBLK
        CMP W[SI+6],09090
        JNZ NOBLK
        CMP B[SI+8],090
        JNZ NOBLK
        ADD SI,9
        SUB CX,8
        MOV AL,0
        call mstosb
        MOV AL,092
        call mstosb
        MOV AL,090
        call mstosb
        LOOP SCR0

NOBLK:  CMP W[SI],0
        JNZ __NOZERO
        CMP W[SI+2],0
        JNZ __NOZERO
        MOV DX,0
COUNTZERO:
        CMP DX,0100
        JZ EOBFOUND
        CMP CX,-1
        JZ EOBFOUND
        LODSB
        INC DX
        DEC CX
        TEST AL,AL
        JZ COUNTZERO
EOBFOUND:
        DEC DL
        INC CX
        DEC SI
        MOV AL,DL
        call mstosb
        MOV AL,092
        call mstosb
        MOV AL,090
        call mstosb
        JCXZ SCR_FINISHED
        JMP SCR0
__NOZERO: CMP W[SI],09092
        JZ NOPSFOUND
        LODSB
        call mstosb
        DEC CX
        IF NZ JMP SCR0
        JMP SCR_FINISHED
NOPSFOUND:
        MOV AL,1
        call mstosb
        LODSB
        call mstosb
        LODSB
        call mstosb
        DEC CX
        DEC CX
        JMP SCR0
SCR_FINISHED:
        MOV AX,BP
        STOSW
        MOV CS:ROMADR,DI
        mov ah,062
        int 021
        mov ds,bx
        mov ds,[02c]
        xor si,si
getprogname:
        lodsb
        and al,al
        jnz getprogname
        lodsb
        and al,al
        jnz getprogname
        inc si
        inc si
        mov dx,si
        mov ax,03d02
        int 021
        jc interr
        mov bx,ax
        mov ah,03f
        mov cx,10
        push cs
        pop ds
        mov dx,exeheader
        int 021
        jc interr
        mov ax,04202
        mov dx,-0fff0
        mov cx,-1
        int 021
        push es
        pop ds
        mov ah,040
        xor dx,dx
        mov cx,di
        int 021
        jnc noerr
interr: mov dx,ierr
        jmp print
noerr:  mov ax,04201
        xor cx,cx
        xor dx,dx
        int 021
        push dx
        push ax
        mov cx,ax
        xchg dl,dh
        shr dx,1
        and cx,511
        sub ax,cx
        xchg ah,al
        shr ax,1
        add ax,dx               ;ax:cx is lengte
        test cx,cx
        if nz inc ax
        mov cs:w[offset exeheader+2],cx
        mov cs:w[offset exeheader+4],ax
        mov ax,04200
        xor cx,cx
        xor dx,dx
        int 021
        mov ah,040
        mov cx,10
        push cs
        pop ds
        mov dx,offset exeheader
        int 021
        jc interr
        mov ax,cs
        add ax,cs:w[offset exeheader+8]         ;header size
        sub ax,seg _first_func
        mov dl,4
        xor cx,cx
times16:
        shl ax,1
        rcl cx,1
        dec dl
        jnz times16
        add ax,offset romadr
        adc cx,0
        mov dx,ax
        mov ax,04200
        int 021
        push cs
        pop ds
        mov dx,offset romadr
        mov cx,2+256
        mov ah,040
        int 021
        pop dx
        pop cx
        mov ax,04200
        int 021
        mov ah,040
        xor cx,cx
        int 021
        mov ah,03e
        int 021
        if c jmp interr
        mov ax,04c00
        int 021



INSTALL_COM:
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        PUSH ES
        CMP BYTE CS:INMODE,2
        JNZ LEAVE_I_C
        XOR AX,AX
        MOV ES,AX
        MOV AX,CS:INNUM
        MOV BX,0400
        SHL AX,1
        ADD BX,AX
        MOV DX,ES:[BX]
        MOV CS:COMPORT,DX
        and ax,2
        SHL AX,1
        MOV BX,48
        SUB BX,AX
        MOV ES:W[BX],OFFSET GETSENTBYTE
        MOV ES:[BX+2],CS
        MOV BX,CS:INNUM
        AND BL,1
        INC BL
        XOR BL,3
        MOV CL,3
        SHL BL,CL
        NOT BL
        IN AL,021
        AND AL,BL                       ;bit 3/4
        OUT 021,AL
        IN AL,DX                        ;RESET CHIP
        INC DX
        MOV AL,1                        ;EI WHEN DATA AVAIL
        OUT DX,AL
        INC DX
        INC DX
        INC DX
        MOV AL,0
        OUT DX,AL
LEAVE_I_C:
        POP ES
        POP DX
        POP CX
        POP BX
        POP AX
        RET

UNINSTALL_COM:
        CMP BYTE CS:INMODE,2
        JNZ RET
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        MOV DX,CS:COMPORT
        INC DX
        XOR AL,AL
        OUT DX,AL
        INC DX
        INC DX
        INC DX
        OUT DX,AL
        MOV BX,CS:INNUM
        AND BL,1
        INC BL
        XOR BL,3
        MOV CL,3
        SHL BL,CL
        IN AL,021
        OR AL,BL                ;bit 3/4
        OUT 021,AL
        POP DX
        POP CX
        POP BX
        POP AX
        RET

RESET:                          ;For F6 reset, see CAST_RESET in ed.8
        MOV BYTE CS:RI,0        ;I REGISTER OP NUL ZETTEN
        MOV BYTE CS:RR,0        ;R = 0
        MOV BYTE CS:RR_BIT7,16  ;R7 = 0, SAMRAM AAN
        MOV BYTE CS:IMODE,0     ;BIJ RESET: INTERRUPT MODE 0
        MOV BYTE CS:NMI,0       ;GEWONE INTERRUPT GENEREREN
        MOV BYTE CS:IF1FLG,0    ;ZET IF1 ROM UIT
        MOV BYTE CS:QFLAG,0     ;ZET FLAG VOOR EDF8  (ZIE QUEER1 IN INSTR.8)
        MOV WORD CS:RPC,0       ;PROGRAM COUNTER OP 0
        MOV BYTE CS:IFF,0       ;DI
        MOV BYTE CS:IFF2,0      ;VOOR NMI
        MOV BYTE CS:BORCLR,0ff  ;BORDER COLOUR
        MOV BYTE CS:NEWBOR,0
        MOV WORD CS:RS_IN,0
        MOV WORD CS:RS_OUT,0
        MOV BYTE CS:DTR,0
        MOV BYTE CS:CTS,0
        MOV BYTE CS:COMSDAT,0
        RET

GET_REGS:
        MOV AX,CS:RFA
        MOV CX,CS:RBC
        MOV SI,CS:RDE
        MOV DX,CS:RHL
        MOV BP,CS:RSP
        MOV DI,CS:RPC
        RET

SAVE_REGS:
        MOV CS:RFA,AX
        MOV CS:RBC,CX
        MOV CS:RDE,SI
        MOV CS:RHL,DX
        MOV CS:RSP,BP
        MOV CS:RPC,DI
        RET

SAVE_VECTORS:
        XOR AX,AX
        MOV ES,AX
        MOV AX,ES:[32]
        MOV CS:TIMADR,AX
        MOV AX,ES:[34]
        MOV CS:TIMSEG,AX
        MOV AX,ES:[36]
        MOV CS:KBDADR,AX
        MOV AX,ES:[38]
        MOV CS:KBDSEG,AX
        MOV AX,ES:[108]
        MOV CS:CTRLBRKADR,AX
        MOV AX,ES:[110]
        MOV CS:CTRLBRKSEG,AX
        MOV AX,ES:[44]
        MOV CS:COM1ADR,AX
        MOV AX,ES:[46]
        MOV CS:COM1SEG,AX
        MOV AX,ES:[48]
        MOV CS:COM2ADR,AX
        MOV AX,ES:[50]
        MOV CS:COM2SEG,AX
        MOV AX,ES:[52]
        MOV CS:SEGVIOLADR,AX
        MOV AX,ES:[54]
        MOV CS:SEGVIOLSEG,AX
        RET

GET_VECTORS:
        XOR AX,AX
        MOV ES,AX
        MOV AX,CS:TIMADR
        MOV BX,CS:TIMSEG
        MOV ES:[32],AX
        MOV ES:[34],BX
        MOV AX,CS:KBDADR
        MOV BX,CS:KBDSEG
        MOV ES:[36],AX
        MOV ES:[38],BX
        MOV AX,CS:CTRLBRKADR
        MOV BX,CS:CTRLBRKSEG
        MOV ES:[108],AX
        MOV ES:[110],BX
        MOV AX,CS:COM1ADR
        MOV BX,CS:COM1SEG
        MOV ES:[44],AX
        MOV ES:[46],BX
        MOV AX,CS:COM2ADR
        MOV BX,CS:COM2SEG
        MOV ES:[48],AX
        MOV ES:[50],BX
        MOV AX,CS:SEGVIOLADR
        MOV BX,CS:SEGVIOLSEG
        MOV ES:[52],AX
        MOV ES:[54],BX
        RET

init_memory:
        mov byte cs:if1flg,0    ;if1 not paged in
        mov cs:b[offset ramstate+1],0ff
        mov cs:b[offset ramstate+2],0ff
        mov cs:b[offset ramstate+3],0ff
        mov ax,0108
        call swap_mem
        mov ax,0204
        cmp byte cs:rommod,2
        if a mov al,5
        call swap_mem
        mov ax,0305
        cmp byte cs:rommod,2
        if a mov al,3
        call swap_mem
        mov bx,offset in31tab
        mov cx,8
init_mem_clear74ls259:
        mov cs:b[bx],0
        inc bx
        loop init_mem_clear74ls259
        mov byte cs:hstate,0
        ret

INIT_EMULATOR:
        PUSH DS                 ;BEWAAR DS = specseg
        PUSH CS
        POP DS
        MOV byte VID_ACT,0FF    ;VIDEO EMULATIE ACTIEF MAKEN
        call hoesnel            ;om addnum te initialiseren
        CLI
        cmp byte cs:winkey,0
        jne no_tim_inst
        MOV AX,CS:ADDNUM
        OUT 040,AL
        MOV AL,AH
        OUT 040,AL
no_tim_inst:
        MOV byte TIMFLAG,0FF
        MOV byte SHIFTSTATE,080
        MOV byte BREAK,0
        MOV byte E0FLAG,0
        MOV word INTEL,0
        MOV word INTEL2,16384
        MOV word INTEL3,22528
        MOV byte RFSHFLG,0
        MOV byte VIDRFSH,0
        MOV byte VIERTEL,0
        sti
        MOV BX,OFFSET IN_TAB
        MOV CX,8               ;2 KEYTABS
CLEAR_KTB:
        MOV B[BX],255
        INC BX
        LOOP CLEAR_KTB
        MOV CX,8
CLEAR_ALL:
        MOV B[BX],0
        INC BX
        LOOP CLEAR_ALL
        MOV BX,OFFSET SHFTSTATES
        MOV CX,35
CLEAR_SFST:
        MOV B[BX],0
        INC BX
        LOOP CLEAR_SFST
        pop ds
        RET

calcchecksum:
        push ds
        push si
        push bx
        push ax
        push cs
        pop ds
        mov si,offset stext
        xor bx,bx
        cld
l1:     lodsb
        xor bl,al
        add bh,al
        cmp si,offset main
        jnz l1
        mov checksum,bx
        pop ax
        pop bx
        pop si
        pop ds
        ret




END_SPECTR:
        CLI
        MOV AL,020
        OUT 020,AL
        MOV AL,0FF
        OUT 040,AL
        NOP
        NOP
        OUT 040,AL
        IN AL,061
        AND AL,011111100XB
        OUT 061,AL              ;EVT. PIEP UIT
        MOV AX,CS
        MOV DS,AX
        call close_tapefiles
        CALL UNINSTALL_COM
        CALL FLUSHOUTPUT
        CALL CLEARINPUT
        CALL GET_VECTORS
        call mdrv_closeall
        mov dx,cs:emshandle
        mov ah,045
        test dx,dx
        if nz int 067           ;deallocate ems memory
        STI
        call text_mode
        mov bx,cs:romhandle
        mov ah,03e
        test bx,bx
        if nz int 021
        mov bx,cs:xrhandle
        mov ah,03e
        test bx,bx
        if nz int 021
        mov dx,endmes
        mov ah,9
        int 021
        MOV AX,04C00            ;terminate met exit code 00
        INT 021



intro:
        push cs
        pop ds
        mov ax,w[offset specseg]
        mov es,ax
        mov di,16384
        mov ax,seg introscr
        sub ax,0400
        mov ds,ax
        mov si,offset introscr+04000
        cld
        mov cx,6912
        call descr_loop
        push cs
        pop ds
        mov byte vid_act,0ff
        mov byte borclr,4
        mov byte newbor,0
        push es
        pop ds
        call video_update
        mov cx,7
iwaitl: push cx
        mov ah,02c
        int 021
        mov al,dh
iwait:  push ax
        mov ah,0b
        int 021
        and al,al
        jnz key_pressed
        mov ah,02c
        int 021
        pop ax
        cmp al,dh
        jz iwait
        pop cx
        loop iwaitl
        jmp intro_exit
key_pressed:
        pop ax
        pop ax
intro_exit:
        ret



segviolation:                           ;PUSH/POP use MOV BX,DS:[BP]
                                        ;If BP=0ffff, it generates an
        cmp bp,0ffff                    ;interrupt. This routine makes
        jnz notmine                     ;sure the Z80 opcode is emulated
        mov bp,sp                       ;correctly.
        cmp w[bp+2],seg emulate         ;All this won't work with QEMM installed
        jnz notmine_bp
        push ax
        push di
        mov di,bx                       ;temporary storage
        mov ax,w[bp]
        xor ah,193
        test ah,203                     ;push / pop?
        jnz seg_return
        test ah,4                       ;if push, jump forward
        jnz seg_dopushlater
        mov bl,[0ffff]                  ;get the popped value
        mov bh,[0]
seg_dopushlater:
        call seg_xchgregs               ;xchg bx <-> z80 register
        test ah,4
        jz seg_return                   ;if pop, we're done
        mov [0ffff],bl                  ;if push, now push and
        call seg_xchgregs               ;restore z80 register
seg_return:
        mov ax,[bp]
        add ax,4                        ;step over problematic instruction
        mov [bp],ax
        mov bx,di
        pop di
        pop ax
        mov bp,0ffff
        iret
notmine_bp:
        mov bp,0ffff
notmine:
        jmp far cs:d[offset segvioladr]

seg_xchgregs:
        test ah,16
        jnz seg_deoraf
        test ah,32
        jnz seg_hl
        xchg bx,cx
        ret
seg_hl:
        cmp al,04d
        if b xchg bx,dx
        if ae xchg bx,di
        ret
seg_deoraf:
        test ah,32
        jnz seg_af
        xchg bx,si
        ret
seg_af:
        xchg bx,[bp-2]
        ret

adlib_write:                 ;writes value ah to register al
        push cx
        push dx
        mov dx,0388
        out dx,al
        in al,dx
        in al,dx
        in al,dx
        in al,dx
        in al,dx
        in al,dx
        mov al,ah
        inc dx
        out dx,al
        pop dx
        pop cx
        ret

adlib_writep:
        call adlib_write
adlib_pause:
        push ax
        push dx
        push cx
        mov dx,0388
        mov cx,35
adlib_wait2:
        in al,dx
        loop adlib_wait2
        pop cx
        pop dx
        pop ax
        ret


cms_write:                      ;writes value ah to register al
        push dx
        mov dx,0221
        out dx,al
        xchg ah,al
        dec dx
        out dx,al
        xchg ah,al
        pop dx
        ret


adlib_init:
        cmp byte cs:adlib,0ff
        jnz ret
        mov ax,06004
        call adlib_writep
        mov ax,08004
        call adlib_writep
        mov dx,0388
        in al,dx
        push ax
        mov ax,0ff02
        call adlib_writep
        mov ax,02104
        call adlib_writep
        mov cx,200
l1:     in al,dx
        loop l1
        push ax
        mov ax,04
        call adlib_writep
        pop ax
        and al,0e0
        cmp al,0c0
        pop ax
        if nz jmp adlib_notok
        and al,0e0
        if nz jmp adlib_notok
        mov byte cs:intsnd,0    ;disable internal speaker '128 sound
        mov byte cs:s_oldctrl,0ff
        mov ax,0
l1:     push ax
        call adlib_writep
        pop ax
        inc al
        jnz l1
        mov ax,02001
        call adlib_writep        ;enable distorted waveforms
        mov al,020
        mov cx,6                ;three carriers and modulators
l1:     push ax
        mov ah,021              ;frequency multiple 1, normal sustain
        call adlib_writep
        pop ax
        push ax
        mov ah,1                ;distorted sine wave
        add al,0c0
        call adlib_writep
        pop ax
        push ax
        mov ah,0ff              ;ff
        add al,040
        call adlib_writep       ;quick attack, no decay
        pop ax
        push ax
        mov ah,00f
        add al,060
        call adlib_writep       ;(sustain: loud, release: quick)
        pop ax
        inc al
        loop l1
        mov al,0
        mov cx,3                ;3 modulator/carrier operators
l1:     push ax
        mov ah,0
        add al,0c0              ;F.M. synthesis, no feedback
        call adlib_writep
        pop ax
        push ax
        mov ah,010               ;Modulator total level about 40 db
        add al,040
        call adlib_writep
        pop ax
        inc al
        loop l1
        cmp byte cs:cmschips,0ff
        jz usecms
        mov ax,02134            ;snare drum: normal envelope, multi=1
        call adlib_writep
        mov ax,0f074            ;quick attack, no decay
        call adlib_writep
        mov ax,0f94             ;(max sustain, quick release)
        call adlib_writep
        mov ax,028bd            ;turn on snare drum
        call adlib_writep
        call adlib_quiet
        mov dx,adlib_msg
        jmp >l1
usecms:
        mov ax,0                ;channel 0 amp 0
        call cms_write
        mov ax,014              ;disable tone all channels
        call cms_write
        mov ax,0115
        call cms_write          ;disable noise all channels but channel 0
        mov ax,0ff16
        call cms_write          ;highest available noise frequency
        mov ax,011c
        call cms_write          ;sound enable
        mov dx,adlib_msg
        jmp >l1
adlib_notok:
        mov byte cs:adlib,0
        mov dx,noadlib_msg
l1:     push ds
        push cs
        pop ds
        mov ah,9
        int 021
        pop ds
        ret


adlib_quiet:
        cmp byte cs:intsnd,0ff
        jz int_quiet
        cmp byte cs:adlib,0ff
        jnz ret
        mov ax,03f43
        call adlib_writep
        mov ax,03f44
        call adlib_writep
        mov ax,03f45
        call adlib_writep
        mov ax,03f54
        call adlib_writep
        cmp byte cs:cmschips,0ff
        jne ret
        mov ax,0
        call cms_write
        ret
int_quiet:
        in al,061
        and al,011111100xb
        out 061,al
        ret


adlib_turnon:
        cmp byte cs:rommod,2
        jbe ret
        cmp byte cs:silence,0
        jnz ret
        cmp byte cs:intsnd,0ff
        jz turnon_int
        cmp byte cs:adlib,0ff
        jnz ret
turnon_int:
        mov byte cs:[offset s_oldctrl],0ff
        mov al,cs:lastfffd
        push ax
        mov bx,offset sstate
        mov cx,14
        mov cs:b[offset lastfffd],0
        mov al,cs:[bx+7]
        not al
        mov cs:s_oldctrl,al
adlib_outit:
        push bx
        mov ah,cs:[bx]
        call far out_128_soundchip
        pop bx
        inc bx
        inc byte cs:lastfffd
        loop adlib_outit
        pop ax
        mov cs:lastfffd,al
        ret



queer2_ems:
        push es
        push ax
        cmp byte cs:sambank,1   ;samrom 1 active?
        jz q2_active
        push cx
        push dx
        push si
        push di
        mov ax,04400            ;phys. page 0 (rom)
        mov bx,2                ;samrom 1
        mov dx,cs:emshandle
        int 067
        mov ax,cs:samseg
        mov es,ax
        xor si,si
        xor di,di
        mov cx,02000
        cld
        rep movsw
        mov ax,04400
        mov bl,cs:[offset ramstate]
        xor bh,bh
        int 067
        pop di
        pop si
        pop dx
        pop cx
        mov byte cs:sambank,1
q2_active:
        mov ax,cs:samseg
        mov es,ax
        cmp si,04000
        pop ax
        ja $+1
        es:
        mov al,[si]
        pop es
        mov bx,dx
        cmp bh,040
        if ae mov [bx],al
        xchg bx,si
        inc bl
        xchg bx,si
        inc dh
        jmp far emulate

ldobhla_ems:
        push dx
        push ax
        mov dx,cs:emshandle
        mov bl,cs:[offset ramstate+2]   ;4 or 6
        xor bl,2                        ;other 32k bank
        xor bh,bh
        mov ax,04402
        int 067
        inc bl
        mov ax,04403
        int 067
        pop ax
        pop bx
        cmp bh,040
        if ae mov [bx],al
        push bx
        push ax
        mov bl,cs:[offset ramstate+2]
        xor bh,bh
        mov ax,04402
        int 067
        inc bl
        mov ax,04403
        int 067
        pop ax
        pop dx
        jmp far emulate

ldobahl_ems:
        push dx
        push ax
        mov dx,cs:emshandle
        mov bl,cs:[offset ramstate+2]   ;4 or 6
        xor bl,2                        ;other 32k bank
        xor bh,bh
        mov ax,04402
        int 067
        inc bl
        mov ax,04403
        int 067
        pop ax
        pop bx
        mov al,[bx]
        push bx
        push ax
        mov bl,cs:[offset ramstate+2]
        xor bh,bh
        mov ax,04402
        int 067
        inc bl
        mov ax,04403
        int 067
        pop ax
        pop dx
        jmp far emulate




JOYSTICK_UPDATE:
        test byte cs:zandjoy,0ff
        jz upd_no_zandbergen
        mov dx,0201
        in al,dx
        out dx,al
        xor al,16
        and al,31
        mov bl,al
        shr bl,1
        xor bl,al
        test bl,1
        if nz xor al,3
        mov bl,al
        jmp short j_upd_algemeen
        ret
upd_no_zandbergen:
        mov cx,cs:joytel
        test cx
        jz ret
        push dx
        push si
        push di
        shr cx,1
        add cx,cs:joytel
        push cx
        call meetjoystick
        pop cx
        add si,cs:joytelsi
        sub si,cx
        add di,cs:joyteldi
        sub di,cx
        in al,dx
        and al,16
        xor al,16
        mov bl,al
        mov ax,cs:joytelsi
        shl ax,1
        xor dx,dx
        mov cx,5
        div cx
        test si,si
        js sineg
        cmp si,ax
        if a or bl,1
        jmp short sidone
sineg:  neg si
        cmp si,ax
        if a or bl,2
sidone: mov ax,cs:joyteldi
        shl ax,1
        xor dx,dx
        div cx
        test di,di
        js dineg
        cmp di,ax
        if a or bl,8
        jmp short didone
dineg:  neg di
        cmp di,ax
        if a or bl,4
didone: mov al,bl
j_upd_algemeen:
        xor al,cs:joyxy
        mov cs:joyxy,bl
        jz j_upd_end
        mov cl,0
j_upd_loop:
        clc
        rcr bl,1
        sbb ah,ah
        not ah
        clc
        rcr al,1
        jnc j_zelfde
        push bx
        push cx
        xchg byte cs:break,ah
        push ax
        mov al,cl
        call set_joystick
        pop ax
        xchg byte cs:break,ah
        pop cx
        pop bx
j_zelfde:
        inc cl
        test al,al
        jnz j_upd_loop
        call matrix_error
j_upd_end:
        pop di
        pop si
        pop dx
        ret



meetjoystick:
        mov dx,0201
        out dx,al
        mov si,0
        mov di,0
        mov ah,3
        cli
j_get_pos:
        in al,dx
        not al
        and al,ah
        jz j_nochange
        test al,1
        jz j_noxpos
        mov si,cx               ;xpos
        and ah,2
j_noxpos:
        test al,2
        jz j_nochange
        mov di,cx               ;ypos
        and ah,1
j_nochange:
        loop j_get_pos
        sti
        ret


INITJOYSTICK:
        mov word cs:joytel,0
        cmp byte cs:zandjoy,0ff
        jne ret                 ;Return als opties -kk of -kz gegeven zijn.
        mov dx,0201
        out dx,al
        mov cx,0
initjoypauze:
        loop initjoypauze
        in al,dx
        and al,0e0
        cmp al,060
        jnz no_zandbergen       ;Geen Ruud Zandbergen joystick
        mov byte cs:zandjoy,1
        mov dx,zandjoymes
        jmp print
no_zandbergen:
        mov byte cs:zandjoy,0
        mov cx,30000
        call meetjoystick
        xor ax,ax
        cmp si,ax
        jz nojoystick
        cmp di,ax
        jz nojoystick
        mov ax,30000
        sub ax,si
        mov cs:joytelsi,ax
        mov ax,30000
        sub ax,di
        mov cs:joyteldi,ax
        mov ax,30000
        cmp si,di
        if a mov si,di
        sub ax,si
nojoystick:
        mov cs:joytel,ax
        mov dx,normjoymes
        if z mov dx,nojoymes
        jmp print



startup ends

