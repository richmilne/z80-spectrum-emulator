;
;   This file is part of the registered Spectrum emulator package 'Z80'
;   version 2.01, and may not be distributed.  You may use this source for
;   other PC based Spectrum or Z80 emulators only after permission.  It is
;   however permitted to use this source file or parts thereof for Spectrum
;   or Z80 emulators on non-PC based machines, provided that the source is
;   acknowledged.
;
;                                                       Gerton Lunter, 3/5/93

startup segment para public

INIT_VIDEO:
        MOV AH,0F
        INT 010
        MOV CS:OLD_MODE,AL
        CMP BYTE CS:XTDHERC,0FF
        IF Z JMP INIT_XTD_HERC
        CMP BYTE CS:HERCFLG,0FF
        if Z jmp INIT_HERC
        CMP BYTE CS:CGA,0FF
        if Z jmp INIT_CGA
        CMP BYTE CS:EGA,0FF
        IF Z JMP INIT_EGA
        cmp byte cs:vga,0ff
        if z jmp init_vga
        CMP BYTE CS:PLANTR,0FF
        IF Z JMP INIT_PLANTR

        push es
        push cs
        pop es
        mov di,offset vga_workspace
        xor bx,bx
        mov ax,01b00
        int 010
        pop es
        cmp al,01b
        if z jmp init_vga

        mov bl,010                      ;return ega info
        mov ah,012
        int 010
        cmp bl,010
        if nz jmp init_ega

        CALL GET_TT
        CMP CS:BYTE TTYPE,1
        IF NZ JMP INIT_PLANTR

        CALL HERCPRESENT
        CMP AL,1
        JZ INIT_HERC

        mov dx,03d4
        mov al,0f
        out dx,al
        inc dx
        in al,dx
        xchg ah,al
        mov al,0bf
        out dx,al
        mov cx,0100
waitCRT:
        loop waitCRT
        in al,dx
        xchg ah,al
        out dx,al
        cmp ah,0bf
        if e jmp init_cga

        MOV AH,09
        MOV DX,OFFSET VIDMES
        PUSH CS
        POP DS
        INT 021
        MOV AX,04C01
        INT 021



INIT_CGA:
;initialiseer CGA
        MOV BYTE CS:GMOD,0           ;'CGA'
        CALL PRVK
        MOV AX,04
        INT 010
        MOV AH,0B
        XOR BX,BX
        INT 010
        MOV AH,0B
        MOV BX,0101
        INT 010
        RET
;initialiseer Hercules
INIT_HERC:
        MOV BYTE CS:GMOD,1           ;'HERC', VOOR SCHERM EMULATIE SPECTRUM
        CALL PRVK
        MOV BYTE CS:MODE,1           ;GRAFISCHE MODE, VOOR SETMODE
INIT_HERC2:
        CALL SETMODE
        PUSH ES
        MOV AX,0B000
        MOV ES,AX
        XOR AX,AX
        MOV DI,AX
        MOV CX,04000
        REP STOSW
        POP ES
        RET
INIT_XTD_HERC:
        MOV BYTE CS:GMOD,2
        CALL PRVK
        MOV BYTE CS:MODE,2
        JMP INIT_HERC2

INIT_PLANTR:
        MOV BYTE CS:GMOD,3              ;'PLANTRONICS'
        CALL PRVK
        MOV BYTE CS:MODE,1              ;GRAFISCH
        CALL GET_TT                     ;HAAL TERMINAL TYPE OP
        CALL SETMODE
        PUSH ES
        MOV AX,0B000
        MOV ES,AX
        XOR AX,AX
        MOV DI,AX
        MOV CX,08000
        REP STOSW
        POP ES
        RET

INIT_EGA:
        MOV BYTE CS:GMOD,4           ;'EGA'
        CALL PRVK
        MOV AX,0d
        INT 010
        mov dx,ega_list
        cmp cs:byte egapal,0
        if nz mov dx,ega_list_2
        mov ax,01002
        push es
        push cs
        pop es
        push cs
        pop ds
        int 010
        pop es
        ret

EGA_LIST:
EGA_BORDER_PALETTE:
        db 0,1,4,5,2,19,22,23,0,1,20,21,18,19,22,23,0
EGA_LIST_2:
        db 0,5,5,7,40,56,56,63,0,5,5,7,40,56,56,63,0

init_vga:
        push es
        push cs
        pop es
        mov di,offset vga_workspace
        xor bx,bx
        mov ax,01b00
        int 010
        pop es
        mov al,cs:b[offset vga_workspace+02a]
        mov cs:vgascan,al
        mov byte cs:gmod,5              ;vga
        call prvk
        mov ax,3                        ;Needed for unknown reason.
        int 010
        push es
        push cs
        pop es
        mov ax,01200                    ;Select 200 scan lines.
        mov bl,030
        int 010
        mov ax,1                        ;Mode 1
        int 010
        xor al,al
        mov di,offset vga_workspace
        mov cx,0100
initv_1:
        stosb
        cmp byte cs:trivga,0ff
        if z stosb
        inc al
        loop initv_1
        mov cx,0100
        mov ax,01110
        mov bx,0100
        cmp byte cs:trivga,0ff
        if z inc bh
        xor dx,dx
        mov bp,offset vga_workspace
        int 010
        mov ah,1
        mov cx,0100
        int 010
        cmp byte cs:greyvga,0ff
        jnz keep_blue
        mov cs:b[offset vga_palette+3],25
        mov cs:b[offset vga_palette+27],25
keep_blue:
        mov ax,01012
        mov dx,offset vga_palette
        xor bx,bx
        mov cx,16
        int 010
        cmp byte cs:greyvga,0ff
        jnz geen_robkleuren
        mov ax,0101b
        xor bx,bx
        mov cx,16
        int 010
geen_robkleuren:
        mov dx,03da
        in al,dx
        mov dx,03c0
        mov al,030                      ;Bit 5: no snow
        out dx,al
        inc dl
        in al,dx
        and al,011110100xb              ;No blinking, Color attributes
        mov bl,al                       ; and Alphanumeric
        mov dx,03da
        in al,dx
        mov dx,03c0
        mov al,030
        out dx,al
        mov al,bl
        out dx,al
        mov cx,16
        mov al,0
initv_palette:                          ;Initialise the 16 attributes
        out dx,al
        jmp $+2
        out dx,al
        inc al
        loop initv_palette
        mov al,8                       ;Border
        out dx,al
        xor al,al
        out dx,al
        mov al,49                       ;Overscan
        out dx,al
        xor al,al
        out dx,al
        mov di,offset vga_workspace
        mov cx,0200
        xor bl,bl
initv_attrs:
        mov al,bl
        mov ah,al
        shr al,1
        shr al,1
        shr al,1
        and ax,0707
        test bl,64
        if nz add ax,0808
        cmp al,8
        if z xor al,al
        cmp ah,8
        if z xor ah,ah
        cmp cx,0100
        ja initv_noflash
        test bl,128
        if nz xchg al,ah
initv_noflash:
        shl al,1
        shl al,1
        shl al,1
        shl al,1
        or al,ah
        stosb
        inc bl
        loop initv_attrs
        mov cx,768
        xor bx,bx
initv_table:
        mov ax,bx
        and ax,0ffe0
        mov dx,10
        mul dx
        mov dx,bx
        and dx,31
        add ax,dx
        add ax,ax
        add ax,4*40*2+4*2+1
        stosw
        inc bx
        loop initv_table
        mov cx,6144/2
        xor bx,bx
initv_table2:
        push cx
        mov ax,bx
        and ax,31
        add ax,ax
        mov si,ax
        mov ax,bx
        and ax,224
        mov cl,5
        shr ax,cl
        mov dx,80*8
        mul dx
        add si,ax
        mov ax,bx
        and ax,1792
        xchg al,ah
        mov dx,80
        mul dx
        add si,ax
        mov ax,bx
        and ax,6144
        xchg al,ah
        mov cl,3
        shr ax,cl
        mov dx,64*80
        mul dx
        add ax,si
        add ax,4*40*2+4*2
        stosw
        pop cx
        inc bx
        inc bx
        loop initv_table2
        mov ax,0b800
        mov es,ax
        xor di,di
        mov ax,08800                    ;All border
        mov cx,8000
        rep stosw
        cmp cs:trivga,0ff
        jz vga_optionxv
        push ds
        mov ax,seg _flash               ;dummy variable
        mov ds,ax
        mov es,ax
        call far _printmes
        pop ds
vga_optionxv:
        pop es
        ret

vga_palette:
        db 0,0,0, 0,0,40, 55,0,0, 57,0,45, 0,53,0, 0,53,53, 52,52,0, 50,50,50
        db 0,0,0, 0,0,43, 60,0,0, 63,0,55, 0,60,0, 0,63,63, 63,63,0, 63,63,63

HERC_TABLES:
        DB 32,061,050,052,0F,019,06,019,019,02,0D,0B,0C
        DB 2, 035,02D,02E,07,05B,02,058,058,02,03,0 ,0
        DB 2, 035,02A,02B,0A,064,02,061,061,02,03,0 ,0

PLANTR_TABLES:
        DB 071,050,05A,0A,01F,06,019,01C,02,07,06,07,0,0,0,0
        db 038,028,02d,0a,07f,06,064,070,02,01,06,07,0,0,0,0
        db 038,028,02d,0a,07f,06,064,070,02,01,06,07,0,0,0,0

HERCPRESENT:
        MOV BX,0100
        MOV DX,03BA
        IN AL,DX
        MOV AH,AL
        AND AH,080
WAIT_EV_2:
        MOV CX,040
WAIT_FOR_EVENT:
        IN AL,DX
        AND AL,080
        CMP AL,AH
        LOOPE WAIT_FOR_EVENT
        JNE GOT_EVENT
        DEC BX
        JNE WAIT_EV_2
        JMP HERC_NOT_FOUND

GOT_EVENT:
        MOV AX,0B000
        MOV ES,AX
        CALL CHECK_RAM
        JNE FOUND_HERC
        MOV AL,1
        MOV DX,03BF
        OUT DX,AL
        CALL CHECK_RAM
        JE HERC_NOT_FOUND
FOUND_HERC:
        MOV AL,1
        RET
HERC_NOT_FOUND:
        XOR AL,AL
        RET
CHECK_RAM:
        ES MOV BL,B[07FFF]
        ES MOV CL,B[03FFF]
        ES INC B[03FFF]
        ES CMP BL,B[03FFF]
        ES MOV B[03FFF],CL
        RET

GET_TT:
        CMP CS:BYTE TTYPE,0
        JNZ RET
        MOV CS:BYTE TTYPE,1     ;'GEEN PLANTRONICS'
        PUSH ES
        XOR AX,AX
        MOV ES,AX
        CMP ES:W[0463],03D4
        POP ES
        JNZ RET
        MOV AH,0
        INT 01A
        MOV BX,DX
WAIT_TIM:
        MOV AH,0
        INT 01A
        CMP BX,DX
        JZ WAIT_TIM
        MOV DX,BX
        XOR CX,CX
WAIT_TIM2:
        MOV AH,0
        INT 01A
        CMP BX,DX
        JZ WAIT_TIM2
COUNTIT:
        MOV DX,03DA
        IN AL,DX
        AND AL,8
        JnZ COUNTIT
COUNTIT2:
        IN AL,DX
        AND AL,8
        JZ COUNTIT2
        INC CX
        CMP CX,40
        JNZ COUNTIT
        MOV AH,0
        INT 01A
        SUB DX,BX
        CMP DX,14
        JB RET
        CMP DX,19
        JA RET
        MOV CS:BYTE TTYPE,2     ;EMULATION MODE
        CMP DX,16
        JA RET
        MOV CS:BYTE TTYPE,3     ;COLOR MODE
        RET

SETMODE:
        CMP CS:BYTE GMOD,3
        JZ SETMOD_PLANTR
        MOV AL,CS:MODE
        CMP AL,2
        IF A MOV AL,1
        MOV AH,0D
        MUL AH
        MOV SI,AX
        ADD SI,HERC_TABLES
        MOV DX,03BF
        MOV AL,1
        OUT DX,AL
        MOV AL,CS:[SI]
        MOV DL,0B8
        OUT DX,AL
        MOV CX,0
        MOV DL,0B4
NOT_EOT:
        MOV AL,CL
        OUT DX,AL
        INC SI
        MOV AL,CS:[SI]
        INC DX
        OUT DX,AL
        DEC DX
        INC CX
        CMP CL,0C
        JNE NOT_EOT
        SUB SI,0C
        MOV AL,CS:[SI]
        OR AL,8
        MOV DL,0B8
        OUT DX,AL
        RET
SETMOD_PLANTR:                  ;MODE 0=TEXT, 1=GRAPH (ADHV TTYPE)
        MOV DX,03D8
        MOV AL,2
        OUT DX,AL
        CMP CS:BYTE MODE,0
        JZ SETMOD_PLANTR_TEXT
        CMP CS:BYTE TTYPE,2
        JZ SETMOD_PLANTR_EMUL
        MOV DL,0DD
        mov al,010
        OUT DX,AL
        MOV DL,0D8
        MOV AL,2
        OUT DX,AL
        MOV BX,OFFSET PLANTR_TABLES+32
        CALL PROGRAM_CRT
        MOV AL,0A
        OUT DX,AL
        MOV AL,030
        INC DL
        OUT DX,AL
        MOV DL,0DD
        mov al,010
        OUT DX,AL
        RET
SETMOD_PLANTR_EMUL:
        MOV DL,0DD
        mov al,010
        OUT DX,AL
        MOV DL,0DF
        MOV AL,0A2
        OUT DX,AL
        MOV DL,0D8
        MOV AL,2
        OUT DX,AL
        MOV BX,OFFSET PLANTR_TABLES+16
        CALL PROGRAM_CRT
        MOV AL,0A
        OUT DX,AL
        INC DL
        MOV AL,030
        OUT DX,AL
        MOV DL,0DF
        MOV AL,0A0
        OUT DX,AL
        mov al,010
        MOV DL,0DD
        OUT DX,AL
        RET
SETMOD_PLANTR_TEXT:
        MOV DL,0DD
        XOR AL,AL
        OUT DX,AL
        MOV DL,0D8
        MOV AL,025
        OUT DX,AL
        MOV BX,OFFSET PLANTR_TABLES
        CALL PROGRAM_CRT
        MOV AL,02D
        OUT DX,AL
        INC DL
        MOV AL,030
        OUT DX,AL
        MOV DL,0DD
        XOR AL,AL
        OUT DX,AL
        RET
PROGRAM_CRT:
        MOV DX,03D4
        MOV AH,0
PROGRAM_CRT_LOOP:
        XCHG AH,AL
        OUT DX,AL
        XCHG AH,AL
        INC DL
        MOV AL,CS:[BX]
        INC BX
        OUT DX,AL
        DEC DL
        INC AH
        CMP AH,16
        JNZ PROGRAM_CRT_LOOP
        MOV DX,03D8
        RET

PRVK:   MOV DX,OFFSET VIDEOKAART
        PUSH DS
        PUSH CS
        POP DS
        MOV AH,9
        INT 021
        MOV AL,GMOD
        MOV DX,OFFSET VK1
        CMP AL,1
        IF Z MOV DX,OFFSET VK2
        CMP AL,2
        IF Z MOV DX,OFFSET VK3
        CMP AL,4
        IF Z MOV DX,OFFSET VK4
        CMP AL,3
        IF Z MOV DX,OFFSET VK5
        cmp al,5
        if z mov dx,offset vk6
        MOV AH,9
        INT 021
        POP DS
        CALL SAVE_SCREEN
        RET

text_mode:
        cmp cs:gmod,5
        jnz no_vga
        mov ah,012
        mov al,cs:vgascan
        mov bl,030
        int 010                         ;Reset # scanlines
no_vga: CMP BYTE CS:GMOD,1              ;HERCULES
        JZ hercc
        cmp byte cs:gmod,2
        jz hercc
        cmp byte cs:gmod,3              ;Plantronics
        jNz NO_HERC2
hercc:
        MOV BYTE CS:MODE,0              ;HERCULES TEXT / plantronics off
        CALL SETMODE
NO_HERC2:
        MOV AL,CS:OLD_MODE
        MOV AH,0
        INT 010
        jmp GET_SCREEN



VIDEO_UPDATE:
        STD
        TEST BYTE CS:VID_ACT
        JZ RET
        PUSH SI
        PUSH DI
        PUSH BP
        PUSH DX
        PUSH ES
        push ds
;        mov ax,04003            ;talk to windows
;        int 02f
        mov ds,cs:specseg
        MOV ES,CS:VIDBUFSEG
        MOV BL,16
        CMP BYTE CS:FLASH,0
        IF NZ MOV BL,8
        MOV AL,CS:FLSHCNT
        INC AL
        MOV CS:FLSHCNT,AL
        AND AL,BL
        MOV AX,ATTR_TAB
        IF Z DEC AH             ;GA NAAR ATTR_TAB_F
        CMP AX,CS:ATRFLSH
        MOV CS:ATRFLSH,AX
        JZ START_VID_EMULATING
        MOV BX,AX
        MOV SI,23294
        MOV CX,768/2
ZERO_FLASH:
        LODSW
        AND AX,08080
        not ax
        and ES:[si+2],ax
        LOOP ZERO_FLASH
        MOV AX,BX
        MOV cs:[offset ATRPOK1],AX
        MOV cs:[offset ATRPOK2],AX
        MOV cs:[offset ATRPOK3],AX
        MOV cs:[offset ATRPOK4],AX
        MOV cs:[offset ATRPOK5],AX
        MOV cs:[offset ATRPOK6],AX
        MOV cs:[offset ATRPOK7],AX
        MOV cs:[offset ATRPOK8],AX
        ADD aX,0300             ;Ga naar EGA attr area's
        MOV cs:[offset ATRPOK9],AX
        MOV cs:[offset ATRPOKA],AX
        sub ax,0300+attr_tab
        push ax
        add ax,offset vga_workspace+0100
        mov cs:[offset atrpokvga],ax
        pop ax
        add ax,cs:atradr           ;Ga naar Plantronics attr's
        mov cs:[offset atrpokb1],ax
        mov cs:[offset atrpokc1],ax
        add ax,0300             ;ga naar 2e plantronics attr's
        mov cs:[offset atrpokb2],ax
        mov cs:[offset atrpokc2],ax
START_VID_EMULATING:
        cmp byte cs:rommod,3
        jb one_screen
        test byte cs:hstate,8           ;Is the screen at page 7?
        je one_screen                   ;Nope, page 5 is (fixed at 4000)
        cmp byte cs:[ramstate+3],10     ;Hope it is paged in bank 3
        je second_at_c000
        test word cs:emshandle          ;Hope we're not using EMS
        je second_in_ram
        mov ax,010a
        call swap_mem
        stc                     ;Signal: restore memory state afterwards!!
        pushf
        jmp short two_screens
second_in_ram:
        mov ax,cs:romseg
        add ax,9*0400
        push ax
        pop ds                  ;ds:04000 = page 7, int. page 10
        jmp short one_screen
second_at_c000:
        push ds
        pop ax
        add ax,0800
        push ax
        pop ds
one_screen:
        clc
        pushf                   ;This signals: memory state hasn't changed
two_screens:
        cmp byte cs:gmod,5
        if z jmp vga_emul
        MOV SI,16384+6910
        MOV DI,SI
        MOV CX,768/2
        CMP BYTE CS:GMOD,1      ;1=Hercules
        if Z jmp HERC_EMUL
        CMP BYTE CS:GMOD,2      ;2=XTD HERC
        if Z jmp XTD_HERC_EMUL
        CMP BYTE CS:GMOD,4      ;4=EGA
        IF Z JMP EGA_EMUL
        CMP BYTE CS:GMOD,3      ;3=PLANTRONICS
        IF Z JMP PLANT_EMUL
ATTR_SCAN:
        REPZ CMPSW
        JZ START_SCREEN_SCAN
        call addrconvert
        CALL EMULATTR_CGA
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP ATTR_SCAN
l1:     inc cx
        cmp al,al
        jmp attr_scan
START_SCREEN_SCAN:
        MOV CX,6144/2
SCREEN_SCAN:
        REPZ CMPSw
        JZ END_VID_UPDATE
        call addrconvert
        CALL EMULSCRN_CGA
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP screen_SCAN
l1:     inc cx
        cmp al,al
        JMP SCREEN_SCAN
END_VID_UPDATE:
        MOV AL,CS:NEWBOR
        AND AL,7
        CMP AL,CS:BORCLR
        JZ NO_EMUL
        MOV CS:BORCLR,AL
        CMP BYTE CS:GMOD,0
        IF Z CALL BOREMUL_CGA
        CMP BYTE CS:GMOD,1
        IF Z CALL BOREMUL_HERC
        CMP BYTE CS:GMOD,2
        IF Z CALL BOREMUL_X_HERC
        CMP BYTE CS:GMOD,4
        IF Z CALL BOREMUL_EGA
        CMP BYTE CS:GMOD,3
        IF Z CALL BOREMUL_PLANT
        cmp byte cs:gmod,5
        if z call boremul_vga
NO_EMUL:
        popf
        mov ax,0108
        if c call swap_mem

;        mov ax,04004
;        int 02f                 ;talk to windows again

        pop ds
        POP ES
        POP DX
        POP BP
        POP DI
        POP SI
        RET

HERC_EMUL:
        REPZ CMPSw
        JZ START_SCREEN_SCAN_HERC
        call addrconvert
        CALL EMULATTR_herc
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP herc_emul
l1:     inc cx
        cmp al,al
        JMP HERC_EMUL
START_SCREEN_SCAN_HERC:
        MOV CX,6144/2
SCREEN_SCAN_HERC:
        REPZ CMPSw
        if Z jmp END_VID_UPDATE
        call addrconvert
        CALL EMULSCRN_HERC
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP screen_SCAN_herc
l1:     inc cx
        cmp al,al
        JMP SCREEN_SCAN_HERC

XTD_HERC_EMUL:
        REPZ CMPSw
        JZ START_SCREEN_SCAN_X_HERC
        call addrconvert
        CALL EMULATTR_x_herc
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP xtd_herc_emul
l1:     inc cx
        cmp al,al
        JMP XTD_HERC_EMUL
START_SCREEN_SCAN_X_HERC:
        MOV CX,6144/2
SCREEN_SCAN_X_HERC:
        REPZ CMPSw
        if Z jmp END_VID_UPDATE
        call addrconvert
        CALL EMULSCRN_X_HERC
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP screen_SCAN_x_herc
l1:     inc cx
        cmp al,al
        JMP SCREEN_SCAN_X_HERC

PLANT_EMUL:
        REPZ CMPSw
        JZ START_SCREEN_SCAN_PLANT
        call addrconvert
        CALL EMULATTR_PLANT
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP plant_emul
l1:     inc cx
        cmp al,al
        JMP PLANT_EMUL
START_SCREEN_SCAN_PLANT:
        MOV CX,6144/2
SCREEN_SCAN_PLANT:
        REPZ CMPSw
        if Z jmp END_VID_UPDATE
        call addrconvert
        CALL EMULSCRN_PLANT
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP screen_SCAN_plant
l1:     inc cx
        cmp al,al
        JMP SCREEN_SCAN_PLANT

EGA_EMUL:
        MOV DX,03CE
        mov ax,03
        out dx,ax
        MOV AX,0205
        OUT DX,AX                       ;WRITE MODE 2, READ MODE 0
EGA_EMUL_LOOP:
        REPZ CMPSw
        JZ START_SCREEN_SCAN_EGA
        call addrconvert
        CALL EMULATTR_EGA
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP ega_emul_loop
l1:     inc cx
        cmp al,al
        JMP EGA_EMUL_LOOP
START_SCREEN_SCAN_EGA:
        MOV CX,6144/2
SCREEN_SCAN_EGA:
        REPZ CMPSw
        JZ END_VID_UPDATE_EGA
        call addrconvert
        CALL EMULSCRN_EGA
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP screen_SCAN_ega
l1:     inc cx
        cmp al,al
        JMP SCREEN_SCAN_EGA
END_VID_UPDATE_EGA:
        mov dx,03da
        in al,dx
        mov dl,0ce
        mov ax,0ff08
        out dx,ax
        mov ax,5
        out dx,ax
        mov ax,3
        out dx,ax
        JMP END_VID_UPDATE


vga_emul:
        cld
        mov si,16384
vga_3blocks:
        mov di,si
        mov cx,6144/6
vga_scremul:
        repz cmpsw
        jz vga_attremul
        dec si
        dec si
        mov di,si
        mov ax,0b800
        push ds
        push ax
        lodsw
        stosw
        mov bx,cs:[si+vga_scrn_addrs-16386]
        pop ds
        mov [bx],al
        mov [bx+2],ah
        pop ds
        xor al,al
        jmp vga_scremul
vga_attremul:
        mov cx,768/3
        cmp si,16384+4096
        mov si,22528
        jb vga_attr0
        mov si,22528+256
        jz vga_attr0
        mov si,22528+512
vga_attr0:
        mov di,si
vga_attr:
        repz cmpsb
        jz vga_nextblock
vga_attr2:
        push di
        dec si
        add di,si
        sub di,45057
        mov di,cs:w[di+vga_attr_addrs]
        mov ax,0b800
        push ds
        push ax
        mov bx,offset vga_workspace
atrpokvga equ $-2
        lodsb
        mov es:b[si-1],al
        cs:xlatb
        pop ds
        mov b[di],al
        mov b[di+80],al
        mov b[di+160],al
        mov b[di+240],al
        mov b[di+320],al
        mov b[di+400],al
        mov b[di+480],al
        mov b[di+560],al
        pop ds
        pop di
        cmp al,al
        jmp vga_attr
vga_nextblock:
        jnz vga_attr2
        cmp si,23296
        if z jmp end_vid_update
        cmp si,22528+256
        mov si,16384+2048
        if z jmp vga_3blocks
        mov si,16384+4096
        jmp vga_3blocks


boremul_vga:
        and al,7
        mov ah,al
        mov dx,03da
boremul_overscan:
        in al,dx
        test al,1
        jz boremul_overscan
        mov dl,0c0
        mov al,8
        out dx,al
        mov al,ah
        out dx,al
        mov al,49
        out dx,al
        mov al,ah
        out dx,al
        ret


BOREMUL_CGA:
        MOV CX,0B800
        PUSH CX
        POP ES
        XOR DI,DI
        mov cx,2
        SHR AL,cl
        rcl ch,1
        shr al,1
        rcl ch,1
        mov al,ch
        MOV CL,2
        SHL al,CL
        OR AL,CH
        mov ch,al
        mov cl,4
        SHL CH,CL
        OR AL,CH
        MOV AH,AL
        CLD
        CALL BOR_LOOP_CGA
        MOV DI,02000
BOR_LOOP_CGA:
        MOV CX,4
        REP STOSW
        MOV DL,95
BOR_LOP2_CGA:
        ADD DI,64
        MOV CL,8
        REP STOSW
        DEC DL
        JNZ BOR_LOP2_CGA
        ADD DI,64
        MOV CL,4
        REP STOSW
        RET

BOREMUL_PLANT:
        MOV CX,0B800
        PUSH CX
        POP ES
        MOV DI,CS:ATRADR
        MOV BL,AL
        XOR BH,BH
        ADD BX,BX
        MOV AL,CS:[DI+BX]
        MOV BL,CS:[DI+BX+0300]
        MOV AH,AL
        MOV BH,BL
        XOR DI,DI
        CLD
        CALL BOR_LOOP_plant
        MOV DI,02000
BOR_LOOP_plant:
        mov cx,96
blcp:   stosw
        mov es:[di+04000-2],bx
        stosw
        mov es:[di+04000-2],bx
        stosw
        mov es:[di+04000-2],bx
        stosw
        mov es:[di+04000-2],bx
        add di,64
        stosw
        mov es:[di+04000-2],bx
        stosw
        mov es:[di+04000-2],bx
        stosw
        mov es:[di+04000-2],bx
        stosw
        mov es:[di+04000-2],bx
        loop blcp
        RET

BOREMUL_HERC:
        MOV CX,0B000
        MOV ES,CX
        XOR DI,DI
        SHR AL,1
        mov cx,2
        shr al,1
        rcl ch,1
        shr al,1
        rcl ch,1
        mov al,ch
        SHL CH,CL
        OR AL,CH
        SHL CH,CL
        OR AL,CH
        SHL CH,CL
        OR AL,CH
        MOV AH,AL
        CLD
        MOV CX,855              ;(76/4)*90
        PUSH CX
        PUSH CX
        PUSH CX
        REP STOSW
        POP CX
        MOV DI,02000
        REP STOSW
        POP CX
        MOV DI,04000
        REP STOSW
        POP CX
        MOV DI,06000
        REP STOSW
        MOV DI,06AE
        CALL BOR_LOOP_HERC
        MOV DI,026AE
        CALL BOR_LOOP_HERC
        MOV DI,046AE
        CALL BOR_LOOP_HERC
        MOV DI,066AE
        CALL BOR_LOOP_HERC
        MOV DI,0178E
        MOV CX,1800
        PUSH CX
        PUSH CX
        PUSH CX
        REP STOSW
        POP CX
        MOV DI,0378E
        REP STOSW
        POP CX
        MOV DI,0578E
        REP STOSW
        POP CX
        MOV DI,0778E
        REP STOSW
        RET
BOR_LOOP_HERC:
        MOV CX,6
        REP STOSW
        STOSB
        MOV DL,47
BOR_LOP2_HERC:
        ADD DI,64
        MOV CL,13
        REP STOSW
        DEC DL
        JNZ BOR_LOP2_HERC
        ADD DI,64
        MOV CL,6
        REP STOSW
        STOSB
        RET

BOREMUL_X_HERC:
        MOV CX,0B000
        MOV ES,CX
        XOR DI,DI
        MOV AH,AL
        SHR AL,1
        MOV CH,0
        SHR AL,1
        RCL CH,1
        SHR AL,1
        RCL CH,1
        MOV AL,CH
        MOV CL,2
        SHL CH,CL
        OR AL,CH
        SHL CH,CL
        OR AL,CH
        SHL CH,CL
        OR AL,CH
        INC AH
        TEST AH,2
        PUSHF
        AND AH,6
        CMP AH,4
        MOV AH,AL
        MOV BX,AX
        IF E NOT AX
        POPF
        IF NE XOR AX,01010101010101010XB
        CLD
        CALL BOR_LOOP_X_HERC
        MOV DI,02000
        XCHG AX,BX
        CALL BOR_LOOP_X_HERC
        MOV DI,04000
        XCHG AX,BX
        CALL BOR_LOOP_X_HERC
        MOV DI,06000
        XCHG AX,BX
BOR_LOOP_X_HERC:
        MOV CX,5
        REP STOSW
        MOV DL,95
BOR_LOP2_X_HERC:
        ADD DI,64
        MOV CL,10
        REP STOSW
        DEC DL
        JNZ BOR_LOP2_X_HERC
        ADD DI,64
        MOV CL,5
        REP STOSW
        RET

BOREMUL_EGA:
        and al,07
        push ax
        mov bx,ega_border_palette
        cs:xlatb
        mov ah,al
        pushf
        cli
        mov dx,03da
        in al,dx
        mov dl,0c0
        mov al,031
        out dx,al
        mov al,ah
        out dx,al
        popf
        pop ax
        mov ah,al
        mov al,0
        mov dx,03ce
        out dx,ax               ;set/reset register laden met kleur
        mov ax,0ff08
        out dx,ax               ;alle pixels selecteren
        mov ax,0f01
        out dx,ax               ;enable set/reset reg laden met 0f
        mov ax,5                
        out dx,ax               ;write mode 0
        mov ax,3
        out dx,ax
        MOV DX,0A000
        MOV ES,DX
        CLD
        xor di,di
        mov cx,4*20             ;4 lijnen van 40 bytes
        rep stosw
        MOV CX,192              ;192 LIJNEN
LOOP_LINE:
        STOSW
        STOSW                   ;4 BYTES LINKS, EN ....
        ADD DI,32
        STOSW
        STOSW                   ;...4 BYTES RECHTS.
        LOOP LOOP_LINE
        mov cx,4*20
        rep stosw
        MOV AX,1
        mov dx,03ce
        OUT DX,AX
        MOV AX,0205
        OUT DX,AX               ;RESTORE WRITE MODE 2
        RET


ADDRCONVERT:                    ;Deze routine is nodig omdat de emulattr
        shl cx,1                ;routines uitgaan van een REPZ CMPSB en er
        mov al,b[si+3]          ;vanaf versie 1.40 een REPZ CMPSW gepleegd
        cmp al,es:[di+3]        ;wordt.
        jz aac_lowbyte
        inc si
        inc di
        inc cx
aac_lowbyte:
        inc si
        inc di
        ret


emulattr_plant:
        PUSH SI
        PUSH DI
        PUSH CX
        INC SI
        MOV BX,SI
        MOV CL,4
        SAL BH,CL
        ROR BH,1                ;BX IS NU ADRES IN SPECTRUM-SCHERM
        PUSH BX                 ;BEWAAR POINTER
        MOV AL,BL               ;AL=X COORD
        SHR BX,CL               ;SCHUIF DE Y-COORDINAAT-BITS NAAR BL
        AND BX,0111111110XB     ;BX=2*Y
        MOV BP,CS:[SCREEN_ADDRESSES_CGA+BX]    ;BP IS plant SCREEN-ADDRESS
        SAL AL,1                ;X KEER 2
        AND AX,111110XB         ;ALLEEN DE X-COORDINAAT OVERHOUDEN
        ADD BP,AX               ;BP=plant ADDRESS

NEXT_BYTE_plant:                  ;ENTRY POINT ALS 2 BYTES NAAST ELKAAR VER-
                                ;ANDERD ZIJN.
        MOV BL,[SI]             ;HAAL SPECTRUM ATTR
        MOV ES:[SI],BL
        XOR BH,BH
        SAL BX,1                ;VERM MET 2
        MOV cX,CS:[ATTRp1+BX]   ;HAAL ATTR lo DATA (low=ink)
atrpokb1        equ $-2
        mov dx,cs:[attrp2+bx]   ;haal 2e attr data (hi) (low=ink)
ATRPOKb2        EQU $-2
        POP BX                  ;HAAL SPECTRUM BLD-ADRES TERUG
        mov ah,8
BYTE8LOOP_plant:
                                ;VERANDER plant-BYTE OP BP, MET ATTR DATA
                                ;IN SI/DI EN BLD-ADRES IN BX
        MOV aL,[BX]             ;aL=DATA
        MOV ES:[BX],aL          ;ZET EVT. NIEUWE BYTE IN BUFFER
        inc bh
        push es
        push bx
        push ax
        mov bl,al
        xor bh,bh
        shl bx,1
        MOV BX,CS:[BX+GRAPHIC_TABLE]       ;HAAL GRAFISCHE DATA
        mov ax,bx
        not ax
        push bx
        push ax
        and al,ch
        and ah,ch
        and bl,cl
        and bh,cl
        or bx,ax
        mov ax,0b800
        mov es,ax
        mov es:[bp],bx
        pop ax
        pop bx
        and al,dh
        and ah,dh
        and bl,dl
        and bh,dl
        or ax,bx
        mov es:[bp+04000],ax
        add bp,02000
        cmp bp,04000
        if ae add bp,-04000+80
        pop ax
        pop bx
        pop es
        dec ah
        jnz byte8loop_plant

        POP CX
        POP DI
        POP SI
        TEST CL,31
        JZ RET                  ;RETURN ALS DIT DE LAATSTE ATTR-BYTE WAS VAN
                                ; DEZE REGEL (ZF=1)
        DEC CL
        CMPSB
        jz ret
        ADD BP,0FEBE            ;= 4*-80 -2
        ADD BX,0F7FF
        PUSH SI
        PUSH DI
        PUSH CX
        PUSH BX
        INC SI
        JMP NEXT_BYTE_plant
        RET






EMULSCRN_PLANT:
        PUSH CX
        INC SI                  ;MAAK GOEDE ADRES

        MOV BX,SI               ;BEREKEN SPECTRUM-ATTR ADRES
        MOV CL,3
        SHR BH,CL
        OR BH,050               ;BX IS NU ATTR ADRES
        mov bp,bx               ;bp=attr

        mov bx,si
        MOV CH,BL               ;CH=X
        INC CL
        SHR BX,CL               ;BX 4 NAAR RECHTS
        AND BL,0FE              ;HAAL LAATSTE BIT VAN X WEG. BX IS NU 2*Y+1024
        MOV CL,CH
        SHL CL,1                ;CX=X*2
        AND CX,0111110XB        ;HOU ALLEEN X-BITS OVER (MAAK CH 0)
        MOV BX,CS:[SCREEN_ADDRESSES_MINUS_1024_CGA+BX]
        ADD cx,bX               ;cx IS NU plant ADRES

;De adressen zijn nu berekend; nu worden de waarden opgehaald.

CONTINUE_EMULATING_plant:
        MOV BL,ds:[bp]          ;HAAL ATTR
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        push cx                 ;bewaar plant adres
        MOV AX,CS:[attrp1+BX]   ;HAAL IN AX DE ATTR DATA
ATRPOKc1        EQU $-2
        mov cx,cs:[attrp2+bx]   ;haal in cx de 2e attr data
atrpokc2        equ $-2
        MOV BL,[SI]             ;HAAL DE GRAFISCHE DATA
        MOV ES:[SI],BL          ;ZET GR.DATA IN VIDEO BUFFER
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        MOV DX,CS:[GRAPHIC_TABLE+BX]

        DEC SI                  ;MAAK GOEDE ADRES
        pop bx                  ;haal in bx plant adres
        push es
        push cx                 ;bewaar 2e attr data
        push dx                 ;bewaar grafische data

        MOV CX,DX               ;BEREKEN ATTR/GRAPHIC plant DATA
        NOT CX
        AND CH,Ah
        AND CL,Ah
        AND DH,Al
        AND DL,Al
        OR CX,DX

        MOV AX,0B800
        MOV ES,AX
        MOV ES:[BX],CX

        pop dx
        pop cx
        mov ax,dx
        not ax
        and ah,ch
        and al,ch
        and dh,cl
        and dl,cl
        or ax,dx
        mov es:[bx+04000],ax

        pop es
        POP CX
        TEST CL,31
        JZ RET                ;ERUIT ALS EINDE VD REGEL (OF VID.BUF.)
        DEC CL
        CMPSB
        JZ RET                  ;ERUIT ALS BYTES GELIJK
        PUSH CX
        LEA CX,[BX-2]           ;CX=NIEUW plant-ADRES
        DEC BP                  ;BP=NIEUW ATTR-ADRES
        INC SI
        JMP CONTINUE_EMULATING_plant
        RET



EMULATTR_EGA:
        PUSH SI
        PUSH DI
        PUSH CX
        INC SI
        MOV BX,SI
        MOV CL,4
        SHL BH,CL
        ROR BH,1                ;BX IS NU ADRES IN SPECTRUM-SCHERM
        PUSH BX                 ;BEWAAR POINTER
        MOV AL,BL               ;AL=X COORD
        SHR BX,CL               ;SCHUIF DE Y-COORDINAAT-BITS NAAR BL
        AND BX,0111111110XB     ;BX=2*Y
        MOV BP,CS:[SCREEN_ADDRESSES_EGA+BX]    ;BP IS EGA SCREEN-ADDRESS
        AND AX,11111XB          ;ALLEEN DE X-COORDINAAT OVERHOUDEN
        add ax,4*40             ;4 regels naar beneden (voor border)
        ADD BP,AX               ;BP=EGA ADDRESS

NEXT_BYTE_EGA:                  ;ENTRY POINT ALS 2 BYTES NAAST ELKAAR VER-
                                ;ANDERD ZIJN.
        MOV BL,[SI]             ;HAAL SPECTRUM ATTR
        MOV ES:[SI],BL
        XOR BH,BH
        SAL BX,1                ;VERM MET 2
        MOV CX,CS:[ATTR_TAB_EGA+BX]     ;HAAL ATTR DATA
ATRPOK9 EQU $-2


        POP BX                  ;HAAL SPECTRUM BLD-ADRES TERUG
        MOV DX,03CE
        MOV AH,8
BYTE8LOOP_EGA:
        PUSH AX
                                ;VERANDER EGA-BYTE OP BP, MET ATTR DATA
                                ;IN CX EN BLD-ADRES IN BX
        MOV AX,0FF08            ;Alle bits selecteren
        OUT DX,AX
        MOV AH,[BX]             ;Haal binary image
        MOV ES:[BX],AH          ;ZET IN SHADOW VID BUFFER
        PUSH ES
        MOV DX,0A000
        MOV ES,DX
        mov dl,es:[bp]          ;Latch oude informatie
        mov dx,03ce
        mov ES:[BP],CH
        OUT DX,AX               ;Binary image naar bit mask register
        MOV AL,ES:[BP]          ; (in al zat nog 08) Latch informatie
        MOV ES:[BP],CL
        POP ES
        ADD BP,40               ;VOLGENDE EGA REGEL
        INC BH                  ;VOLGENDE SPECTRUM BEELDLIJN
        POP AX
        DEC AH
        JNZ BYTE8LOOP_EGA

        POP CX
        POP DI
        POP SI
        TEST CL,31
        JZ RET_EGA              ;RETURN ALS DIT DE LAATSTE ATTR-BYTE WAS VAN
                                ; DEZE REGEL (ZF=1)
        DEC CL
        CMPSB
        JZ RET_EGA              ;TERUG ALS VOLGENDE NIET VERANDERD IS (ZF=1)
        ADD BP,-321             ;8*-40 - 1
        ADD BX,0F7FF
        PUSH SI
        PUSH DI
        PUSH CX
        PUSH BX
        INC SI
        JMP NEXT_BYTE_EGA
RET_EGA:
        RET



EMULSCRN_EGA:
        PUSH CX
        PUSH DI
        INC SI                  ;MAAK GOEDE ADRES

        MOV BX,SI               ;BEREKEN SPECTRUM-ATTR ADRES
        MOV CL,3
        SHR BH,CL
        OR BH,050               ;BX IS NU ATTR ADRES
        mov bp,bx               ;bp=attr

        mov bx,si
        MOV CH,BL               ;CH=X
        INC CL
        SHR BX,CL               ;BX 4 NAAR RECHTS
        AND BL,0FE              ;HAAL LAATSTE BIT VAN X WEG. BX IS NU 2*Y+1024
        MOV CL,CH
        AND CX,011111XB         ;HOU ALLEEN X-BITS OVER (MAAK CH 0)
        add cx,4*40             ;4 regels naar beneden (voor border)
        ADD CX,CS:[SCREEN_ADDRESSES_MINUS_1024_EGA+BX]
                                ;CX IS NU EGA ADRES

;De adressen zijn nu berekend; nu worden de waarden opgehaald.

CONTINUE_EMULATING_EGA:
        PUSH CX
        MOV BL,ds:[bp]          ;HAAL ATTR (ZET NIET IN SHADOW BUFFER, WANT
        XOR BH,BH               ; ALS DAT HAD GEHOEVEN, WAS DEZE BYTE AL
                                ; VERVERST DOOR EMUL_ATTR)
        SHL BX,1                ;MAAL 2
        MOV CX,CS:[ATTR_TAB_EGA+BX]     ;HAAL IN CX DE ATTR DATA
ATRPOKA EQU $-2
        POP BX
        MOV Ah,[SI]             ;HAAL DE GRAFISCHE DATA
        MOV ES:[SI],Ah          ;ZET GR.DATA IN VIDEO BUFFER

        DEC SI                  ;MAAK GOEDE ADRES


        PUSH ES
        MOV Al,8
        PUSH AX
        MOV Ah,0ff
        MOV DX,03CE
        OUT DX,AX
        MOV AX,0A000
        MOV ES,AX
        MOV ES:[BX],CH          ;KLEUR PAPER
        POP AX
        OUT DX,AX               ;BITMASK PAPER
        mov al,es:[bx]
        MOV ES:[BX],CL          ;KLEUR INK
        POP ES

        POP DI
        POP CX
        TEST CL,31
        IF Z JMP RET_EGA        ;ERUIT ALS EINDE VD REGEL (OF VID.BUF.)
        DEC CL
        CMPSB
        IF Z JMP RET_EGA        ;ERUIT ALS BYTES GELIJK
        PUSH CX
        PUSH DI
        MOV CX,BX
        DEC CX                  ;CX=NIEUW EGA ADRES
        DEC BP                  ;BP=NIEUW ATTR-ADRES
        INC SI
        JMP CONTINUE_EMULATING_EGA







EMULATTR_CGA:
        PUSH SI
        PUSH DI
        PUSH CX
        INC SI
        MOV BX,SI
        MOV CL,4
        SAL BH,CL
        ROR BH,1                ;BX IS NU ADRES IN SPECTRUM-SCHERM
        PUSH BX                 ;BEWAAR POINTER
        MOV AL,BL               ;AL=X COORD
        SHR BX,CL               ;SCHUIF DE Y-COORDINAAT-BITS NAAR BL
        AND BX,0111111110XB     ;BX=2*Y
        MOV BP,CS:[SCREEN_ADDRESSES_CGA+BX]    ;BP IS CGA SCREEN-ADDRESS
        SAL AL,1                ;X KEER 2
        AND AX,111110XB         ;ALLEEN DE X-COORDINAAT OVERHOUDEN
        ADD BP,AX               ;BP=CGA ADDRESS

NEXT_BYTE_CGA:                  ;ENTRY POINT ALS 2 BYTES NAAST ELKAAR VER-
                                ;ANDERD ZIJN.
        MOV BL,[SI]             ;HAAL SPECTRUM ATTR
        MOV ES:[SI],BL
        XOR BH,BH
        SAL BX,1                ;VERM MET 2
        MOV AX,CS:[ATTR_TAB+BX] ;HAAL ATTR DATA
ATRPOK1 EQU $-2
        MOV BL,AH
        MOV BH,AH
        MOV DI,BX
        MOV AH,AL
        MOV SI,AX               ;SI=PAPER KLEUR, DI=INK


        POP BX                  ;HAAL SPECTRUM BLD-ADRES TERUG
        MOV CX,02000
        MOV DX,0E050            ;DE CONSTANTEN VOOR NEXT CGA ADRES
        MOV AH,8
BYTE8LOOP_CGA:
        PUSH DX
                                ;VERANDER CGA-BYTE OP BP, MET ATTR DATA
                                ;IN SI/DI EN BLD-ADRES IN BX

        PUSH BX                 ;BEWAAR SPECTRUM ADRES
        MOV DL,[BX]             ;BL=DATA
        MOV ES:[BX],DL          ;ZET EVT. NIEUWE BYTE IN BUFFER
        MOV BH,0
        MOV BL,DL
        SHL BX,1                ;BX=BX*2
        MOV BX,CS:[BX+GRAPHIC_TABLE]       ;HAAL GRAFISCHE DATA
        MOV DX,BX
        NOT DX                  ;DX=NOT BX
        AND DX,SI
        AND BX,DI
        OR BX,DX
        PUSH ES
        MOV DX,0B800
        MOV ES,DX
        MOV ES:[BP],BX
        POP ES
        POP BX
        INC BH                  ;VOLGENDE BEELDLIJN

        POP DX                  ;ANDERE VOLGORDE!
        XCHG CX,DX
        ADD BP,DX               ;OM-EN-OM OPTELLEN: 02000 EN 0E050
        DEC AH
        JNZ BYTE8LOOP_CGA

        POP CX
        POP DI
        POP SI
        TEST CL,31
        JZ RET                  ;RETURN ALS DIT DE LAATSTE ATTR-BYTE WAS VAN
                                ; DEZE REGEL (ZF=1)
        DEC CL
        CMPSB
        JZ RET                  ;TERUG ALS VOLGENDE NIET VERANDERD IS (ZF=1)
        ADD BP,0FEBE            ;= 4*-80 -2
        ADD BX,0F7FF
        PUSH SI
        PUSH DI
        PUSH CX
        PUSH BX
        INC SI
        JMP NEXT_BYTE_CGA
        RET



EMULSCRN_CGA:
        PUSH CX
        INC SI                  ;MAAK GOEDE ADRES

        MOV BX,SI               ;BEREKEN SPECTRUM-ATTR ADRES
        MOV CL,3
        SHR BH,CL
        OR BH,050               ;BX IS NU ATTR ADRES
        mov bp,bx               ;bp=attr

        mov bx,si
        MOV CH,BL               ;CH=X
        INC CL
        SHR BX,CL               ;BX 4 NAAR RECHTS
        AND BL,0FE              ;HAAL LAATSTE BIT VAN X WEG. BX IS NU 2*Y+1024
        MOV CL,CH
        SHL CL,1                ;CX=X*2
        AND CX,0111110XB        ;HOU ALLEEN X-BITS OVER (MAAK CH 0)
        MOV BX,CS:[SCREEN_ADDRESSES_MINUS_1024_CGA+BX]
        ADD cx,bX               ;cx IS NU CGA ADRES

;De adressen zijn nu berekend; nu worden de waarden opgehaald.

CONTINUE_EMULATING_CGA:
        MOV BL,ds:[bp]          ;HAAL ATTR
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        MOV AX,CS:[ATTR_TAB+BX] ;HAAL IN AX DE ATTR DATA
ATRPOK2 EQU $-2
        MOV BL,[SI]             ;HAAL DE GRAFISCHE DATA
        MOV ES:[SI],BL          ;ZET GR.DATA IN VIDEO BUFFER
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        MOV DX,CS:[GRAPHIC_TABLE+BX]

        DEC SI                  ;MAAK GOEDE ADRES

        MOV BX,CX               ;BX IS NU CGA ADRES
        MOV CX,DX               ;BEREKEN ATTR/GRAPHIC CGA DATA
        NOT CX
        AND CH,AL
        AND CL,AL
        AND DH,AH
        AND DL,AH
        OR CX,DX

        PUSH ES                 ;ZET DATA OP CGA SCHERM
        MOV AX,0B800
        MOV ES,AX
        MOV ES:[BX],CX
        POP ES
        POP CX
        TEST CL,31
        JZ RET                ;ERUIT ALS EINDE VD REGEL (OF VID.BUF.)
        DEC CL
        CMPSB
        JZ RET                  ;ERUIT ALS BYTES GELIJK
        PUSH CX
        LEA CX,[BX-2]           ;CX=NIEUW CGA-ADRES
        DEC BP                  ;BP=NIEUW ATTR-ADRES
        INC SI
        JMP CONTINUE_EMULATING_CGA
        RET






;Hercules emulatie routines; bijna hetzelfde als de CGA routines, gebruiken
;andere tabel uit TABLES.8 en stellen het zonder snowcheck

EMULATTR_HERC:
        PUSH SI
        PUSH DI
        PUSH CX
        INC SI
        MOV BX,SI
        MOV CL,4
        SAL BH,CL
        ROR BH,1                ;BX IS NU ADRES IN SPECTRUM-SCHERM
        PUSH BX                 ;BEWAAR POINTER
        MOV AL,BL               ;AL=X COORD
        SHR BX,CL               ;SCHUIF DE Y-COORDINAAT-BITS NAAR BL
        AND BX,0111111110XB     ;BX=2*Y
        MOV BP,CS:[SCREEN_ADDRESSES_HERC+BX]    ;BP IS HERC SCREEN-ADDRESS
        SAL AL,1                ;X KEER 2
        AND AX,111110XB         ;ALLEEN DE X-COORDINAAT OVERHOUDEN
        ADD BP,AX               ;BP=CGA ADDRESS

NEXT_BYTE_HERC:                 ;ENTRY POINT ALS 2 BYTES NAAST ELKAAR VER-
                                ;ANDERD ZIJN.
        MOV BL,[SI]             ;HAAL SPECTRUM ATTR
        MOV ES:[SI],BL          ;ZET IN BUFFER
        MOV BH,0
        SAL BX,1                ;VERM MET 2
        MOV AX,CS:[ATTR_TAB+BX] ;HAAL ATTR DATA
ATRPOK3 EQU $-2
        PUSH AX
        MOV AH,AL
        MOV SI,AX               ;SI=PAPER KLEUR
        POP AX
        MOV AL,AH               ;AX=INK
        MOV DI,AX               ;SI=PAP,DI=INK


        POP BX                  ;HAAL SPECTRUM BLD-ADRES TERUG
        MOV AH,8
BYTE8LOOP_HERC:
                                ;VERANDER CGA-BYTE OP BP, MET ATTR DATA
                                ;IN SI/DI EN BLD-ADRES IN BX
        PUSH BX                 ;BEWAAR SPECTRUM ADRES
        MOV DL,[BX]             ;BL=DATA
        MOV ES:[BX],DL          ;ZET EVT. NIEUWE BYTE IN BUFFER
        MOV BH,0
        MOV BL,DL
        SHL BX,1                ;BX=BX*2
        MOV BX,CS:[BX+GRAPHIC_TABLE]       ;HAAL GRAFISCHE DATA
        MOV DX,BX
        NOT DX                  ;DX=NOT BX
        AND DX,SI
        AND BX,DI
        OR BX,DX
        PUSH ES
        MOV CX,0B000
        MOV ES,CX
        MOV ES:[BP],BX
        POP ES
        POP BX
        INC BH                  ;VOLGENDE BEELDLIJN
        ADD BP,02000            ;VOLGENDE HERC BEELDLIJN
        IF S ADD BP,0805A       ;4*-02000 + DEC. 90
        DEC AH
        JNZ BYTE8LOOP_HERC

        POP CX
        POP DI
        POP SI
        TEST CL,31
        JZ RET                  ;RETURN ALS DIT DE LAATSTE ATTR-BYTE WAS VAN
                                ; DEZE REGEL (ZF=1)
        DEC CL
        CMPSB
        JZ RET                  ;TERUG ALS VOLGENDE NIET VERANDERD IS (ZF=1)
        ADD BP,0FF4A            ;= 2*-90 -2
        ADD BX,0F7FF
        PUSH SI
        PUSH DI
        PUSH CX
        PUSH BX
        INC SI
        JMP NEXT_BYTE_HERC
        RET



EMULSCRN_HERC:
        PUSH CX
        INC SI                  ;MAAK GOEDE ADRES

        MOV BX,SI               ;BEREKEN SPECTRUM-ATTR ADRES
        MOV CL,3
        SHR BH,CL
        OR BH,050               ;BX IS NU ATTR ADRES
        mov bp,bx               ;bp=attr

        mov bx,si
        MOV CH,BL               ;CH=X
        INC CL
        SHR BX,CL               ;BX 4 NAAR RECHTS
        AND BL,0FE              ;HAAL LAATSTE BIT VAN X WEG. BX IS NU 2*Y+1024
        MOV CL,CH
        SHL CL,1                ;CX=X*2
        AND CX,0111110XB        ;HOU ALLEEN X-BITS OVER (MAAK CH 0)
        MOV BX,CS:[SCREEN_ADDRESSES_MINUS_1024_HERC+BX]
        ADD cx,bX               ;cx IS NU CGA ADRES

;De adressen zijn nu berekend; nu worden de waarden opgehaald.

CONTINUE_EMULATING_HERC:
        MOV BL,ds:[bp]          ;HAAL ATTR
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        MOV AX,CS:[ATTR_TAB+BX] ;HAAL IN AX DE ATTR DATA
ATRPOK4 EQU $-2
        MOV BL,[SI]             ;HAAL DE GRAFISCHE DATA
        MOV ES:[SI],BL          ;ZET GR.DATA IN VIDEO BUFFER
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        MOV DX,CS:[GRAPHIC_TABLE+BX]

        DEC SI                  ;MAAK GOEDE ADRES

        MOV BX,CX               ;BX IS NU HERC ADRES
        MOV CX,DX               ;BEREKEN ATTR/GRAPHIC CGA DATA
        NOT CX
        AND CH,AL
        AND CL,AL
        AND DH,AH
        AND DL,AH
        OR CX,DX

        PUSH ES                 ;ZET DATA OP HERC SCHERM
        MOV AX,0B000
        MOV ES,AX
        MOV ES:[BX],CX
        POP ES
        POP CX
        TEST CL,31
        JZ RET                  ;ERUIT ALS EINDE VD REGEL (OF VID.BUF.)
        DEC CL
        CMPSB
        JZ RET                  ;ERUIT ALS BYTES GELIJK
        PUSH CX
        LEA CX,[BX-2]           ;CX=NIEUW HERC-ADRES
        DEC BP                  ;BP=NIEUW ATTR-ADRES
        INC SI
        JMP CONTINUE_EMULATING_HERC
        RET




EMULATTR_X_HERC:
        PUSH SI
        PUSH DI
        PUSH CX
        INC SI
        MOV BX,SI
        MOV CL,4
        SAL BH,CL
        ROR BH,1                ;BX IS NU ADRES IN SPECTRUM-SCHERM
        PUSH BX                 ;BEWAAR POINTER
        MOV AL,BL               ;AL=X COORD
        SHR BX,CL               ;SCHUIF DE Y-COORDINAAT-BITS NAAR BL
        AND BX,0111111110XB     ;BX=2*Y
        MOV BP,CS:[SCREEN_ADDRESSES_X_HERC+BX]    ;BP IS HERC SCREEN-ADDRESS
        SAL AL,1                ;X KEER 2
        AND AX,111110XB         ;ALLEEN DE X-COORDINAAT OVERHOUDEN
        ADD BP,AX               ;BP=CGA ADDRESS

NEXT_BYTE_X_HERC:               ;ENTRY POINT ALS 2 BYTES NAAST ELKAAR VER-
                                ;ANDERD ZIJN.
        MOV BL,[SI]             ;HAAL SPECTRUM ATTR
        MOV ES:[SI],BL          ;ZET IN BUFFER
        MOV AL,BL
        XOR BH,BH
        SAL BX,1                ;VERM MET 2
        MOV DX,CS:[ATTR_TAB+BX] ;HAAL ATTR DATA
ATRPOK5 EQU $-2
        MOV BX,OFFSET XLATTAB
        CS:XLATB                ;MAAK ANDERE ATTR, VOOR 2E RIJ
        MOV BL,AL
        XOR BH,BH
        SAL BX,1
        MOV AX,CS:[ATTR_TAB+BX]
ATRPOK6 EQU $-2
        MOV BH,AH
        MOV BL,AH
        MOV DI,BX               ;DI=INK
        MOV AH,AL
        MOV SI,AX               ;SI=PAPER KLEUR


        POP BX                  ;HAAL SPECTRUM BLD-ADRES TERUG
        MOV AH,8
BYTE8LOOP_X_HERC:
                                ;VERANDER CGA-BYTE OP BP, MET ATTR DATA
                                ;IN SI/DI EN BLD-ADRES IN BX
        PUSH BX                 ;BEWAAR SPECTRUM ADRES
        MOV AL,[BX]             ;AL=DATA
        MOV ES:[BX],AL          ;ZET EVT. NIEUWE BYTE IN BUFFER
        MOV BH,0
        MOV BL,AL
        SHL BX,1                ;BX=BX*2
        MOV BX,CS:[BX+GRAPHIC_TABLE]       ;HAAL GRAFISCHE DATA
        PUSH ES
        PUSH BX
        MOV CX,BX
        NOT CX                  ;DX=NOT BX
        AND CX,SI
        AND BX,DI
        OR BX,CX

        MOV CX,0B000
        MOV ES,CX
        POP CX
        MOV ES:[BP],BX
        MOV BL,DH
        MOV BH,DH
        AND BX,CX
        NOT CX
        AND CH,DL
        AND CL,DL
        OR BX,CX
        MOV ES:[BP+02000],BX
        POP ES

        POP BX
        INC BH                  ;VOLGENDE BEELDLIJN
        ADD BP,04000            ;VOLGENDE HERC BEELDLIJN
        IF S ADD BP,08054       ;2*-04000 + DEC. 84
        DEC AH
        JNZ BYTE8LOOP_X_HERC

        POP CX
        POP DI
        POP SI
        TEST CL,31
        JZ RET                  ;RETURN ALS DIT DE LAATSTE ATTR-BYTE WAS VAN
                                ; DEZE REGEL (ZF=1)
        DEC CL
        CMPSB
        JZ RET                  ;TERUG ALS VOLGENDE NIET VERANDERD IS (ZF=1)
        ADD BP,0FEAE            ;= 4*-84 -2
        ADD BX,0F7FF
        PUSH SI
        PUSH DI
        PUSH CX
        PUSH BX
        INC SI
        JMP NEXT_BYTE_X_HERC
        RET



EMULSCRN_X_HERC:
        PUSH CX
        PUSH DI
        INC SI                  ;MAAK GOEDE ADRES

        MOV BX,SI               ;BEREKEN SPECTRUM-ATTR ADRES
        MOV CL,3
        SHR BH,CL
        OR BH,050               ;BX IS NU ATTR ADRES
        mov bp,bx               ;bp=attr

        mov bx,si
        MOV CH,BL               ;CH=X
        INC CL
        SHR BX,CL               ;BX 4 NAAR RECHTS
        AND BL,0FE              ;HAAL LAATSTE BIT VAN X WEG. BX IS NU 2*Y+1024
        MOV CL,CH
        SHL CL,1                ;CX=X*2
        AND CX,0111110XB        ;HOU ALLEEN X-BITS OVER (MAAK CH 0)
        MOV DI,CS:[SCREEN_ADDRESSES_MINUS_1024_X_HERC+BX]
        ADD DI,CX               ;DI IS NU X_HERC ADRES

;De adressen zijn nu berekend; nu worden de waarden opgehaald.

CONTINUE_EMULATING_X_HERC:
        MOV AL,ds:[bp]          ;HAAL ATTR
        XOR AH,AH
        PUSH AX
        MOV BX,OFFSET XLATTAB
        CS:XLATB
        MOV BL,AL
        XOR BH,BH
        SAL BX,1
        MOV DX,CS:[ATTR_TAB+BX]
ATRPOK7 EQU $-2
        POP BX
        SHL BX,1                ;MAAL 2
        MOV AX,CS:[ATTR_TAB+BX] ;HAAL IN AX DE ATTR DATA
ATRPOK8 EQU $-2
        MOV BL,[SI]             ;HAAL DE GRAFISCHE DATA
        MOV ES:[SI],BL          ;ZET GR.DATA IN VIDEO BUFFER
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        PUSH DX                 ;ZET 2E ATTR DATA OP STACK
        MOV DX,CS:[GRAPHIC_TABLE+BX]
        PUSH DX

        DEC SI                  ;MAAK GOEDE ADRES
        MOV CX,DX               ;BEREKEN ATTR/GRAPHIC CGA DATA
        NOT CX
        AND CH,AL
        AND CL,AL
        AND DH,AH
        AND DL,AH
        OR CX,DX
        POP DX                  ;GRAFISCHE DATA
        POP BX                  ;HAAL 2E ATTR DATA TERUG

        PUSH ES                 ;ZET DATA OP HERC SCHERM
        MOV AX,0B000
        MOV ES,AX
        MOV ES:[DI+02000],CX
        MOV CX,DX
        AND CH,BH
        AND CL,BH
        NOT DX
        AND DL,BL
        AND DH,BL
        OR CX,DX
        MOV ES:[DI],CX
        POP ES

        LEA BX,[DI-2]           ;BX IS NIEUW HERC ADR, VOOR LATER
        POP DI
        POP CX
        TEST CL,31
        JZ RET                  ;ERUIT ALS EINDE VD REGEL (OF VID.BUF.)
        DEC CL
        CMPSB
        JZ RET                  ;ERUIT ALS BYTES GELIJK
        PUSH CX
        PUSH DI
        MOV DI,BX
        DEC BP                  ;BP=NIEUW ATTR-ADRES
        INC SI
        JMP CONTINUE_EMULATING_X_HERC
        RET

SAVE_SCREEN:
        PUSHF
        CLD
        PUSH SI
        PUSH DI
        PUSH DS
        PUSH ES
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        CALL GET_PARM
        JC RET
        MOV AH,3
        INT 010
        MOV CS:CURPOSN,DX
        MOV CX,2000
        REP MOVSW
        POP DX
        POP CX
        POP BX
        POP AX
        POP ES
        POP DS
        POP DI
        POP SI
        POPF
        RET

GET_SCREEN:
        PUSHF
        CLD
        PUSH SI
        PUSH DI
        PUSH DS
        PUSH ES
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        CALL GET_PARM
        JC RET
        MOV DX,CS:CURPOSN
        MOV AH,2
        INT 010
        PUSH ES
        PUSH DS
        POP ES
        POP DS
        XCHG SI,DI
        MOV CX,2000
        REP MOVSW
        POP DX
        POP CX
        POP BX
        POP AX
        POP ES
        POP DS
        POP DI
        POP SI
        POPF
        RET

GET_PARM:
        MOV AH,0F
        INT 010
        MOV CX,0B800
        CMP AL,4
        JB GOTIT
        MOV CH,0B0
        CMP AL,7
        JE GOTIT
        STC
        RET
GOTIT:  MOV DH,BH
        CMP AL,2
        IF AE SHL DH,1
        MOV DL,0
        ADD DX,DX
        ADD DX,DX
        ADD DX,DX
        MOV SI,DX
        LES DI,CS:SCRNBUFFER
        MOV DS,CX
        RET

startup ends
                                                                                                                                                                                                              
