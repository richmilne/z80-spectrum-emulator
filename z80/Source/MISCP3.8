;
;   This file is part of the registered Spectrum emulator package 'Z80'
;   version 2.01, and may not be distributed.  You may use this source for
;   other PC based Spectrum or Z80 emulators only after permission.  It is
;   however permitted to use this source file or parts thereof for Spectrum
;   or Z80 emulators on non-PC based machines, provided that the source is
;   acknowledged.
;
;                                                       Gerton Lunter, 3/5/93

startup segment para public

; Routines om het spectrum segment in en uit te pakken

scrunge:
;Komt terug met in CX de totale lengte v.h. gescrungde segment
        push ax
        push bx
        push dx
        push es
        push ds
        cld
        mov ds,cs:specseg
        push ds
        pop es
        mov di,16384
        mov si,16384
        mov cx,49152
        call noblock
        xor al,al
        stosb
        mov al,0ed
        stosb
        stosb
        xor al,al
        stosb
        mov cx,di
        sub ch,64
        pop ds
        pop es
        pop dx
        pop bx
        pop ax
        ret

;
;si wijst naar eerste nog in te lezen karakter
;bl bevat bloklengte (0-255)
;ah bevat blok karakter
;di wijst naar eerste vrije karakter
;cx bevat nog te scrungen bytes
;
scrungeit2:
        cmp bl,255
        jz putblock2
        lodsb
        cmp al,ah
        jnz scr_nogood
        inc bl
        loop scrungeit2
        jmp putblock2
scr_nogood:
        dec si
putblock2:
        cmp ah,0ed
        jnz no_ed2
        cmp bl,2
        jae putblock3
        mov al,ah
        stosb
        jcxz scr_done
        movsb                           ;om ED 00 00 00 00 ... -->
        loop noblock                    ;   ED ED ED nn 00 tegen te gaan.
        jmp scr_done
no_ed2: cmp bl,4
        jbe putnormal
putblock3:
        mov al,0ed
        stosb
        stosb
        mov al,bl
        stosb
        mov al,ah
        stosb
        jcxz scr_done
        jmp noblock
putnormal:
        mov al,ah
putnorm2:
        stosb
        dec bl
        jnz putnorm2
        jcxz scr_done
noblock:                        ;Minimaal 1 over (cx >= 1)
        lodsb
        mov ah,al
        mov bl,1
        loop scrungeit2
        jmp putblock2
scr_done:
        ret




descrungeit:                    ;Out: c=error
        push ax
        push bx
        push cx
        push dx
        push es
        push ds
        cld
        mov ds,cs:specseg
        push ds
        pop es
        mov di,16384+3
        mov cx,49151+3
find_end4:
        dec di
        inc cx
find_end3:
        dec di
        inc cx
find_end2:
        mov al,0
        inc cx
        dec di
find_end:
        repnz scasb
        jnz not_found
        dec cx
        jcxz not_found
        mov al,0ed
        scasb
        jnz find_end2
        dec cx
        jcxz not_found
        scasb
        jnz find_end3
        dec cx
        jcxz not_found
        xor al,al
        scasb
        jnz find_end4
        lea si,[di-5]
        mov di,0ffff
        mov cx,si
        add cx,1-04000
        std
        rep movsb
        cld
        mov si,di
        inc si
        mov di,16384
        mov cx,49152
        call descr_loop
        cmp di,1
        cmc
descr_end:
        pop ds
        pop es
        pop dx
        pop cx
        pop bx
        pop ax
        ret

;In: cld, es:di wijst naar begin outputbuffer, es:ffff is einde, ds:si
;    wijst naar begin inputbuffer, es:ffff is einde, cx is aantal bytes.
;out: c=error
;     di->end of descrunged block
descr_loop:
        cmp si,16384
        jb not_found
        cmp di,16384
        jb not_found
        cmp b[si],0ed
        jz maybe_shiftcode
        movsb
        loop descr_loop
        clc
        ret
maybe_shiftcode:
        cmp b[si+1],0ed
        jz shiftcode
        movsb
        loop descr_loop
        clc
        ret
shiftcode:
        inc si
        inc si
        lodsb
        mov bl,al
        lodsb
descr_putblock2:
        stosb
        dec cx
        jz descr_the_end
        dec bl
        jnz descr_putblock2
        cmp cx,49152
        ja not_found
        inc cx
        loop descr_loop
        clc
        ret
not_found:
        stc
        ret
descr_the_end:
        dec bl
        jnz not_found
        ret                     ;nc:ok



CTRLC:  IRET

CRIT_ERR:
        MOV AL,3
        IRET

TESTCODE:
        DB 018,0,09F,02B,0FE,0,078,02A,0,0,0E5,0E1,0ED,06B,0,0

GET_SPD:CLD
        mov ax,cs:specseg
        MOV ES,AX               ;ES WIJST NAAR SPECTRUM SEGMENT
        MOV DI,04000            ;MAAK SCHERM+RAM LEEG
        MOV CX,0C00             ;0C000 BYTES=48K
        PUSH CS
        POP DS
CR_LOOP:MOV SI,OFFSET TESTCODE
        PUSH CX
        MOV CX,8
        REP MOVSW               ;RAM LEEGMAKEN
        POP CX
        LOOP CR_LOOP
        MOV AX,ES
        MOV DS,AX               ;DS WIJST NAAR SPECTRUM SEGMENT
        MOV W[0FFF0],0C303
        MOV W[0FFF2],04000      ;INC BC/JP 04000
        CALL SAVE_VECTORS       ;BEWAAR TIMER EN KEYBOARD INT VECTORS
        XOR AX,AX
        MOV ES,AX
        MOV CX,AX               ;LD BC,0
        MOV SI,AX               ;FLAG VOOR TIMER2 (REGISTER DE)
        MOV DI,04000            ;PC=04000
        MOV BP,0                ;SP=0
        mov byte cs:timmod,0
        MOV AL,0FF
        OUT 040,AL
        OUT 040,AL
        in al,021
        push ax
        MOV CS:SP2,SP
        mov al,0fe              ;turn off all channels except timer
        out 021,al
        MOV AX,SEG EMULATE
        PUSH AX
        MOV AX,OFFSET EMULATE
        PUSH AX
        CLI
        MOV ES:W[32],TIMER2
        MOV ES:W[34],CS
        MOV AX,CS
        MOV ES,AX
        STI
        RETF
TIMER2: PUSH AX
        MOV AL,020
        OUT 020,AL
        POP AX
        CMP SI,0
        JNZ NO_FIRST_TIME
        MOV CX,0                ;ZET BC (WEER) OP NUL
        MOV SI,DI               ;BEWAAR HUIDIGE WAARDE PC
        IRET
NO_FIRST_TIME:
        MOV SP,CS:SP2           ;RESTORE STACK-POINTER
        STI
        inc byte cs:timmod
        cmp byte cs:timmod,1
        jz tim2ndtime
        cmp byte cs:timmod,2
        jz tim3rdtime
        cmp byte cs:timmod,3
        if z jmp tim4thtime
        NEG CX
        SHR BP,1
        RCR CX,1
        SHR BP,1
        RCR CX,1
        MOV CS:INLOOP,CX
        mov dx,bx
        pop ax
        out 021,al              ;reset all channels to normal values
        JMP GET_VECTORS

tim2ndtime:
        xor bx,bx
        xor ax,ax
timloop2:
        db 28 dup 090           ;32 nops (inc bx/jne takes about 4 nops' time)
        inc bx
        jne timloop2
        inc ax
        jmp timloop2


TIM3rdTIME:
        add bx,bx
        adc ax,ax
        add bx,bx
        adc ax,ax
        add bx,bx
        adc ax,ax
        add bx,bx
        adc ax,ax
        mov bl,bh
        mov bh,al
        test ah
        if nz mov bx,0ffff
        mov cs:bxcst,bx         ;(nops/512)
        MOV BX,CX               ;still holding the result from previous round
        XOR CX,CX
        XOR AX,AX
        NOP
        nop
        nop
        ORG scrunge+(($-scrunge) AND 0FFFC)
TIMLOOP:NOP
        LOOP TIMLOOP
        INC AX
        LOOP TIMLOOP


tim4thtime:
        NEG CX
        SHR AX,1
        RCR CX,1
        SHR AX,1
        RCR CX,1
        SHR AX,1
        RCR CX,1
        SHR AX,1
        RCR CX,1
        MOV CS:CXLOOP,CX
        XOR CX,CX
        MOV DX,0378
        XOR BP,BP
        NOP
        nop
        nop
        ORG scrunge+(($-scrunge) AND 0FFFC)
LDSAMPLETIMER:
        test byte cs:keyscan,0
        jNz LDSAMPLETIMER
        in al,dx
        xor al,AL
        add al,al
        jc LDSAMPLETIMER
        loop ldsampleTIMER
        INC BP
        LOOP LDSAMPLETIMER




PRINT_DIGIT:
        MOV CL,'0'-1
PRDLOOP:
        INC CL
        SUB AX,BX
        JAE PRDLOOP
        ADD AX,BX
        CMP CL,'0'
        JNZ NIETNUL
        CMP CH,0
        JZ RET
NIETNUL:MOV CH,1
        PUSH AX
        PUSH CX
        MOV DL,CL
        MOV AH,2
        INT 021
        POP CX
        POP AX
        RET



IMMEDIATE_NMI:                  ;This is the routine associated with -sn.
        CMP BYTE CS:IMMNMI,0    ;Just before the emulator starts, it
        JZ RET                  ;generates an NMI.
        MOV BYTE CS:IMMNMI,0
        PUSH AX
        CALL FAR RESET_ALL_FAR
        POP AX
        DEC BP
        DEC BP
        TEST BP,0C000
        IF NZ MOV DS:[BP],DI
        MOV DI,066
        RET

LDIR_INST:
        PUSH DS
        PUSH ES
        PUSH SI
        PUSH DI
        PUSH CX
        TEST byte cs:mflag,2
        JZ LDIR_FAST
        MOV SI,LDIR2
        MOV CX,LDIR2_LEN
        PUSH SI
        PUSH CX
        MOV SI,LDDR2
        MOV CX,LDDR2_LEN
        JMP LDIR_LDIR
LDIR_FAST:
        MOV SI,LDIR1
        MOV CX,LDIR1_LEN
        PUSH SI
        PUSH CX
        MOV SI,LDDR1
        MOV CX,LDDR1_LEN
LDIR_LDIR:
        MOV ES,SEG EMULATE
        PUSH CS
        POP DS
        MOV DI,OFFSET EDOPB8
        mov ax,21
        call movecommand
        POP CX
        POP SI
        MOV DI,OFFSET EDOPB0
        mov ax,21
        call movecommand
        MOV SI,LDIR2
        MOV CX,LDIR2_LEN
        MOV DI,OFFSET EDOPB0+0100
        mov ax,21
        call movecommand
        MOV SI,LDDR2
        MOV CX,LDDR2_LEN
        MOV DI,OFFSET EDOPB8+0100
        mov ax,21
        call movecommand
        POP CX
        POP DI
        POP SI
        POP ES
        POP DS
        RET

LDIR1:
        TEST SI,0C000
        IF Z JMP LDIR1+0100
        DEC CX
        ADD SI,CX
        SUB SI,CX
        INC CX
        IF C JMP LDIR1+0100
        PUSH ES
        PUSH DS
        POP ES
        XCHG DI,DX
        XCHG SI,DI
        CLD
        REP MOVSB
        POP ES
        XCHG SI,DI
        XCHG DI,DX
        AND AH,011101001XB
        XOR BL,BL
        MOV BH,[DI]
        JMP BX
        db 5 dup 090
LDIR1_LEN       EQU $-LDIR1

LDIR2:
        XCHG BX,DX
        PUSH AX
;        sub es:byte[rr],2
;LDIR_NEXT_BYTE:
;        add es:byte[rr],2
        MOV AH,[BX]
        TEST SI,0C000
        IF NZ MOV [SI],AH
        INC BX
        INC SI
        POP AX
        XCHG DX,BX
        XOR BL,BL
        DEC CX
        JZ SHORT LDIR_END
;        CMP W[DI-2],0B0ED              ;This slight speedup causes difficulties
;        JZ LDIR_NEXT_BYTE              ;in TIMER, and -l isn't needed much anyway
        DEC DI
        DEC DI
        OR AH,4
        MOV BH,[DI]
        JMP BX
        db 5 dup 090
LDIR_END:
        AND AH,011101001XB
        MOV BH,[DI]
        JMP BX
        db 5 dup 090
LDIR2_LEN        EQU $-LDIR2

LDDR1:
        TEST SI,0C000
        IF Z JMP LDDR1+0100
        PUSH CX
        ADD CX,03FFF
        SUB SI,CX
        ADD SI,CX
        POP CX
        IF C JMP LDDR1+0100
        PUSH ES
        PUSH DS
        POP ES
        XCHG DI,DX
        XCHG SI,DI
        STD
        REP MOVSB
        POP ES
        XCHG SI,DI
        XCHG DI,DX
        AND AH,011101001XB
        XOR BL,BL
        MOV BH,[DI]
        JMP BX
        db 5 dup 090
LDDR1_LEN        EQU $-LDDR1

LDDR2:
        XCHG BX,DX
        PUSH AX
;        sub es:b[rr],2
;LDDR_NEXT_BYTE:
;        add es:b[rr],2
        MOV AH,[BX]
        TEST SI,0C000
        IF NZ MOV [SI],AH
        DEC BX
        DEC SI
        POP AX
        XCHG DX,BX
        XOR BL,BL
        DEC CX
        JZ LDDR_END
;        CMP W[DI-2],0B8ED
;        JZ LDDR_NEXT_BYTE
        DEC DI
        DEC DI
        OR AH,4
        MOV BH,[DI]
        JMP BX
        db 5 dup 090
LDDR_END:
        AND AH,011101001XB
        MOV BH,[DI]
        JMP BX
        db 5 dup 090
LDDR2_LEN       EQU $-LDDR2





END_SPECTR:
        CLI
        MOV AL,020
        OUT 020,AL
        MOV AL,0FF
        OUT 040,AL
        NOP
        NOP
        OUT 040,AL
        IN AL,061
        AND AL,011111100XB
        OUT 061,AL              ;EVT. PIEP UIT
        MOV AX,CS
        MOV DS,AX
        call close_tapefiles
        CALL UNINSTALL_COM
        CALL FLUSHOUTPUT
        CALL CLEARINPUT
        CALL GET_VECTORS
        call mdrv_closeall
        mov dx,cs:emshandle
        mov ah,045
        test dx,dx
        if nz int 067           ;deallocate ems memory
        STI
        call text_mode
        mov bx,cs:romhandle
        mov ah,03e
        test bx,bx
        if nz int 021
        mov bx,cs:xrhandle
        mov ah,03e
        test bx,bx
        if nz int 021
        mov dx,endmes
        mov ah,9
        int 021
        MOV AX,04C00            ;terminate met exit code 00
        INT 021



intro:
        push cs
        pop ds
        mov ax,w[offset specseg]
        mov es,ax
        mov di,16384
        mov ax,seg introscr
        sub ax,0400
        mov ds,ax
        mov si,offset introscr+04000
        cld
        mov cx,6912
        call descr_loop
        push cs
        pop ds
        mov byte vid_act,0ff
        mov byte borclr,4
        mov byte newbor,0
        push es
        pop ds
        call video_update
        mov cx,7
iwaitl: push cx
        mov ah,02c
        int 021
        mov al,dh
iwait:  push ax
        mov ah,0b
        int 021
        and al,al
        jnz key_pressed
        mov ah,02c
        int 021
        pop ax
        cmp al,dh
        jz iwait
        pop cx
        loop iwaitl
        jmp intro_exit
key_pressed:
        pop ax
        pop ax
intro_exit:
        ret



segviolation:                           ;PUSH/POP use MOV BX,DS:[BP]
                                        ;If BP=0ffff, it generates an
        cmp bp,0ffff                    ;interrupt. This routine makes
        jnz notmine                     ;sure the Z80 opcode is emulated
        mov bp,sp                       ;correctly.
        cmp w[bp+2],seg emulate         ;All this won't work with QEMM installed
        jnz notmine_bp
        push ax
        push di
        mov di,bx                       ;temporary storage
        mov ax,w[bp]
        xor ah,193
        test ah,203                     ;push / pop?
        jnz seg_return
        test ah,4                       ;if push, jump forward
        jnz seg_dopushlater
        mov bl,[0ffff]                  ;get the popped value
        mov bh,[0]
seg_dopushlater:
        call seg_xchgregs               ;xchg bx <-> z80 register
        test ah,4
        jz seg_return                   ;if pop, we're done
        mov [0ffff],bl                  ;if push, now push and
        call seg_xchgregs               ;restore z80 register
seg_return:
        mov ax,[bp]
        add ax,4                        ;step over problematic instruction
        mov [bp],ax
        mov bx,di
        pop di
        pop ax
        mov bp,0ffff
        iret
notmine_bp:
        mov bp,0ffff
notmine:
        jmp far cs:d[offset segvioladr]

seg_xchgregs:
        test ah,16
        jnz seg_deoraf
        test ah,32
        jnz seg_hl
        xchg bx,cx
        ret
seg_hl:
        cmp al,04d
        if b xchg bx,dx
        if ae xchg bx,di
        ret
seg_deoraf:
        test ah,32
        jnz seg_af
        xchg bx,si
        ret
seg_af:
        xchg bx,[bp-2]
        ret

adlib_write:                 ;writes value ah to register al
        push cx
        push dx
        mov dx,0388
        out dx,al
        in al,dx
        in al,dx
        in al,dx
        in al,dx
        in al,dx
        in al,dx
        mov al,ah
        inc dx
        out dx,al
        pop dx
        pop cx
        ret

adlib_writep:
        call adlib_write
adlib_pause:
        push ax
        push dx
        push cx
        mov dx,0388
        mov cx,35
adlib_wait2:
        in al,dx
        loop adlib_wait2
        pop cx
        pop dx
        pop ax
        ret


cms_write:                      ;writes value ah to register al
        push dx
        mov dx,0221
        out dx,al
        xchg ah,al
        dec dx
        out dx,al
        xchg ah,al
        pop dx
        ret


adlib_init:
        cmp byte cs:adlib,0ff
        jnz ret
        mov ax,06004
        call adlib_writep
        mov ax,08004
        call adlib_writep
        mov dx,0388
        in al,dx
        push ax
        mov ax,0ff02
        call adlib_writep
        mov ax,02104
        call adlib_writep
        mov cx,200
l1:     in al,dx
        loop l1
        push ax
        mov ax,04
        call adlib_writep
        pop ax
        and al,0e0
        cmp al,0c0
        pop ax
        if nz jmp adlib_notok
        and al,0e0
        if nz jmp adlib_notok
        mov byte cs:intsnd,0    ;disable internal speaker '128 sound
        mov byte cs:s_oldctrl,0ff
        mov ax,0
l1:     push ax
        call adlib_writep
        pop ax
        inc al
        jnz l1
        mov ax,02001
        call adlib_writep        ;enable distorted waveforms
        mov al,020
        mov cx,6                ;three carriers and modulators
l1:     push ax
        mov ah,021              ;frequency multiple 1, normal sustain
        call adlib_writep
        pop ax
        push ax
        mov ah,1                ;distorted sine wave
        add al,0c0
        call adlib_writep
        pop ax
        push ax
        mov ah,0ff              ;ff
        add al,040
        call adlib_writep       ;quick attack, no decay
        pop ax
        push ax
        mov ah,00f
        add al,060
        call adlib_writep       ;(sustain: loud, release: quick)
        pop ax
        inc al
        loop l1
        mov al,0
        mov cx,3                ;3 modulator/carrier operators
l1:     push ax
        mov ah,0
        add al,0c0              ;F.M. synthesis, no feedback
        call adlib_writep
        pop ax
        push ax
        mov ah,010               ;Modulator total level about 40 db
        add al,040
        call adlib_writep
        pop ax
        inc al
        loop l1
        cmp byte cs:cmschips,0ff
        jz usecms
        mov ax,02134            ;snare drum: normal envelope, multi=1
        call adlib_writep
        mov ax,0f074            ;quick attack, no decay
        call adlib_writep
        mov ax,0f94             ;(max sustain, quick release)
        call adlib_writep
        mov ax,028bd            ;turn on snare drum
        call adlib_writep
        call adlib_quiet
        mov dx,adlib_msg
        jmp >l1
usecms:
        mov ax,0                ;channel 0 amp 0
        call cms_write
        mov ax,014              ;disable tone all channels
        call cms_write
        mov ax,0115
        call cms_write          ;disable noise all channels but channel 0
        mov ax,0ff16
        call cms_write          ;highest available noise frequency
        mov ax,011c
        call cms_write          ;sound enable
        mov dx,adlib_msg
        jmp >l1
adlib_notok:
        mov byte cs:adlib,0
        mov dx,noadlib_msg
l1:     push ds
        push cs
        pop ds
        mov ah,9
        int 021
        pop ds
        ret




queer2_ems:
        push es
        push ax
        cmp byte cs:sambank,1   ;samrom 1 active?
        jz q2_active
        push cx
        push dx
        push si
        push di
        mov ax,04400            ;phys. page 0 (rom)
        mov bx,2                ;samrom 1
        mov dx,cs:emshandle
        int 067
        mov ax,cs:samseg
        mov es,ax
        xor si,si
        xor di,di
        mov cx,02000
        cld
        rep movsw
        mov ax,04400
        mov bl,cs:[offset ramstate]
        xor bh,bh
        int 067
        pop di
        pop si
        pop dx
        pop cx
        mov byte cs:sambank,1
q2_active:
        mov ax,cs:samseg
        mov es,ax
        cmp si,04000
        pop ax
        ja $+1
        es:
        mov al,[si]
        pop es
        mov bx,dx
        cmp bh,040
        if ae mov [bx],al
        xchg bx,si
        inc bl
        xchg bx,si
        inc dh
        jmp far emulate

ldobhla_ems:
        push dx
        push ax
        mov dx,cs:emshandle
        mov bl,cs:[offset ramstate+2]   ;4 or 6
        xor bl,2                        ;other 32k bank
        xor bh,bh
        mov ax,04402
        int 067
        inc bl
        mov ax,04403
        int 067
        pop ax
        pop bx
        cmp bh,040
        if ae mov [bx],al
        push bx
        push ax
        mov bl,cs:[offset ramstate+2]
        xor bh,bh
        mov ax,04402
        int 067
        inc bl
        mov ax,04403
        int 067
        pop ax
        pop dx
        jmp far emulate

ldobahl_ems:
        push dx
        push ax
        mov dx,cs:emshandle
        mov bl,cs:[offset ramstate+2]   ;4 or 6
        xor bl,2                        ;other 32k bank
        xor bh,bh
        mov ax,04402
        int 067
        inc bl
        mov ax,04403
        int 067
        pop ax
        pop bx
        mov al,[bx]
        push bx
        push ax
        mov bl,cs:[offset ramstate+2]
        xor bh,bh
        mov ax,04402
        int 067
        inc bl
        mov ax,04403
        int 067
        pop ax
        pop dx
        jmp far emulate




JOYSTICK_UPDATE:
        test byte cs:zandjoy,0ff
        jz upd_no_zandbergen
        mov dx,0201
        in al,dx
        out dx,al
        xor al,16
        and al,31
        mov bl,al
        shr bl,1
        xor bl,al
        test bl,1
        if nz xor al,3
        mov bl,al
        jmp short j_upd_algemeen
        ret
upd_no_zandbergen:
        mov cx,cs:joytel
        test cx
        jz ret
        push dx
        push si
        push di
        shr cx,1
        add cx,cs:joytel
        push cx
        call meetjoystick
        pop cx
        add si,cs:joytelsi
        sub si,cx
        add di,cs:joyteldi
        sub di,cx
        in al,dx
        and al,16
        xor al,16
        mov bl,al
        mov ax,cs:joytelsi
        shl ax,1
        xor dx,dx
        mov cx,5
        div cx
        test si,si
        js sineg
        cmp si,ax
        if a or bl,1
        jmp short sidone
sineg:  neg si
        cmp si,ax
        if a or bl,2
sidone: mov ax,cs:joyteldi
        shl ax,1
        xor dx,dx
        div cx
        test di,di
        js dineg
        cmp di,ax
        if a or bl,8
        jmp short didone
dineg:  neg di
        cmp di,ax
        if a or bl,4
didone: mov al,bl
j_upd_algemeen:
        xor al,cs:joyxy
        mov cs:joyxy,bl
        jz j_upd_end
        mov cl,0
j_upd_loop:
        clc
        rcr bl,1
        sbb ah,ah
        not ah
        clc
        rcr al,1
        jnc j_zelfde
        push bx
        push cx
        xchg byte cs:break,ah
        push ax
        mov al,cl
        call set_joystick
        pop ax
        xchg byte cs:break,ah
        pop cx
        pop bx
j_zelfde:
        inc cl
        test al,al
        jnz j_upd_loop
        call matrix_error
j_upd_end:
        pop di
        pop si
        pop dx
        ret



meetjoystick:
        mov dx,0201
        out dx,al
        mov si,0
        mov di,0
        mov ah,3
        cli
j_get_pos:
        in al,dx
        not al
        and al,ah
        jz j_nochange
        test al,1
        jz j_noxpos
        mov si,cx               ;xpos
        and ah,2
j_noxpos:
        test al,2
        jz j_nochange
        mov di,cx               ;ypos
        and ah,1
j_nochange:
        loop j_get_pos
        sti
        ret


INITJOYSTICK:
        mov word cs:joytel,0
        cmp byte cs:zandjoy,0ff
        jne ret                 ;Return als opties -kk of -kz gegeven zijn.
        mov dx,0201
        out dx,al
        mov cx,0
initjoypauze:
        loop initjoypauze
        in al,dx
        and al,0e0
        cmp al,060
        jnz no_zandbergen       ;Geen Ruud Zandbergen joystick
        mov byte cs:zandjoy,1
        mov dx,zandjoymes
        jmp print
no_zandbergen:
        mov byte cs:zandjoy,0
        mov cx,30000
        call meetjoystick
        xor ax,ax
        cmp si,ax
        jz nojoystick
        cmp di,ax
        jz nojoystick
        mov ax,30000
        sub ax,si
        mov cs:joytelsi,ax
        mov ax,30000
        sub ax,di
        mov cs:joyteldi,ax
        mov ax,30000
        cmp si,di
        if a mov si,di
        sub ax,si
nojoystick:
        mov cs:joytel,ax
        mov dx,normjoymes
        if z mov dx,nojoymes
        jmp print



startup ends

