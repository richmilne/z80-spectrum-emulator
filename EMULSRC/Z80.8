;
;   This file is part of the registered Spectrum emulator package 'Z80'
;   version 2.01, and may not be distributed.  You may use this source for
;   other PC based Spectrum or Z80 emulators only after permission.  It is
;   however permitted to use this source file or parts thereof for Spectrum
;   or Z80 emulators on non-PC based machines, provided that the source is
;   acknowledged.
;
;                                                       Gerton Lunter, 3/5/93

startup segment para public

;zx spectrum 48k/128k emulator
;
;eerste regel geschreven op 11 november 1988, kwart over vijf.

;**********************************************************************
;EERST WORDT EEN STACK SEGMENT GEDEFINIEERD
;**********************************************************************

STACK_SIZE      EQU 0200        ;WOORDEN

STACK SEGMENT PARA STACK

        DB STACK_SIZE/3 DUP "STACK!"

STACK ENDS

;There should be EXACTLY 24 bytes before the header block - the symbols
;RIX and RIY are referenced by value (031 and 02F) in dd.8

IN_TAB:         DB 8 DUP ?
IN2_TAB:        DB 8 DUP ?
IN31TAB:        DB 8 DUP ?

;The following 30 bytes constitute the header of a .Z80 file

RFA     DW ?                    ;REVERSED AF REGISTER
RBC     DW ?                    ;BC REG.PAAR
RHL     DW ?                    ;HL REG.PAAR
RPC     DW ?                    ;PROGRAM COUNTER (0 if version >= 2.0)
RSP     DW ?                    ;STACK POINTER
RI      DB ?                    ;I REGISTER
RR      DB ?                    ;R REGISTER
RR_BIT7 DB ?                    ;BIT 7 V.H. R REGISTER
                                ;OP DISK: BIT 0=RR_BIT7, BIT 1-3=BORDER,
                                ;BIT 4=1 ALS SAMROM INGESCHAKELD, 5=data shrunk
RDE     DW ?                    ;DE
RBCA    DW ?                    ;BX'
RDEA    DW ?                    ;DE'
RHLA    DW ?                    ;HL'
RAFA    DW ?                    ;AF' (REVERSED, EIGENLIJK FA')
RIY     DW ?                    ;IY
RIX     DW ?                    ;IX
IFF     DB ?                    ;INTERRUPT FLIPFLOP, 0=DI
IFF2    DB ?                    ;IFF2 WORDT GEBRUIKT BIJ NMI
IMODE   DB ?                    ;INTERRUPT MODE (bits 0-1). 2:Issue2, 3:Dub.Irpt
                                ;4-5: Vid.sync.mode, 6-7:Joystick interface

;The next 25 bytes are saved in version 2.0 Z80 files

LENGTH  DW 23                   ;length of additional info block
RPC2    DW ?                    ;Program counter for version >= 2.0
ROMMOD  DB ?                    ;Emulator mode: 0=norm,1=if1,2=sam,3=128,4=3+1
HSTATE  DB ?                    ;If in Samram mode, bitwise state of 74ls259
                                ;If in 128 mode, last OUT to 7ffd
IF1FLG  DB ?                    ;0FF if if1 rom paged in
MFLAG   DB ?                    ;bit 0=1: r register emulated
                                ;bit 1=1: ldir emulated
SREG    DB ?                    ;Last out to fffd (soundchip register number)
SSTATE  DB 16 dup ?             ;Sixteen sound chip registers

;Header of memory block

MLENGTH DW ?                    ;Length of data block (without header)
MPAGE   DB ?                    ;Page number of datablock

lastfffd db ?                   ;last out to fffd (sound chip reg no)
s_oldctrl db ?                  ;old value of control register
envaddlo dw ?                   ;determines freq. of envelope
envaddhi dw ?
envnumlo dw ?                   ;counter for envelope emulation
envcur   db ?                   ;current value of envelope
envadd   db ?                   ;0,1 or ff
env2nd   db ?                   ;value of envelope at start of next period
env2add  db ?
envtog   db ?                   ;0ff if envelope toggles
TEMP_PC DW ?                    ;To store the PC when crashing at an IN 0
TEMP_F  DB ?                    ;Inofficial flag emulation
temp_fa db ?
NMI     DB ?                    ;0FF ALS NMI IPV INTR
BREAK   DB ?
E0FLAG  DB ?
NUMLCK  DB ?
KSTATE  DW ?
azerty  db 0                    ;0ff if using azerty keyboard
SHIFTSTATE      DB ?
SHFTSTATES      DB 35 DUP ?     ;SHIFTSTATES MULTI-KEY TOETSEN BIJ INDRUKKEN
LASTKEY DB ?
SPCTEL  DB ?
KEMPSTON_STATE  DB ?            ;STATUS KEMPSTON-JOYSTICK
tstates dw 0
INTEL   DB ?
INTEL2  DW ?
INTEL3  DW ?
R_RND   DW ?
QFLAG   DB ?
ATRSCR  DW ?
RFSHFLG DB ?
VIDRFSH DB ?
VIERTEL DB ?
FLSHCNT DB ?
ATRFLSH DW ?
MODE    DB ?                    ;VOOR INITHERC
TTYPE   DB ?                    ;VOOR PLANTRONICS EMULATIE
ATRADR  DW ?                    ;ADRES ATTR DATA PLANTRONICS (COLOR<->GREY)
MODEPD  DB ?                    ;0FF ALS MODE GEPRINT: ZIE VIDEO.8
CURPOSN DW ?
VALUE   DW ?
REGIST  DB 0
C_ACTIVE        DB ?
C_ACTION_CODE   DB ?

IF1_ON  DB ?                    ;0ff if IF1 AKTIEF
DOUBLE  DB ?                    ;" DUBB. IRUPT SNELHEID
FLASH   DB ?                    ;" FLASH EMULATIE
HERCFLG DB ?                    ;" HERCULES
XTDHERC DB ?                    ;" XTD HERC
CGA     DB ?                    ;" CGA
EGA     DB ?                    ;" EGA
VGA     DB ?                    ;" VGA
trivga  db ?                    ;" 400-line VGA
greyvga db ?                    ;" black/white VGA
PLANTR  DB ?                    ;" PLANTR
SILENCE DB ?                    ;" STILLE SPECTRUM
cmschips db ?                   ;" CM/S chips used
intsnd  db ?                    ;" internal speaker for 128 sound
ISSUE2  DB ?                    ;" ISSUE 2 GEEMULEERD
IMMNMI  DB ?                    ;" IMMEDIATE NMI AFTER LOADING .Z80 FILE
winkey  db ?                    ;" reading keys from INT 10 etc for windows comp'ty.
curs128 db ?                    ;" using shifted cursor keys in '128 mode by def.
ADLIB   db 0ff
GMOD    DB ?                    ;0=CGA, 1=HERC, 2=XTD HERC, 3=PLANTR, 4=ega, 5=vga
VGASCAN DB ?                    ;0,1,2,3: 200, 350, 400, 480 scanlines
EGAPAL  DB ?                    ;1 ALS EGA MET ALTERNATIEF PALET
IF1SW   DB ?                    ;0FF ALS 16K IF1 BANKSWITCH
EXPMEM  DB ?                    ;0FF IF EMULATOR SHOULD TRY TO USE EXPANDED MEM
JOYMODE DB ?                    ;0=cursor/protek/agf, 1=kempston, 2,3=sinclr1,2
SYNCMOD DB ?                    ;1=HOOG, 2=NORMAAL, 3=LAGE VID SYNCHRONISATIE
CXLOOP  DW ?                    ;CX-WAARDE VOOR EEN PAUZE VAN 1/18.2x16 s
INLOOP  DW ?                    ;CX-WAARDE VOOR LD_EDGE LOOP VAN 1/18.2x4 s
bxcst   dw ?                    ;timing constant for emulator slowdown
timmod  db ?                    ;temporary var.
        dw 0                    ;used by movecommand
slowmod dw 20 dup ?             ;4T-23T: 0=-, 1=jmp, 2...=nops
RELSPD0 DW ?                    ;MAXIMALE REL. SNELH. IN PROMILLES
debugflg db ?                   ;0 if not debugging (see option -xd)
debugadr dw ?                   ;trapping at address debugadr
JOYTEL  DW ?                    ;MACHAFH. STRTW JYSTK UITLEESRTINE (0=geen jstk)
JOYTELSI DW ?
JOYTELDI DW ?
ZANDJOY DB ?                    ;0 ALS GEEN ZANDBERGEN JOYSTICK
JOYXY   DB ?
MAXTEL  DB ?
ADDNUM  DW ?
TIMNUM  DW ?
TIMADR  DW ?
TIMSEG  DW ?
KBDADR  DW ?
KBDSEG  DW ?
CTRLBRKADR      DW ?
CTRLBRKSEG      DW ?
COM1ADR DW ?
COM1SEG DW ?
COM2ADR DW ?
COM2SEG DW ?
SEGVIOLADR DW ?
SEGVIOLSEG DW ?
INTTEL  DB ?
SP2     DW ?
TIMFLAG DB ?
VID_ACT DB ?
BORCLR  DB ?
NEWBOR  DB ?
MODFLG  DB ?                    ;0=normaal, 1,2=real mode
KEYSCAN DB ?                    ;B0:SCAN KEYS B1:KEY SCANNED
TAPEIF  DB ?                    ;N=LPTN ALS TAPEINTERFACE
TAPEIO  DW ?                    ;TAPE BASE IO ADDRESS
ISSUE2DEFAULT DB ?              ;STANDAARD UITLEZING LPT POORT
WORKSP  DB ?
ACTIVE_ROM      DW ?
ACTROM2         DW ?
ramstate        db 4 dup 0fe    ;active pages
VIDBUFSEG       DW ?
OLD_MODE        DB ?            ;OUDE VIDEO MODE
TRAPADR         DW ?
TRAPSEG         DW ?
oldint3a        dw ?
oldint3s        dw ?
SCRNBUFFER      DD ?            ;POINTER NAAR 4096 SCHERM BUFFER (ZIE VIDEO.8)
PROGSEG         DW ?            ;STARTSEGMENT PROGRAMMA (IN DS, BIJ BEGIN)
SPECSEG         DW ?            ;SEGMENT VAN SPECTRUM GEHEUGEN
ROMSEG          DW ?            ;SEGMENT ROM AREA
samseg          dw ?            ;segment samram speedup buffer (16K)
sambank         db ?            ;bank currently active in samram spdup bufr
romhandle       dw 0            ;handle roms.bin
xrhandle        dw 0            ;handle extra rom from option -xr
emshandle       dw 0            ;handle lim ems driver

RS_IN   DW ?                    ;RS232 INPUT WORKSPACE
RS_OUT  DW ?                    ;RS232 OUTPUT WORKSPACE
DTR     DB ?
CTS     DB ?
cts128  db ?
OUTMODE DB ?                    ;0=NIETS, 1=LPTN, 2=COMN, 3=DISK
OUTNUM  DW ?                    ;N ALS OUTMODE=1 OF 2, HANDLE ALS OUTMODE=3
INMODE  DB ?                    ;0=NIETS, 2=COMN, 3=DISK
INNUM   DW ?
RSCOUNT DW ?                    ;TELLER AANTAL GELEZEN BYTES
RSOUTCOUNT DW ?                 ;TELLER AANTAL GESCHREVEN BYTES
PUTOUT  DW ?                    ;OUTPUT BUFFER PUT-POINTER
GETOUT  DW ?                    ;O GET
PUTIN   DW ?                    ;I PUT
GETIN   DW ?                    ;I GET
COMSDAT DB 0                    ;signals from if1 out-port EF
wkbd_count db 0                 ;1/18.2 tick counter for key release
wkbd_lastscan db 0              ;latest pressed key
wkbd_shift db 0                 ;current shift & sym_shft states
comsclk db 0ff                  ;comms clk
readwrt db 0ff                  ;read / NOT write
erase   db 0ff                  ;NOT erase
motors  db 0                    ;bit 0=1: mdrv 1 active, etc.
mhandles dw 8 dup 0             ;8 handles of cartridge files
writprot db 8 dup 0             ;0: cartridge not write-protected
mdrvwritprot db 0ff             ;current cartridge write protected
mdrvpointer dw 0                ;pointer in mdrv buffer
mdrvgap db 0                    ;<>0 if current block is a GAP block
mdrvheader db 0                 ;reading/writing a header or a datablock
mdrvblock db 0                  ;own counter of mdrv block
gapcnt dw 0                     ;counts off the duration of GAPs
old_if1ctrl db 0                ;last EF write value
mdrv_counter db 0               ;see TIMER. If =5 and ERASE, then make GAP
dataread db 0                   ;0ff if the mdrv buffer is INIRed from
datawritten db 0                ;0ff if the mdrv buffer is OTIRed to
mdrvhandle dw 0                 ;Handle of current cartridge, 0 if none.
mdrvseg dw 0                    ;segment of +/- 16K cartridge buffer
mdrvbufchanged db 0
mdrvbufhandle dw 0
mdrvbufblock db 0
COMPORT DW ?                    ;BASE PORT ADDRESS COMN
CHECKSUM DW ?

ROMADR          DW 0            ;!=0 ALS AL GESCRUNGED
                      
BUFSIZE EQU 256                 ;MINSTENS 256 (ZIE MISC.8)

INBUF:  DB BUFSIZE DUP ?
EXEHEADER:
OUTBUF: DB BUFSIZE DUP ?
mdrvbuffer:
        db 0220 dup 0
specchars:
        db 1024 dup 0

FIXUP_TABLE:
        DW sfix2,sfix4,SFIX5,SFIX6,SFIX7,SFIX8,SFIX9,sfix10,sfix11,sfix12
        dw sfix13,sfix14,sfix15,sfix16,0

ROMS_FILENAME:  DB "ROMS.BIN",0
ini_filename:   db "z80.ini",0
stext:  ;first text
NEM:    DB "Insufficient memory available."
L0D0A:  DB 0d,0a,'$'
MES1:   DB 0d,0a,"Z80 - the Sinclair ZX Spectrum Emulator - (c) 1993 G.A. Lunter - version 2.01a",0d,0a
        db "      Spectrum ROM code copyright Amstrad plc, used by permission.",0d,0a
        db "      $"
regmes: db "Registered user: $"
shwmes: db "Shareware version: see documentation for registration details$"
hmes:   db 0d,0a,"      Type Z80 -? for help",0D,0A,'$'
ROMMES: DB "File ROMS.BIN not found or corrupt.",0D,0A,'$'
MES4:   DB "      Relative speed of emulator: $"
MES5:   DB "%",0d,0a,0a,'$'
toofasterr:     db "Sorry --- this computer is too fast!$"
initoolong:     db "Z80.INI file too long, maximum is 8000 bytes. Default settings assumed.",0d,0a,'$'
SHELLMES:       DB "Type 'EXIT' to return to the ZX Spectrum Emulator -- $"
SHELLMES2:      DB "K bytes free",0d,0a,"$"
VIDEOKAART:     DB "Using video interface: $"
ZANDJOYMES:     DB "Digital 'Zandbergen' joystick interface detected.",0d,0a,'$'
NORMJOYMES:     DB "Analogue IBM joystick interface detected.",0d,0a,'$'
NOJOYMES:       DB "No joystick interface detected.",0d,0a,'$'
ERROR_IN_FILE:  DB "Error in .Z80 or .SNA file.",0d,0a,'$'
error_wrong_version: db "Version 2.0 does not support this .Z80 file - please upgrade.",0d,0a,'$'
emsmes:         db "EMS memory detected.",0d,0a,'$'
noemsmes:       db "No EMS memory -- only partial '128 emulation!",0d,0a,'$'
EMSERR:         DB "EMS driver error (probably not enough memory).",0d,0a,'$'
VK1:    DB "CGA",0d,0a,0a,'$'
VK2:    DB "Hercules",0d,0a,0a,'$'
VK3:    DB "Extended Hercules",0d,0a,0a,'$'
VK4:    DB "EGA",0d,0a,0a,'$'
VK5:    DB "Plantronics",0d,0a,0a,'$'
VK6:    DB "VGA",0d,0a,0a,'$'
adlib_msg:      db "Adlib Compatible soundcard found.",0d,0a,'$'
noadlib_msg:    db "No Adlib Compatible soundcard found for '128 sound.",0d,0a,'$'
REGERR: DB "Sorry -- switches -z and -b are available to registered users only.",0d,0a
        DB "See the documentation for details on how to register for this program.",0d,0a,0a,'$'
PERR:   DB 0d,0a,"Error in parameters on command line.$"
inierr: db 0d,0a,"Error in z80.ini file at line $"
dbgerr: db 0d,0a,"Error in trap address; format is -xd#### hexadecimal.$"
IERR:   db 0d,0a,"Fatal internal error$"
VIDMES: DB 0d,0a,"No suitable video interface found. Use appropriate switch.",0d,0a,"$"
NCPERR: DB 0D,0A,"COM-port not found.$"
NLPERR: DB 0D,0A,"LPT-port not found.$"
OUTFILE_NF:     DB 0D,0A,"Error during opening output-file.$"
INFILE_NF:      DB 0D,0A,"Input-file not found.$"
DUPOUT: DB 0D,0A,"More than one output-channel specified.$"
MDRVERR: DB 0D,0A,"Invalid microdrive number, or cartridge file not found.$"
ROMFILE_NF: DB 0D,0A,"Specified ROM image file not found or not exactly 16K bytes long.$"
terr1:  db 0d,0a,"-T switch unknown, or arguments missing.$"
terr2:  db 0d,0a,"Tape input-file not found.$"
terr3:  db 0d,0a,"Error opening tape output-file.$"
terr6:  db 0d,0a,"Switch -XP, -XM, -TD or -TS: Invalid directory.$"
xerr1:  db 0d,0a,"-X switch unknown, or arguments missing.$"
endmes:
        db "This program is shareware.  If you like it and use it regularly you should",0d,0a
        db "register.  The registered version can load all Spectrum programs directly from",0d,0a
        db "tape, can be slowed down, and comes with several utilities and the complete",0d,0a
        db "source files.  The registration fee is HFL 25,-- for Dutch users, and HFL 35,--,"
        db "20 US dollar or 15 British pound for foreign users.  Read the manual for more",0d,0a
        db "details.  Send the money, together with your name and address, to:",0d,0a,0d,0a
        db "            Gerton Lunter",0d,0a
        db "            P.O. Box 2535",0d,0a
        db "            NL-9704 CM  Groningen",0d,0a
        db "            The Netherlands",0d,0a,'$'
HELPMES:DB "Syntax: Z80 [{-|/}switches ...] [filename[{.z80|.sna}]]",0d,0a
        db 0d,0a
        db "Display adapter options:",0d,0a
        db "   -h        Hercules graphics",0d,0a
        db "   -xh       Extended Hercules graphics",0d,0a
        db "   -p        Plantronics graphics",0d,0a
        db "   -q        Plantronics, different palette",0d,0a
        db "   -c        CGA graphics",0d,0a
        db "   -e        EGA graphics",0d,0a
        db "   -v        VGA graphics",0d,0a
        db "   -xv       400-line VGA (For some Tridents)",0d,0a
        db "   -xb       Black-and-white VGA",0d,0a
        db "Spectrum hardware options:",0d,0a
        db "   -n        Emulate a Spectrum without Interface I",0d,0a
        db "   -s        Emulate a spectrum with SamRam",0d,0a
        db "   -1[28]    Emulate a Spectrum 128 (can be used with -n)",0d,0a,'$'
helpmes2:
        db "Emulator configuration:",0d,0a
        db "   -znnn.n   Emulate the Spectrum at speed nnn.n%",0d,0a
        db "   -xp D     Select default directory D for .Z80 snapshot files",0d,0a
        db "   -yl, -yh  Low, high video synchronization mode",0d,0a
        db "   -r        Emulate the R register",0d,0a
        db "   -2        Emulate an Issue-2 Spectrum",0d,0a
        db "   -d        Double interrupt frequency (100 Hz)",0d,0a
        db "   -f        Faster FLASH emulation",0d,0a
        db "   -l        Better (but slower) LDIR/LDDR emulation",0d,0a
        db "   -xf       Switch full 16K of Interface I ROM",0d,0a
        db "   -xr F     Use file F as standard Spectrum rom",0d,0a
        db "Joystick options:",0d,0a
        db "   -kk       Do not look for analog or Zandbergen joystick",0d,0a
        db "   -kz       Use digital Zandbergen joystick",0d,0a
        db "   -jk       Emulate Kempston joystick (instead of Cursor)",0d,0a
        db "   -j1, -j2  Emulate Sinclair joysticks 1 or 2",0d,0a
        db "   -xs       Default to shifted cursor keys (NumLock) in '128 mode",0d,0a
        db "Microdrive and tape options:",0d,0a
        db "   -m N F    Insert cartridgefile F{.MDR} in microdrive N",0d,0a
        db "   -xm D     Select default directory D for .MDR files",0d,0a
        db "   -bN       Use LPTn for tape I/O",0d,0a
        db "   -td D     Select directory D for multiple .TAP file mode",0d,0a
        db "   -ts D     Specify default directory for single .TAP file mode",0d,0a,'$'
helpmes3:
        db "   The next options all automatically select Single .TAP File mode:",0d,0a
        db "   -ti F     Use F{.TAP} as tape input",0d,0a
        db "   -to F     Use F{.TAP} as tape output (if exists, append)",0d,0a
        db "   -tm       Mirror tape input to disk (Do also specify output file!)",0d,0a
        db "   -te       Mirror tape input to disk in EXACT mode",0d,0a
;        db "   -tw       Don't wrap load pointer of tapefile at end",0d,0a,'$'
        db "RS232 redirection options:",0d,0a
        db "   -aN       Redirect Spectrum RS232 output to LPTn",0d,0a
        db "   -oN       Redirect Spectrum RS232 output to COMn",0d,0a
        db "   -uF       Redirect file F to Spectrum RS232 input",0d,0a
        db "   -iN       Redirect COMn to Spectrum RS232 input",0d,0a
        db "   -wF       Redirect Spectrum RS232 output to file F",0d,0a
        db "Sound options:",0d,0a
        db "   -g        No sound",0d,0a
        db "   -xa       Do not use Adlib for 128 sound",0d,0a
        db "   -xc       Use CM/S chips on SoundBlaster for noise",0d,0a
        db "   -xi       Do not use internal PC speaker for 128 sound",0d,0a
        db "Miscellaneous switches:",0d,0a
        db "   -xe       Do not use expanded memory",0d,0a
        db "   -xz       Assume AZERTY keyboard layout",0d,0a
        db "   -xw       Run in Windows compatibility mode",0d,0a
;        db "   -xd####   Generate an 8086 INT 3 at Z80 hex address ####",0d,0a
        db "   -?        This help page",0d,0a,0d,0a,'$'
keymes1:
        db "Press a key...",0d,'$'
keymes2:
        db "              ",0d,'$'

MAIN:   PUSH DS
        PUSH CS
        POP DS
        MOV DX,MES1
        MOV AH,9
        INT 021
        mov dx,shwmes
        mov ah,9
        int 021
        mov dx,hmes
        mov ah,9
        int 021
        POP DS
        PUSH ES
        PUSH DS
        MOV AX,SEG _FIRST_FUNC
        MOV BX,SEG emulate
        ADD BX,01500                    ;16K + NOGWAT + 64K
        SUB BX,AX
        PUSH DS
        POP ES
        MOV AH,04A
        INT 021                         ;SETBLOCK
        IF C JMP NOT_ENOUGH
        call calcchecksum
        CMP CS:ROMADR,0
        IF Z JMP SCRUNGEIT
        MOV AX,SEG OPC0
        MOV DS,AX
        MOV ES,AX
        std
        MOV SI,CS:ROMADR
        DEC SI
        MOV DI,0FFEE
        MOV CX,0FFEF
        lodsb
        xchg ah,al
        lodsb
        xchg ax,bp
MLODSB  MACRO
        DEC BP
        CMP BP,OFFSET INBUF
        IF B MOV BP,OFFSET INBUF+255
        LODSB
        xor al,cs:b[offset checksum+1]
        SUB AL,CS:B[BP]
        xor al,cs:b[offset checksum]
#EM
DESCRUNGE:
        MLODSB
DESCR_AGAIN:
        CMP AL,090
        JZ CHECK_BLOCK
        STOSB
        LOOP DESCRUNGE
        JMP DESCR_DONE
CHECK_BLOCK:
        MLODSB
        CMP AL,092
        JZ DO_BLOCK
        MOV ES:B[DI],090
        DEC DI
        DEC CX
        JMP DESCR_AGAIN
DO_BLOCK:
        MLODSB
        AND AL,AL
        JZ PUTBLOCK
        CMP AL,1
        JZ PUT9092
        MOV AH,AL
        mov al,0cc
PUTZERO:
        STOSB
        cmp ah,3
        if z mov al,00
        DEC CX
        DEC AH
        JNZ PUTZERO
        JCXZ DESCR_DONE
        JMP DESCRUNGE
PUT9092:
        MOV AL,090
        STOSB
        mov al,092
        STOSB
        DEC CX
        DEC CX
        JMP DESCRUNGE
PUTBLOCK:
        DEC DI
        MOV AX,09090
        STOSW
        STOSW
        MOV AL,0E3
        STOSW
        MOV AX,0FF3d
        STOSW
        MOV B[DI+1],08A
        SUB CX,9
        JMP DESCRUNGE
DESCR_DONE:
        PUSH CS
        POP DS
        MOV AX,SEG OPC0
        MOV ES,AX
        MOV SI,FIXUP_TABLE
        CLD
FIXUP2: LODSW
        AND AX,AX
        JZ FIXUP3
        MOV BX,AX
        MOV ES:[BX],CS
        JMP FIXUP2
FIXUP3: POP DS
        XOR AX,AX
        MOV ES,AX
        mov ax,es:w[0417]
        mov cs:kstate,ax
;        and ax,080
;        mov ES:W[0417],ax
;        call set_kbd_leds
        POP ES
        PUSH DS
        call get_cbaddrs
        PUSH CS
        POP DS
        MOV NUMLCK,0
        MOV TTYPE,0          ;GEEN PLANTRONICS TERM. TYPE GESCAND
        MOV DOUBLE,0         ;NORMALE IRUPT SNELHEID
        MOV mflag,0          ;fast r register emulation; fast ldir emulation
        MOV FLASH,0          ;GEEN FLASH EMULATIE
        MOV HERCFLG,0        ;GEEN HERCULES
        MOV XTDHERC,0        ;GEEN XTD HERCULES
        MOV CGA,0            ;GEEN CGA
        MOV EGA,0            ;GEEN EGA
        mov vga,0
        mov trivga,0
        mov greyvga,0
        MOV EGAPAL,0         ;NORMAAL PALET
        MOV SILENCE,0        ;GEEN STILLE SPECTRUM
        mov cmschips,0       ;Do not use CM/S chips on soundblaster
        mov intsnd,0ff       ;128 sound through internal speaker if no adlib
        MOV ISSUE2,0         ;GEEN ISSUE 2 GEEMULEERD
        MOV IMMNMI,0         ;GEEN IMMEDIATE NMI
        MOV OUTMODE,0        ;RS232 <-> NIETS (VOOR DEF ZIE LOAD_ROMS)
        MOV OUTNUM,0         ;LPT1
        MOV INMODE,0         ;RS232 <-> NIETS
        MOV IF1SW,0          ;8K IF1 BANKSWITCH
        MOV ROMMOD,1         ;IF1
        MOV JOYMODE,0        ;CURSOR JOYSTICK
        MOV KEMPSTON_STATE,0 ;JOYSTICK IN MIDDENSTAND
        MOV ZANDJOY,0FF      ;AUTODETECTIE ZANDJOY & ANALOGE JOYSTICK
        mov curs128,0
        MOV TAPEIF,1
        MOV SYNCMOD,2        ;STANDAARD VIDEO SYNC.
        MOV KEYSCAN,0        ;NORMALE KEYBOARD SCANNING
        MOV SPCTEL,0         ;ZIE LOAD_BLOCK IN CIF.8
        mov tstates,-17470
        mov expmem,0ff       ;try to use expanded memory
        mov ax,01600
        int 02f
        and al,07f           ;00 or 80: Windows not running
        if nz mov al,0ff
        mov winkey,al
        mov comsdat,0
        mov comsclk,0
        mov readwrt,0
        mov erase,0
        mov motors,0         ;all mdrv motors off
        mov dataread,0
        mov datawritten,0
        mov cts,0
        mov cts128,0
        mov word cs:envaddlo,0
        mov word cs:envaddhi,0
        MOV C_ACTIVE,0
        MOV MODFLG,0
        MOV JOYXY,0
        MOV PUTOUT,OFFSET OUTBUF
        MOV GETOUT,OFFSET OUTBUF
        MOV PUTIN,OFFSET INBUF
        MOV GETIN,OFFSET INBUF
        MOV CS:RFA,-1           ;TIJDELIJK, VOOR INSTELLING SNELHEID
        MOV CS:ATRADR,ATTRP1
        POP DS
        MOV bX,01000+011+(stack_size)/8        ;64K for emulator, 0100 PSP
        ADD bX,SEG emulate
        sub bx,SEG _FIRST_FUNC
        MOV CS:PROGSEG,DS
        push ds
        pop es
        MOV AH,04A
        INT 021                 ;Allocate as much memory as is needed for the
        xor ax,ax               ;program alone (no roms, etc.)
        mov es,ax
        mov ax,es:[0408]
        test ax,ax
        if z mov ax,03f8
        inc ax
        mov cs:tapeio,ax
        cmp cs:winkey,0
        jne getspd_windows
        mov ah,048
        mov bx,01000            ;Allocate temporary 64K chunk to emulate in
        int 021
        if c jmp not_enough
        mov cs:specseg,ax
        CALL GET_SPD
        mov es,cs:specseg       ;Free 64K chunk
        mov ah,049
        int 021
        MOV AX,DX               ;'RONDE-TELLER' BC
        MOV DX,0BFF0            ;LENGTE VAN EEN 'RONDE'
        MUL DX
        ADD AX,DI               ;TEL PC HIER BIJ OP
        ADC DX,0
        SUB AX,SI               ;TREK BEGINPC HIERVAN AF
        SBB DX,0
        jmp getspd_continue
getspd_windows:
        mov cs:cxloop,3574
        mov cs:bxcst,894
        mov cs:inloop,1729
        mov ax,44000
        xor dx,dx
getspd_continue:
        shl ax,1
        rcl dx,1
        cmp dx,52               ;52*65536/88 approx 40000, 4000.0% is max
        if a jmp too_fast
        MOV CX,88
        DIV CX
        MOV BX,CS
        MOV DS,BX
        PUSH AX
        MOV AH,9
        MOV DX,MES4
        INT 021
        POP AX
        PUSH AX
        MOV CH,0
        mov bx,10000
        call print_digit
        MOV BX,1000
        CALL PRINT_DIGIT
        MOV BX,100
        CALL PRINT_DIGIT
        MOV BX,10
        MOV CH,1
        CALL PRINT_DIGIT
        PUSH AX
        MOV AH,2
        MOV DL,'.'
        INT 021
        POP AX
        MOV BX,1
        CALL PRINT_DIGIT
        MOV AH,9
        MOV DX,MES5
        INT 021
        POP BX                  ;BX IS REL. SNELHEID IN PROMILLES
        MOV CS:RELSPD0,BX       ;SLA DEZE SNELHEID OP
        call get_progpath
        mov es:b[di],0
        push di
        push cs
        pop ds
        mov si,offset specchars
        mov di,offset _progpath
        mov ax,seg _progpath
        mov es,ax
        mov cx,128
        rep movsb
        push cs
        pop es
        pop di
        mov si,ini_filename
        mov cx,9
        rep movsb
        mov dx,offset specchars
        mov ax,03d00
        int 021
        jc ini_not_found
        mov dx,offset vga_workspace     ;over 4K of workspace
        mov bx,ax
        mov cx,8000
        mov ah,03f
        int 021
        jc ini_not_found
        test ax
        jz ini_not_found
        cmp ax,8000
        jz ini_too_long
        mov si,offset vga_workspace
        mov bx,ax
        mov b[si+bx],01a
        mov bx,1                ;line counter
        call param_iniloop
ini_not_found:
        MOV DS,CS:PROGSEG
        MOV SI,080              ;command line
        CMP BYTE [SI],0
        IF Z JMP LOAD_ROMS
        INC SI
        call param_loop
        jmp load_roms
        ret
ini_too_long:
        push cs
        pop ds
        mov dx,initoolong
        mov ah,9
        int 021
        jmp ini_not_found


param_iniloop:
        lodsb
        cmp al,9
        jz param_iniloop
        cmp al,020
        jz param_iniloop
        cmp al,0a
        jnz nonewline
        inc bx
        jmp param_iniloop
nonewline:
        cmp al,0d
        jz param_iniloop
        cmp al,'%'
        jz param_skip
        cmp al,01a
        jz ret
        cmp al,'-'
        jz param_i_par
        cmp al,'/'
        jz param_i_par
ini_err:
        push bx
        mov dx,inierr
        CALL PRINT
        pop ax
        MOV CH,0
        MOV BX,1000
        CALL PRINT_DIGIT
        MOV BX,100
        CALL PRINT_DIGIT
        MOV BX,10
        CALL PRINT_DIGIT
        MOV CH,1
        mov bx,1
        call print_digit
        MOV DX,L0D0A
        CALL PRINT
        MOV AX,04C01
        INT 021

param_skip:
        lodsb
        cmp al,01a
        jz ret
        cmp al,0a
        jnz param_skip
        inc bx
        jmp param_iniloop

param_i_par:
        push bx
        LODSB
        AND AL,0DF
        MOV BX,OFFSET OPLIST
OPLOOPini:
        CMP AL,CS:[BX]
        JZ CALLiniOPTION
        ADD BX,4
        CMP CS:W[BX],0
        JNZ OPLOOPini
        pop bx
        jmp ini_err

CALLiniOPTION:
        CALL CS:[BX+2]
        pop bx
        JMP PARAM_iniloop





PARAM_LOOP:
        LODSB
        CMP AL,9
        JZ PARAM_LOOP
        cmp al,020
        jz param_loop
        DEC SI
        CMP AL,0D
        jz ret
        cmp al,01a
        jz ret
        CMP AL,'/'
        IF Z JMP PARAMS
        CMP AL,'-'
        IF Z JMP PARAMS
        ret

PARAMS2:
        LODSB                   ;NIEUW KARAKTER
        DEC SI                  ;POINT WEER NAAR NIEUW KARAKTER
        CMP AL,32
        JZ PARAM_LOOP
        CMP AL,9                ;TAB
        JZ PARAM_LOOP
        TEST AL
        jz ret
        CMP AL,0D
        jz ret
        cmp al,01a
        jz ret
        CMP AL,'-'
        JZ PARAMS
        CMP AL,'/'
        JZ PARAMS
        DEC SI                  ;USE 'DUMMY SWITCHAR' (OUDE OPTIE)
PARAMS:
        LODSB                   ;switchchar
        LODSB                   ;NIEUWE OPTIE
        AND AL,0DF
        MOV BX,OFFSET OPLIST
        MOV DX,PERR
OPLOOP:
        CMP AL,CS:[BX]
        JZ CALLOPTION
        ADD BX,4
        CMP CS:W[BX],0
        JNZ OPLOOP
        JMP ENDERR

CALLOPTION:
        CALL CS:[BX+2]
        JMP PARAMS2

OPLIST: DW 'N',PNORM,'S',PSAMR,01F,PHELP,'D',PDOUBLE,'R',PRREG,'F',PFLSH
        DW 'L',PLDR,'H',PHERC,'X',PXXX,'C',PCGA,'G',PSILENCE,'O',PSERN
        DW 'I',PISERN,'A',PPARN,'W',PFILEOUT,'U',PFILEIN,'E',PEGA,'T',PTTAPE,
        DW 'V',PVGA,'P',PPLANT,'Q',PQPLANT,'K',PJINPUT,'J',PJOYSTICK,'Z',PSPEED
        DW 012,PISSUE2,'Y',PSYNC,'B',PTAPE,'M',PMDRV,011,P128,0

PHELP:  MOV DX,HELPMES
        push cs
        pop ds
        mov ah,9
        int 021
        mov ax,04400
        mov bx,1
        int 021
        and dl,082
        cmp dl,082
        pushf
        if z call helpkey
        mov dx,helpmes2
        mov ah,9
        int 021
        popf
        if z call helpkey
        mov dx,helpmes3
        mov ah,9
        int 021
        mov ax,04c00
        int 021
helpkey:
        mov dx,keymes1
        mov ah,9
        int 021
helpkey2:
        mov ah,0b
        int 021
        and al,al
        jz helpkey2
        mov ah,7
        int 021
        mov dx,keymes2
        mov ah,9
        int 021
        ret
PDOUBLE:xor CS:DOUBLE,0FF
        RET
PNORM:  cmp cs:rommod,2
        jz pnorm1
        ja pnorm2
        xor cs:rommod,1
        ret
pnorm1: mov cs:rommod,0
        ret
pnorm2: xor cs:rommod,7
        ret
PSAMR:  cmp cs:rommod,2
        MOV CS:ROMMOD,2
        if z mov cs:rommod,1
        RET
p128:   lodsw
        cmp ax,'82'
        if nz sub si,2
        cmp cs:rommod,2
        ja p1281
        jb p1282
        mov cs:rommod,4
        ret
p1281:  sub cs:rommod,3
        ret
p1282:  add cs:rommod,3
        ret
PIF1BSW:xor CS:IF1SW,0FF
        RET
PRREG:  xor CS:mflag,1
        RET
PFLSH:  xor CS:FLASH,0FF
        RET
PLDR:   xor CS:mflag,2
        RET
PISSUE2:xor CS:ISSUE2,0FF
        RET
PXXX:   CALL GETCHR
        CMP AL,'H'
        if Z jmp PXTDHERC
        CMP AL,'N'
        if Z jmp PIMMNMI
        cmp al,'R'
        if z jmp pnewrom
        cmp al,'E'
        if z jmp pexpmem
        cmp al,'C'
        if z jmp pcms
        cmp al,'D'
        if z jmp pdebug
        cmp al,'Z'
        if z jmp pazerty
        cmp al,'V'
        if z jmp p400vga
        cmp al,'A'
        if z jmp padlib
        cmp al,'F'
        if z jmp pif1bsw
        cmp al,'I'
        if z jmp pinternal
        cmp al,'W'
        if z jmp pwinkey
        cmp al,'S'
        if z jmp pcurs128
        cmp al,'B'
        if z jmp pgreyvga
        dec si                  ;point to the option again
        push ds
        push si
        mov ds,seg _double
        mov ax,sp
        push ss
        push ax
        call far _xswitch
        pop bx
        pop bx
        pop si
        pop ds
        mov dx,xerr1
        cmp ax,1
        if z jmp enderr
        mov dx,terr6
        cmp ax,6
        if z jmp enderr
        ret
PIMMNMI:
        xor CS:IMMNMI,0FF
        RET
PXTDHERC:
        xor CS:XTDHERC,0FF
        xor cs:hercflg,0ff
        ret
PHERC:  xor CS:HERCFLG,0FF
        cmp cs:xtdherc,0ff
        jnz ret
        mov cs:xtdherc,0
        mov cs:hercflg,0ff
        RET
PCGA:   xor CS:CGA,0FF
        RET
p400vga:xor cs:trivga,0ff
PVGA:   xor CS:VGA,0FF
        RET
PEGA:   xor CS:EGA,0FF
        RET
PPLANT: cmp cs:atradr,attrp1
        jnz notplant
        cmp cs:plantr,0ff
        jnz notplant
        mov cs:plantr,0
        ret
notplant:
        MOV CS:PLANTR,0FF
        mov cs:atradr,attrp1
        RET
PQPLANT:cmp cs:atradr,attrp1g
        MOV CS:PLANTR,0FF
        MOV CS:ATRADR,ATTRP1G
        jnz ret
        mov cs:atradr,attrp1
        mov cs:plantr,0
        RET
pnewrom:
        mov dx,offset _tapein   ;dummy
        call transfer_open_name
        jc pnr_err
        mov cs:xrhandle,ax
        ret
pazerty:
        mov bx,offset keybtab1
        mov al,cs:[bx+01e]
        xchg al,cs:[bx+010]
        mov cs:[bx+01e],al
        mov al,cs:[bx+02c]
        xchg al,cs:[bx+011]
        mov cs:[bx+02c],al
        xor cs:azerty,0ff
        jz qwerty
        mov al,cs:[bx+12]
        xchg al,cs:[bx+13]
        xchg al,cs:[bx+50]
        xchg al,cs:[bx+39]
        mov cs:[bx+12],al       ;to make it invertible
        ret
qwerty: mov al,cs:[bx+12]
        xchg al,cs:[bx+39]
        xchg al,cs:[bx+50]
        xchg al,cs:[bx+13]
        mov cs:[bx+12],al
        ret
pexpmem:
        xor cs:expmem,0ff
        ret
padlib:
        xor cs:adlib,0ff
        ret
pwinkey:
        xor cs:winkey,0ff
        ret
pgreyvga:
        xor cs:greyvga,0ff
        ret
pnr_err:
        mov dx,romfile_nf
        jmp enderr
pcms:
        xor cs:cmschips,0ff
        ret
pinternal:
        xor cs:intsnd,0ff
        ret
pcurs128:
        xor cs:curs128,0ff
        ret
PSILENCE:
        xor CS:SILENCE,0FF
        RET
PJOYSTICK:
        CALL GETCHR
        CMP AL,'1'
        JE PJOY_SINCLAIR
        CMP AL,'2'
        JE PJOY_SINCLAIR
        CMP AL,'K'
        IF NE JMP ERR
        mov al,1
pjoyput:cmp cs:joymode,al
        MOV CS:JOYMODE,al
        jnz ret
        mov cs:joymode,0
        RET
PJOY_SINCLAIR:
        ADD AL,2-'1'
        jmp pjoyput
pdebug:
        xor bx,bx
        call pdebug_chr
        call pdebug_chr
        call pdebug_chr
        call pdebug_chr
        mov cs:debugadr,bx
        mov cs:debugflg,0ff
        ret
pdebug_chr:
        lodsb
        cmp al,'a'
        if ae and al,0df
        cmp al,'0'
        jb pdbg_err
        cmp al,'F'
        ja pdbg_err
        cmp al,'9'
        jbe pdbg_ok
        cmp al,'A'
        jb pdbg_err
        add al,'0'-'A'+10
pdbg_ok:
        sub al,'0'
        mov cl,4
        shl bx,cl
        or bl,al
        ret
pdbg_err:
        mov dx,dbgerr
        jmp enderr
pttape:
        push ds
        push si
        mov ds,seg _double
        mov ax,sp
        push ss
        push ax
        call far _tswitch
        pop bx
        pop bx
        pop si
        pop ds
        mov dx,terr1
        cmp ax,1
        if z jmp enderr
        mov dx,terr2
        cmp ax,2
        if z jmp enderr
        mov dx,terr3
        cmp ax,3
        if z jmp enderr
        mov dx,terr6
        cmp ax,6
        if z jmp enderr
        ret
PJINPUT:
        CALL GETCHR
        CMP AL,'K'
        JE PJKEYBOARD
        CMP AL,'Z'
        IF NE JMP ERR
        mov al,1
        jmp pjinputput
PJKEYBOARD:
        xor al,al
pjinputput:
        cmp cs:zandjoy,al
        MOV CS:ZANDJOY,al
        jnz ret
        mov cs:zandjoy,0ff
        RET
pmdrv:  lodsb
        cmp al,' '
        jz pmdrv
        dec si
        mov dx,mdrverr
        call getchr
        sub al,'1'
        jb pmdrverr
        cmp al,8
        jae pmdrverr
        xor ah,ah
        mov bx,ax
pmdrv_1:
        lodsb
        cmp al,' '
        jz pmdrv_1
        dec si
        push si
pmdrv_search:
        lodsb
        cmp al,' '
        jz pmdrv_end
        cmp al,0d
        jz pmdrv_end
        cmp al,01a
        jz pmdrv_end
        cmp al,9
        jnz pmdrv_search
pmdrv_end:
        dec si
        pop cx
        push w[si]
        mov b[si],0
        push si
        push cs
        mov ax,offset mhandles
        push ax
        push ds
        push cx
        push bx
        mov ax,seg _double
        mov ds,ax
        call far _mswitch
        pop bx
        pop bx
        pop ds
        pop bx
        pop bx
        pop si
        pop w[si]
        test ax,ax
        jnz ret
pmdrverr:
        mov dx,mdrverr
        jmp enderr
PSYNC:  LODSB
        CMP AL,020
        JZ PSYNC
        CMP AL,9
        JZ PSYNC
        CMP AL,0D
        IF Z JMP ERR
        cmp al,01a
        if z jmp err
        AND AL,0DF
        CMP AL,'L'
        JZ PSYNCLO
        CMP AL,'H'
        IF NZ JMP ERR
        mov al,1
        jmp psyncput
PSYNCLO:mov al,3
psyncput:
        cmp cs:syncmod,al
        mov cs:syncmod,al
        jnz ret
        mov cs:syncmod,2
        RET
PSPEED:
        MOV DX,REGERR
        JMP ENDERR
PFILEIN:
        MOV DX,OFFSET _INPUTFILE
        CALL TRANSFER_OPEN_NAME
        MOV DX,INFILE_NF
        IF C JMP ERR2
        MOV CS:INNUM,AX
        MOV CS:INMODE,3
        MOV CS:RSCOUNT,0
        RET
PFILEOUT:
        CALL CHK_DUPOUT
        MOV DX,OFFSET _OUTPUTFILE
        CALL TRANSFER_OPEN_NAME
        MOV DX,OUTFILE_NF
        IF C JMP ERR2
        MOV CS:OUTNUM,AX
        MOV CS:OUTMODE,3
        RET
PSERN:  CALL CHK_DUPOUT
        CALL GETN
        CMP AL,4
        IF AE JMP ERR
        MOV CS:OUTMODE,2
        MOV CS:OUTNUM,AX
        MOV CS:RSOUTCOUNT,0
        ret
PTAPE:
        mov dx,regerr
        jmp enderr
CHECKCOM:
        ADD AX,AX
        PUSH ES
        PUSH AX
        MOV AX,040
        MOV ES,AX
        POP BX
        CMP ES:W[BX],0
        POP ES
        IF Z JMP NOCOMPORT
        RET
PPARN:  CALL CHK_DUPOUT
        CALL GETN
        MOV CS:OUTMODE,1
        MOV CS:OUTNUM,AX
        ADD AX,AX
        PUSH ES
        XOR BX,BX
        MOV ES,BX
        MOV BX,AX
        CMP ES:W[BX+0408],0
        POP ES
        JZ NOLPTPORT
        RET
PISERN: CALL GETN
        CMP AL,4
        IF AE JMP ERR
        MOV CS:INMODE,2
        MOV CS:INNUM,AX
        JMP SHORT CHECKCOM
GETN:   LODSB
        CMP AL,'1'
        JB GETNERROR
        CMP AL,'4'
        JA GETNERROR
        SUB AL,'1'
        XOR AH,AH
        RET
GETCHR: LODSB
        CMP AL,'a'
        JB GTCH_NOLOWER
        CMP AL,'z'
        JA GTCH_NOLOWER
        AND AL,0DF
GTCH_NOLOWER:
        CMP AL,'0'
        JB GETNERROR
        CMP AL,'9'
        JBE RET
        CMP AL,'A'
        JB GETNERROR
        CMP AL,'Z'
        JBE RET
GETNERROR:
        POP DX
ERR:
        MOV DX,PERR
ERR2:
        JMP ENDERR
CHK_DUPOUT:
        CMP CS:OUTMODE,0
        JZ RET
        MOV DX,DUPOUT
        JMP ERR2
NOCOMPORT:
        MOV DX,NCPERR
        JMP ENDERR
NOLPTPORT:
        MOV DX,NLPERR
        JMP ENDERR
TRANSFER_OPEN_NAME:
        PUSH ES
        MOV AX,SEG _INPUTFILE
        MOV ES,AX
        PUSH DX
        PUSH DX
        POP BX
TN1:    LODSB
        CMP AL,' '
        JZ TN1
        DEC SI
TRANSFER_NAME:
        LODSB
        CMP AL,' '
        JZ EOFN
        CMP AL,9
        JZ EOFN
        CMP AL,'-'
        JZ EOFN
        CMP AL,'/'
        JZ EOFN
        CMP AL,0
        JZ EOFN
        CMP AL,0D
        JZ EOFN
        cmp al,01a
        jz eofn
        MOV ES:[BX],AL
        INC BX
        JMP TRANSFER_NAME
EOFN:   MOV ES:B[BX],0
        DEC SI
        POP DX
        CMP DX,OFFSET _outputfile
        JNZ OPEN_F
        MOV AH,03C
        MOV CX,020
        PUSH DS
        PUSH ES
        POP DS
        INT 021
        JMP SHORT OPENED
OPEN_F: MOV AX,03D00
        PUSH DS
        PUSH ES
        POP DS
        INT 021
OPENED: POP DS
        POP ES
        JNC RET
        MOV AX,0
        RET




LOAD_ROMS:                              ;...but first do some initialising
        PUSH DS
        PUSH SI
        call adlib_init
        CALL INITJOYSTICK               ;initialiseer joystick uitlezing
        mov dx,cs:tapeio
        push dx
        call far _getissue2default
        pop dx
        MOV AX,CS:RFA                   ;EERST SNELHEIDINSTELLING AFHANDELEN
        CALL SPEED_CONVERT
        CMP CS:OUTMODE,0
        IF Z MOV CS:OUTMODE,1           ;DEFAULT LPT1 (OUTNUM=0)
        call allocate_memory

        call init_memory
        call load_romfile
        MOV ax,CS:VIDBUFSEG     ;VIDEO BUFFER SEGMENT ADRES
        MOV ES,AX
        MOV CX,4096
        MOV DI,16384
        XOR AX,AX
        REP STOSW               ;8192 BYTES 0 IN BUFFER
        push es
        mov ax,03523
        int 021
        push es
        push bx
        mov ax,seg breakhandler
        mov ds,ax
        mov dx,offset breakhandler
        mov ax,02523
        int 021
        call init_video
        call intro
        CALL INIT_EMULATOR      ;Must be before load_z80_file but after
        pop dx                  ; init_video (otherwise get_tt fails)
        pop ds
        mov ax,02523
        int 021
        pop es
        CALL RESET              ;ZET Z80 PARAMS BIJ RESET
        POP SI
        POP DS
        push si
        MOV AH,0
        cld
ASCIILOOP:
        LODSB
        TEST AL
        JZ END_ASCII
        CMP AL,0D
        JZ END_ASCII
        cmp al,01a
        jz end_ascii
        CMP AL,020
        JZ END_ASCII
        CMP AL,9
        JZ END_ASCII
        OR AH,080
        CMP AL,'\'
        IF Z AND AH,0FE
        CMP AL,'.'
        JNZ ASCIILOOP
        OR AH,1
        JMP ASCIILOOP
END_ASCII:
        TEST AH,080
        JNZ NAME_FOUND
        CMP AL,020
        JZ ASCIILOOP
        CMP AL,9
        JZ ASCIILOOP
        POP DX
        JMP install_etc
NAME_FOUND:
        MOV BP,SI
        TEST AH,1
        JNZ DONT_ADD
        ADD SI,4
        MOV W[SI-5],'Z' BY '.'
        MOV W[SI-3],'0' BY '8'
DONT_ADD:
        POP DX                  ;DX=BEGIN FILENAME
        MOV B[SI-1],0
        MOV AX,03D00
        INT 021
        mov bx,0                ;signal: z80 file
        IF nC JMP loadz80file
        mov si,bp
        add si,4
        mov b[si-4],'S'
        mov w[si-3],'A' by 'N'
        mov ax,03d00
        int 021
        if c jmp error
        mov bx,1                ;signal: sna file
loadz80file:
        xchg BX,AX
        call load_z80_file
        cmp ax,2
        jz wrong_version
        test ax,ax
        jnz err_file
        mov al,cs:imode
        mov cs:issue2,0
        mov cs:double,0
        mov cs:joymode,0
        test al,4
        if nz mov cs:issue2,0ff
        test al,8
        if nz mov cs:double,0ff
        test al,16
        if nz mov cs:syncmod,1
        test al,32
        if nz or cs:syncmod,2
        cmp cs:syncmod,0
        if z mov cs:syncmod,2
        test al,64
        if nz mov cs:joymode,1
        test al,128
        if nz or cs:joymode,2
        and cs:imode,3
        jmp short install_etc

too_fast:
        mov dx,toofasterr
        jmp enderr
wrong_version:
        call text_mode
        mov dx,error_wrong_version
        jmp enderr
err_file:
        call text_mode
        MOV DX,ERROR_IN_FILE
ENDERR: CALL PRINT
        MOV DX,L0D0A
        CALL PRINT
        MOV AX,04C01
        INT 021
PRINT:  PUSH DS
        MOV DS,CS
        CALL PRINT_DS
        POP DS
        RET
PRINT_DS:
        PUSH AX
        MOV AH,09
        INT 021
        POP AX
        RET
NOT_ENOUGH:
        MOV DX,NEM
        JMP ENDERR


error:  mov cs:c_active,0ff
        mov cs:c_action_code,0f9        ;Luie_gebruiker_code
        mov ds:b[bp-1],0
        mov si,dx
        mov di,offset _prognaam
        mov ax,seg _prognaam
        push es
        push ax
        pop es
        mov cx,129
        cld
        rep movsb
        pop es
install_etc:
        mov ax,cs:specseg
        MOV DS,AX
        CALL SAVE_VECTORS
        MOV BYTE CS:VID_ACT,0           ;MAAK VIDEO INACTIEF
        MOV BYTE CS:TIMFLAG,0           ;MAAK TIMER INACTIEF
        MOV BYTE CS:INTTEL,0
        CLI
        cmp byte cs:winkey,0
        jnz dont_install
        MOV WORD ES:[32],TIMER
        MOV ES:[34],CS
        MOV WORD ES:[36],KEYBOARD
        MOV ES:[38],CS
dont_install:
        MOV WORD ES:[08C],CTRLC         ;IRET
        MOV ES:[08E],CS
        MOV WORD ES:[090],CRIT_ERR
        MOV ES:[092],CS
        MOV WORD ES:[108],CTRLC         ;IRET
        MOV ES:[110],CS
        MOV WORD ES:[52],SEGVIOLATION
        MOV ES:[54],CS
        CALL INSTALL_COM
        STI
        call adlib_turnon
        CALL INIT_EMULATOR
        CALL RREG_INST          ;RREG EMULATIE EN VERTRAGING INSTALLEREN
        CALL LDIR_INST          ;LDIR EMULATIE INSTALLEREN
        CALL SILENCE_INST       ;STILLE SPECTRUM E.D. INSTALLEREN
        PUSH CS
        POP ES
        MOV CS:SP2,SP           ;ZET STACK POINTER VOOR TIMER
        CALL GET_REGS           ;HAAL REGISTERS
        CALL IMMEDIATE_NMI
        JMP FAR EMULATE         ;en spring naar de emulator.




;OUT_BC:
SI_NB_NS:
        SAHF
        MOV AH,BH
        MOV BX,CX
;OUT_CONTINUE:
        PUSHF
        TEST BL,1
        IF NZ JMP SI_NB_NS+0100         ;NO_SPEAKER
        call (68-16)*256+si_nb_ns       ;overscan0
        MOV BX,AX
        IN AL,061
        XCHG AL,AH
        MOV ES:BYTE NEWBOR,AL
        AND AX,0FD10
        ADD AL,-16
        SBB AL,AL
        AND AL,2
        OR AL,AH
        OUT 061,AL
        MOV AX,BX
        POPF
        LAHF
        RET

;OUT_BC:
SI_NB_S:
        SAHF
        MOV AH,BH
        MOV BX,CX
;OUT_CONTINUE:
        PUSHF
        TEST BL,1
        IF NZ JMP SI_NB_S+0100          ;NO SPEAKER
        MOV ES:BYTE NEWBOR,AH
        call (68-16)*256+si_nb_s        ;overscan
        POPF
        LAHF
        RET




in_fast_1:
        INC DI
        cmp b[di],0fe
        jne >l1
        inc di
        mov bx,dx
        MOV DX,0
tapeioadr       equ $-2
        mov al,191
        mov dx,bx
        XOR BL,BL
        MOV BH,[DI]
        JMP BX
        NOP                     ;RUIMTE VOOR:
        NOP                     ; INC ES:B[RR]
        NOP
        NOP
        NOP
l1:     jmp 67*256+183+37*256+in_fast_1        ;in_slow (183=0b7, 37=-219)
len1    equ $-in_fast_1

in_fast_2:
        INC DI
        cmp b[di],0fe
        jne >l1
        inc di
        mov bh,al
        mov bl,0fe
        call in_fast_2+21*256+2+183+37*256    ;in_continue
        mov al,bh
        XOR BL,BL
        MOV BH,[DI]
        JMP BX
        NOP                     ;RUIMTE VOOR:
        NOP                     ; INC ES:B[RR]
        NOP
        NOP
        NOP
l1:     jmp 67*256+183+37*256+in_fast_2        ;in_slow (183=0b7, 37=-219)
len2    equ $-in_fast_2

djnznormal:
        INC DI
        DEC CH                  ;DJNZ E
        JZ >L1
        XCHG AX,BX
        MOV AL,[DI]
        CBW
        ADD DI,AX
        XCHG AX,BX
        XOR BL,BL
L1:     INC DI
        MOV BH,[DI]
        JMP BX
        NOP                     ;RUIMTE VOOR:
        NOP                     ; INC ES:B[RR]
        NOP
        NOP
        NOP
djnzlen1        equ $-djnznormal

djnzslow:
        INC DI
        DEC CH                  ;DJNZ E
        JZ >L1
        mov bx,ax
        MOV AL,[DI]
        CBW
        ADD DI,AX
        mov ax,2
l0:     dec ax
        jne l0
        mov ax,bx
L1:     INC DI
        XOR BL,BL
        MOV BH,[DI]
        JMP BX
        NOP                     ;RUIMTE VOOR:
        NOP                     ; INC ES:B[RR]
        NOP
        NOP
        NOP
djnzlen2        equ $-djnzslow


SILENCE_INST:                           ;OOK INSTALLATIE ISSUE-2
        PUSH AX                         ;en installeert snelle IN A,(FE)
        PUSH SI                         ;en installeert trage DJNZ
        PUSH DI
        PUSH ES
        PUSH DS
        MOV AX,SEG EMULATE
        MOV DS,AX
        mov ax,cs:tapeio
        mov cs:w[offset tapeioadr],ax
        call install_fastin
        MOV AL,3
        MOV SI,OFFSET SI_NB_NS
        CMP CS:SILENCE,0
        JZ INSTALL_SIL
        MOV SI,OFFSET SI_NB_S
        MOV AL,0
INSTALL_SIL:
        MOV cs:B[SILENT2],AL            ;in mdrv.8
        PUSH DS
        POP ES
        PUSH CS
        POP DS
        MOV DI,OFFSET OUT_BC
        MOV CX,73
        CLD
        REP MOVSB
        MOV SI,DJNZNORMAL
        MOV CX,DJNZLEN1
        CMP byte CS:MODFLG,0
        JZ INSTALL_NORMALMODE
        MOV SI,DJNZSLOW
        MOV CX,DJNZLEN2
INSTALL_NORMALMODE:
        MOV DI,16*256
        mov ax,13                       ;13 T states, no nops offset
        call movecommand
        MOV AL,191
        TEST BYTE CS:ISSUE2
        IF NZ MOV AL,0FF
        xor al,cs:byte issue2default
        MOV ES:BYTE VERSIE_ADRES,AL
        mov es:byte versie_adres2,al
        POP DS
        POP ES
        POP DI
        POP SI
        POP AX
        RET



install_fastin:
        push es
        push ds
        push di
        push si
        push cx
        push ax
        mov ax,seg emulate
        mov es,ax
        push cs
        pop ds
        mov di,219*256                  ;IN A,(n)
        mov ax,0200c            ;32 nops offset, 12 T states (NOT 11!)
        mov si,offset in_fast_1
        mov cx,len1
        cmp byte cs:modflg,0
        jne i_fi_realmod
        mov ax,0800c            ;64 nops offset, 12 T states (NOT 11!)
        mov si,offset in_fast_2
        mov cx,len2
i_fi_realmod:
        call movecommand
        pop ax
        pop cx
        pop si
        pop di
        pop ds
        pop es
        ret




;
;The slowdowncode is put at 0B7 + 204..223
;       mov bh,[di]     8a 3d
;       jmp bx          ff e3
;       jmp nn          e9 displacement (rel. to PC just after the jmp)
;       es:             26
;       inc b[]         fe 06 address
;       cmp di,[]       3b 3e address
;       jne n           75 displacement
;       nop             90
;       mov bx,nn       bb number
;       dec bx          4b
;
RREG_INST:
        push ds
        mov bx,offset slowmod
        mov di,(104 shl 8)+0b7
        cld
        mov es,seg emulate
rreg_1loop:
        push bx
        push di
        mov ax,cs:[bx]
        test ax
        if nz call rreg_makeblock
        pop di
        pop bx
        inc bx
        inc bx
        add di,256
        cmp di,124*256
        jb rreg_1loop
        mov ds,seg jx_table
        mov si,offset jx_table
rreg_2loop:
        lodsw
        test ax
        jz jxtable_done
        mov di,ax
        lodsb
        call slowdown_opcode
        jmp rreg_2loop
jxtable_done:
        pop ds
        ret

slowdown_opcode:                ;di->jxf; al=# T states
        mov bx,offset slowmod-8
        xor ah,ah
        add bx,ax
        add bx,ax
        mov bx,cs:[bx]
        test bx
        jz rreg_snel
        mov ah,al
        mov al,0e9
        stosb
        add ah,100
        mov al,0b5
        sub ax,di
        stosw
        ret
rreg_snel:
        test cs:mflag,1
        jz rreg_echtsnel
        mov al,026
        stosb
        mov ax,06fe
        stosw
        mov ax,offset rr
        stosw
rreg_echtsnel:
        mov ax,03d8a
        stosw
        mov ax,0e3ff
        stosw
        ret

rreg_makeblock:
        test cs:debugflg,0ff
        jz no_debugging
        push ax
        mov al,026
        stosb
        mov al,03b
        stosb
        mov al,03e
        stosb
        mov ax,offset debugadr  ;cmp di,es:[debugadr]
        stosw
        mov ax,0375             ;jne >
        stosw
        mov al,0e9
        stosb
        mov ax,offset trapper
        sub ax,di
        sub ax,2
        stosw                   ;jmp trapper
        pop ax
no_debugging:
        test cs:winkey,0ff
        jz no_winkey
        push ax
        mov al,026
        stosb                   ;es:
        mov ax,00683
        stosw                   ;inc w[],n
        mov ax,offset tstates
        stosw
        mov ax,di               ;high byte: 100+ # T states
        sub ah,100
        mov al,ah
        stosb
        mov ax,0573             ;jnc 5 bytes ahead
        stosw
        mov al,0ea              ;jmp far
        stosb
        mov ax,offset inter_handler
        stosw
        push cs
        pop ax
        stosw
        pop ax
no_winkey:
        test cs:mflag,1
        jz no_rregemul
        push ax
        mov al,026              ;es:
        stosb
        mov ax,06fe             ;inc b[]
        stosw
        mov ax,offset rr
        stosw
        pop ax
no_rregemul:
        test ax
        if nz dec ax
        mov cx,ax
        cmp ax,45
        jb norepblock
        sub ax,3                ;substract time for MOV BX,nn
        mov bx,ax
        mov al,0bb              ;mov bx,nn
        stosb
        mov ax,bx
        shr bx,1
        shr bx,1
        shr bx,1
        shr bx,1
        xor dx,dx
        div bx                  ;ax=# nops in block, bx=# blocks, dx=rest
        xchg ax,bx
        stosw
        sub bx,4
        mov al,090
        mov cx,bx
putnops:
        stosb
        loop putnops
        mov al,04b
        stosb
        mov al,075
        stosb
        mov ax,bx
        neg ax
        sub ax,3
        stosb
        mov cx,dx
norepblock:
        mov al,090
        jcxz >l1
        mov bx,di
        mov bl,0fa
putnops2:
        stosb
        cmp di,bx
        je >l1
        loop putnops2
l1:     mov ax,03d8a
        stosw
        mov ax,0e3ff
        stosw
        ret


movecommand:                    ;ds:si->opcode routine, es:di->destination,
        push di                 ; cx=length in bytes, al=T states, ah=time offset
        push cx
        rep movsb
        pop cx
        pop di
        push cx
        push di
mc_findjx:
        cmp es:w[di],03d8a
        jne mc_next
        cmp es:w[di+2],0e3ff
        jne mc_next
        push ax
        push cx
        push di
        push ax
        mov bx,offset slowmod-8
        xor ah,ah
        add ax,ax
        add bx,ax
        mov ax,cs:[bx]
        pop bx
        mov bl,bh
        xor bh,bh
        test byte cs:winkey,0ff
        if e sub ax,bx          ;Number of nops to wait. Now find an appropriate
        if b xor ax,ax          ; slowdown routine
        mov cx,20
        mov bx,offset slowmod
        mov dx,0ffff            ;best hit difference
        xor di,di               ;best hit
mc_findslowdown:
        push ax
        sub ax,cs:[bx]
        if s neg ax
        cmp dx,ax
        jb mc_badhit
        mov dx,ax
        mov di,bx
mc_badhit:
        pop ax
        inc bx
        inc bx
        loop mc_findslowdown
        cmp ax,dx                       ;if ax<dx, no wait
        if be mov di,offset slowmod-2   ;guaranteed to be 0
        test byte cs:debugflg,0ff
        jz mc_nodebug
        cmp di,offset slowmod-2
        if e mov di,offset slowmod
mc_nodebug:
        sub di,offset slowmod-8
        shr di,1
        mov ax,di
        pop di
        push di
        call slowdown_opcode
        pop di
        pop cx
        pop ax
        add di,7
        sub cx,7
mc_next:
        inc di
        dec cx
        if ne jmp mc_findjx
        pop di
        pop cx
        ret


get_cbaddrs:
        push ds
        mov ds,seg jx_table
        mov si,offset jx_table
        cld
get_cb_end:
        lodsw
        test ax
        jz got_cb_end
        inc si
        jmp get_cb_end
got_cb_end:
        dec si
        dec si
        push ds
        pop es
        mov di,si
        mov ds,seg emulate
        mov bx,02c
rreg_cb:
        cmp bh,64
        ja rreg_findjxf
        mov al,bh
        and al,7
        cmp al,6
        jz rregcb_next
rreg_findjxf:
        inc bx
        cmp w[bx],03d8a
        jne rreg_findjxf
        cmp w[bx+2],0e3ff
        jne rreg_findjxf
        mov ax,bx
        stosw
        mov al,bh
        and al,7
        cmp al,6                ;(hl)
        mov al,8
        jnz rreg_putt
        mov al,15
        cmp bh,64
        jb rreg_putt
        cmp bh,128
        jae rreg_putt
        mov al,12               ;bit n,(hl)
rreg_putt:
        stosb
rregcb_next:
        mov bl,02c
        inc bh
        jne rreg_cb
        xor ax,ax
        stosw
        stosb
        pop ds
        ret


breakhandler:
        call text_mode
        mov dx,cs:emshandle
        mov ah,045
        test dx,dx
        if nz int 067
        xor ax,ax
        mov es,ax
;        mov ax,cs:kstate
;        and ax,0f0
;        mov es:[0417],ax
        stc
        retf





;The following routine loads in the necessary roms from ROMS.BIN according
;to the mode setting ('128 or sam). The if1 rom is always loaded, whether or
;not it is used. Also, there is always enough memory available for the largest
;mode (128 mode).
;
load_romfile:
        PUSH CS
        POP DS
        mov ax,cs:romhandle
        test ax,ax
        jnz roms_found
        MOV DX,ROMS_FILENAME
        MOV AX,03D00
        INT 021
        JnC ROMS_FOUND
        call get_progpath
        push cs
        pop ds
        mov si,roms_filename
        mov cx,9
        rep movsb
        mov dx,offset specchars
        mov ax,03d00
        int 021
        if c jmp roms_not_found
roms_found:
        mov cs:romhandle,ax
        push ax
        mov dx,cs:emshandle
        test dx,dx
        jz lr_noems
        mov ax,04400            ;page logical 0-3 to physical 0-3
        xor bx,bx
        int 067
        mov ax,04401
        inc bx
        int 067
        mov ax,04402
        inc bx
        int 067
        mov ax,04403
        inc bx
        int 067
lr_noems:
        pop bx
        mov ax,04200
        xor cx,cx
        xor dx,dx
        int 021
        mov ds,cs:romseg                ;=specseg if ems used
        xor dx,dx                       ;space for normal rom
        mov cx,04000
        call load_romblock
        push cs
        pop es
        mov si,03c00
        mov di,offset specchars
        mov cx,1024
        cld
        rep movsb
        push bx
        mov bx,cs:xrhandle      ;Get possible handle of external romfile
        test bx
        jz no_ext_rom
        xor dx,dx
        mov cx,04001
        mov ah,03f
        int 021
        mov dx,romfile_nf
        if c jmp enderr
        cmp ax,04000
        if ne jmp enderr
        mov ax,04200
        xor cx,cx
        xor dx,dx
        int 021                 ;Move to start of file again.
no_ext_rom:
        pop bx
        mov dx,04000            ;Space for if1 rom (2 x same 8K)
        mov cx,02000
        call load_romblock
        mov ax,04201
        mov cx,0ffff
        mov dx,-02000
        int 021                 ;Load the 8K rom once again
        mov dx,06000
        mov cx,02000
        call load_romblock
        cmp cs:rommod,2
        jnz roms_nosam
        mov dx,08000            ;First and second samram rom
        mov cx,08000
        call load_romblock
        jmp short roms_init
roms_nosam:
        cmp cs:rommod,2
        jb roms_init
        mov ax,04201
        xor cx,cx
        mov dx,08000
        int 021                 ;Skip the two samram roms
        xor dx,dx               ;First '128 rom
        mov cx,04000
        call load_romblock
        mov dx,08000            ;Second '128 rom
        mov cx,04000
        call load_romblock
roms_init:                      ;romfile handle is not closed.
        mov dx,cs:emshandle
        test dx,dx
        jz lr_noems2
        xor bh,bh
        mov ax,04401
        mov bl,cs:b[offset ramstate+1]
        int 067
        mov ax,04402
        mov bl,cs:b[offset ramstate+2]
        int 067
        mov ax,04403
        mov bl,cs:b[offset ramstate+3]
        int 067
lr_noems2:
        mov cs:b[offset ramstate],0ff
        mov byte cs:actrom2,0ff
        mov ax,0                ;Normal rom at 0-3fff
        cmp byte cs:rommod,2
        if ae mov al,2          ;e: Samram rom 1; a: '128 rom 2
        call swap_mem
        mov al,0ff              ;see also: load_z80_file
        cmp byte cs:rommod,0    ;mode: norm (no if1)
        if z xor al,al
        cmp byte cs:rommod,3    ;mode: 128 (no if1)
        if z xor al,al
        mov byte cs:if1_on,al
        test al,al
        jz ret
        cmp byte cs:if1flg,0
        jz ret
        mov ax,1                ;Page if1 rom
        call swap_mem
        xor ax,ax
        ret



load_romblock:
        mov ah,03f
        int 021
        jc roms_not_found
        cmp ax,cx
        je ret
ROMS_NOT_FOUND:
        mov dx,rommes
        jmp enderr



;Puts the path to the .EXE file in a buffer (specchars). The DI register
;points to just after the path (ready to receive a filename).
;
get_progpath:
        mov ds,cs:progseg
        mov ax,[02c]
        mov es,ax
        xor bx,bx
find_progpath:
        cmp es:w[bx],0
        jz found_progpath
        inc bx
        jmp find_progpath
found_progpath:
        add bx,3
        mov si,bx
find_endpath:
        inc bx
        cmp es:b[bx],0
        jnz find_endpath
find_backslash:
        dec bx
        cmp bx,si
        jz no_backslash
        cmp es:b[bx],'\'
        jnz find_backslash
no_backslash:
        sub bx,si
        inc si
        mov cx,bx
        push es
        pop ds
        push cs
        pop es
        mov di,offset specchars
        cld
        rep movsb
        ret





startup ends
