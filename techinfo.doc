Sinclair ZX Spectrum Emulator 'Z80' v2.01a  -  20/5/93  -  by G.A. Lunter





5.  TECHNICAL INFORMATION


Contents:

    5.1   The Spectrum
    5.2   The Interface I
    5.3   The SamRam
    5.4   The Z80 microprocessor
    5.5   File formats





5.1  The Spectrum

    The Spectrum is at the hardware level a very simple machine.  There's
    the 16K ROM which occupies the lowest part of the address space, and 48K
    of RAM which fills up the rest.  An ULA which reads the lowest 6912
    bytes of RAM to display the screen, and contains the logic for just one
    I/O port completes the machine, from a software point of view at least.

    Every even I/O address will address the ULA, but to avoid problems with
    other I/O devices only port FE should be used.  If this port is written
    to, bits have the following meaning:


        Bit   7   6   5   4   3   2   1   0
            ┌───┬───┬───┬───┬───┬───┬───┬───┐
            │   │   │   │ E │ M │   Border  │
            └───┴───┴───┴───┴───┴───┴───┴───┘


    The lowest three bits specify the border colour; a zero in bit 3
    activates the MIC output, and a one in bit 4 activates the EAR output
    (which sounds the internal speaker).  The real Spectrum also activates
    the MIC when the ear is written to; the emulator doesn't.  This is no
    problem; MIC is only used for saving, and when saving the Spectrum never
    sounds the internal speaker.  The upper three bits are unused.

    If port FE is read from, the highest eight address lines are important
    too.  A zero on one of these lines selects a particular half-row of five
    keys:

      IN:    Reads keys (bit 0 to bit 4 inclusive)

      #FEFE  SHIFT, Z, X, C, V            #EFFE  0, 9, 8, 7, 6
      #FDFE  A, S, D, F, G                #DFFE  P, O, I, U, Y
      #FBFE  Q, W, E, R, T                #BFFE  ENTER, L, K, J, H
      #F7FE  1, 2, 3, 4, 5                #7FFE  SPACE, SYM SHFT, M, N,

    A zero in one of the five lowest bits means that the corresponding key
    is being pressed.  If more than one address line is made low, the result
    is the logical AND of all single inputs, so a zero in a bit means that
    at least one of the appropriate keys is pressed.  For example, only if
    each of the five lowest bits of the result from reading from port 00FE
    (for instance by XOR A/IN A,(FE)) is one, no key is pressed.

    A final remark about the keyboard.  It is connected in a matrix-like
    fashion, with 8 rows of 5 columns, as is obvious from the above remarks.
    Any two keys pressed simultaneously can be uniquely decoded by reading
    from the IN ports, however, if more than two keys are pressed decoding
    may not be uniquely possible.  For instance, if you press Caps shift, B
    and V, the Spectrum will think also the Space key is pressed, and react
    by giving the 'Break into Program' report.  This matrix behaviour is
    also emulated - without it, Zynaps for instance won't pause when you
    press 5,6,7,8 and 0 simultaneously.

    Bit 5 (value 64) of IN-port FE is the ear input bit.  When the line is
    silent, its value is zero, except in the early Model 2 of the Spectrum,
    where it was one.  When there is a signal, this bit toggles.  The
    Spectrum loading software is not sensitive to the polarity of this bit
    (which it definitely should not be, not only because of this model
    difference, but also because you cannot be sure the tape recorder
    doesn't change the polarity of the signal recorded!) Some old programs
    rely on the fact that bit 5 is always one (for instance Spinads); for
    these programs the emulator can mimic a Model 2 Spectrum.

    Bits 6 and 7 are always one.

    The ULA with the lower 16K of RAM, and the processor with the upper 32K
    RAM and 16K ROM are working independently of each other.  The data and
    address buses of the Z80 and the ULA are connected by small resistors;
    normally, these do effectively decouple the buses.  However, if the Z80
    wants to read of write the lower 16K, the ULA halts the processor if it
    is busy reading, and after it's finished it lets the processor access
    lower memory through the resistors.  A very fast, cheap and neat design
    indeed!

    If you run a program in the lower 16K of RAM, or read or write in that
    memory, the processor is halted sometimes.  This part of memory is
    therefore somewhat slower than the upper 32K block.  This is also the
    reason that you cannot write a sound- or save-routine in lower memory;
    the timing won't be exact, and the music will sound harsh.  Also, INning
    from port FE will halt the processor, because the ULA has to supply the
    result.  Therefore, INning from port FE is a tiny bit slower on average
    than INning from other ports; whilst normally an IN A,(nn) instruction
    would take 11 T states, it takes 12.15 T states on average if nn=FE. See
    below for more exact information.

    If the processor reads from a non-existing IN port, for instance FF, the
    ULA won't stop, but nothing will put anything on the data bus.
    Therefore, you'll read a mixture of FF's (idle bus), and screen and ATTR
    data bytes (the latter being very scarce, by the way).  This will only
    happen when the ULA is reading the screen memory, about 60% of the
    1/50th second time slice in which a frame is generated.  The other 40%
    the ULA is building the border or generating a vertical retrace.  This
    behaviour is actually used in some program, for instance by Arkanoid,
    and the emulator also emulates this behaviour.

    Finally, there is an interesting bug in the ULA which also has to do
    with this split bus.  After each instruction fetch cycle of the
    processor, the processor puts the I-R register 'pair' (not the 8 bit
    internal Instruction Register, but the Interrupt and R registers) on the
    address bus.  The lowest 7 bits, the R register, are used for memory
    refresh.  However, the ULA gets confused if I is in the range 64-127,
    because it thinks the processor wants to read from lower 16K ram very,
    very often.  The ULA can't cope with this read-frequency, and regularly
    misses a screen byte.  Instead of the actual byte, the byte previously
    read is used to build up the video signal.  The screen seems to be
    filled with 'snow'; however, the Spectrum won't crash, and program will
    continue to run normally.  There's one program I know of that uses this
    to generate a nice effect: Vectron.  (which has very nice music too by
    the way).  This effect has not been implemented however - it's a bit
    useless (but maybe I'll include it in the future).

    The processor has three interrupt modes, selected by the instructions IM
    0, IM 1 and IM 2.  In mode 1, the processor simply executes a RST #38
    instruction if an interrupt is requested.  This is the mode the Spectrum
    is normally in.  The other mode that is commonly used is IM 2.  If an
    interrupt is requested, the processor first builds a 16 bit address by
    combining the I register (as the high byte) with whatever the
    interrupting device places on the data bus.  The word at this address is
    then called.  Rodnay Zaks in his book 'Programming the Z80' states that
    only even bytes are allowed as low index byte, but that isn't true.  The
    normal Spectrum contains no hardware to place a byte on the bus, and the
    bus will therefore always read FF (because the ULA also doesn't read the
    screen if it generates an interrupt), so the resulting index address is
    256*I+0FF.  However, some not-so-neat hardware devices put things on the
    data bus when they shouldn't, so later programs didn't assume the low
    index byte was 0FF.  These programs contain a 257 byte table of equal
    bytes starting at 256*I, and the interrupt routine is placed at an
    address that is a multiple of 257.  A useful but not so much used trick
    is to make the table contain FF's (or use the ROM for this) and put a
    byte 18 hex, the opcode for JR, at FFFF.  The first byte of the ROM is a
    DI, F3 hex, so the JR will jump to FFF4, where a long JP to the actual
    interrupt routine is put.

    In interrupt mode 0, the processor executes the instruction that the
    interrupting device places on the data bus.  On a standard Spectrum this
    will be the byte FF, coincidentally (...) the opcode for RST #38. But
    for the same reasons as above, this is not really reliable.

    The 50 Hz interrupt is synchronized with the video signal generation by
    the ULA; both the interrupt and the video signal are generated by it.
    Many programs use the interrupt to synchronize with the frame cycle.
    Some use it to generate fantastic effects, such as full-screen
    characters, full-screen horizon (Aquaplane) or pixel colour (Uridium for
    instance).  Very many modern programs use the fact that the screen is
    'written' (or 'fired') to the CRT in a finite time to do as much
    time-consuming screen calculations as possible without causing character
    flickering:  although the ULA has started displaying the screen for this
    frame already, the electron beam will for a moment not 'pass'
    this-or-that part of the screen so it's safe to change something there.
    So the exact time in the 1/50 second time-slice at which the screen is
    updated is very important.  Because the emulator updates the screen at
    once, no single best solution can be given, and therefore the user can
    select one of three possibilities (low, normal or high video
    synchronisation, corresponding to a screen update after 1/200, 2/200 or
    3/200 of a (relative) second after a Z80 interrupt) which gives the best
    results.  Try for instance Zynaps; with normal video synchronisation the
    top four or five lines of the background move out-of-phase with the
    rest, and your space-ship flickers in that region.  With low video
    synchronisation the background moves smoothly but the sprites flicker in
    all parts of the screen.  Only with high video sync everything moves
    smoothly and doesn't flicker.

    This emulator does not try to emulate the really time-critical border
    pattern effects (except when loading, but the width of the loading
    stripes are not quite right because also PC video timings come into
    play), but maybe I'll include it in the future.  I will need some hard
    data on video timings then, and I've figured these out recently.  Here
    they are.

    Each line takes exactly 224 T states.  After an interrupt occurs, 64
    line times pass before the byte 16384 is displayed.  At least the last
    48 of these are actual border-lines.  I could not determine whether my
    monitor didn't display the others or whether it was in vertical retrace,
    but luckily that's not really important.  Then the 192 screen+border
    lines are displayed, followed by about 56 border lines again.  56.5
    border lines would make up exactly 70000 T states, 1/50th of 3500000.
    However, I noticed that the frequency of the 50 Hz interrupt (measured
    in 1/T states!) changes very slightly when my Spectrum gets hot (I think
    it has something to do with the relative change of the frequencies of
    the two crystals in the Spectrum), so the time between interrupts will
    probably not be exactly 70000 T states. Anyway, whether the final border
    block is of fixed or variable length doesn't concern us either, the
    timings of the start and end of the screen, which are the timings of
    real interest, are fixed.

    Now for the timings of each line itself.  I define a screen line to
    start with 256 screen pixels, then border, then horizontal retrace, and
    then border again.  All this takes 224 T states.  Every half T state a
    pixel is written to the CRT, so if the ULA is reading bytes it does so
    each 4 T states (and then it reads two: a screen and an ATTR byte).  The
    border is 48 pixels wide at each side.  A video screen line is therefore
    timed as follows: 128 T states of screen, 24 T states of right border,
    48 T states of horizontal retrace and 24 T states of left border.

    When an interrupt occurs, the running instruction has to be completed
    first.  So the start of the interrupt is fixed relative to the start of
    the frame up to the length of the last instruction in T states.  If the
    processor was executing a HALT (which, according to the Z80 books I
    read, is effectively many NOPs), the interrupt routine starts at most 3
    T states away from the start of the frame.  Of course the processor also
    needs some T states to store the program counter on the stack, read the
    interrupt vector and jump to the routine, but since I cannot determine
    that by only using the Spectrum, it is useless information by that very
    reason alone!

    Now when to OUT to the border to change it at the place you want? First
    of all, you cannot change the border within a 'byte', an 8-pixel chunk.
    If we forget about the screen for a moment, if you OUT to port FE after
    14326 to 14329 T states (including the OUT) from the start of the IM 2
    interrupt routine, the border will change at exactly the position of
    byte 16384 of the screen.  The other positions can be computed by
    remembering that 8 pixels take 4 T states, and a line takes 224 T
    states.  You would think that OUTing after 14322 to 14325 T states, the
    border would change at 8 pixels left of the upper left corner of the
    screen.  This is right for 14322, 14323 and 14324 T states, but if you
    wait 14325 T states the ULA happens to be reading byte 16384 (or 22528,
    or both) and will halt the processor for a while, thereby making you
    miss the 8 pixels.  This exception happens again after 224 T states, and
    again after 448, an so forth.  These 192 exceptions left of the actual
    screen rectangle are the only ones; similar things don't happen at the
    right edge because the ULA don't need to read things there - it has just
    finished!

    As noted above, reading or writing in low ram (or OUTing to the ULA)
    causes the ULA to halt the processor.  When and how much? The processor
    is halted each time you want to access the ULA or low memory and the ULA
    is busy reading.  Of the 312.5 'lines' the ULA generates, only 192
    contain actual screen pixels, and the ULA will only read bytes during
    128 of the 224 T states of each screen line.  But if it does, the
    processor is halted for exactly 4 T states.



5.2  The Interface I

    The Interface I is quite complicated.  It uses three different I/O
    ports, and contains logic to page and unpage an 8K ROM if new commands
    are used.  I won't be very detailed here; you could refer to the source
    code of the emulator if you want to know some details, or read the
    'Spectrum Shadow ROM Disassembly' by Gianlura Carri, published by
    Melbourne House - but don't expect the same level of detail as of Ian
    Logan and Frank O'Hara in their Rom disassembly book.

    The ROM is paged if the processor executes the instruction at ROM
    address 0008 or 1708 hexadecimal, the error and close# routines.  It is
    inactivated when the Z80 executes the RET at address 0700.

    I/O Port E7 is used to send or receive data to and from the microdrive.
    Accessing this port will halt the Z80 until the Interface I has
    collected 8 bits from the microdrive head; therefore, it the microdrive
    motor isn't running, or there is no formatted cartridge in the
    microdrive, the Spectrum hangs.  This is the famous 'IN 0 crash'.

    Port EF is used for several things:


       Bit    7   6    5    4    3    2    1     0
            ┌───┬───┬────┬────┬─────┬───┬─────┬─────┐
        READ│   │   │    │busy│ dtr │gap│ sync│write│
            │   │   │    │    │     │   │     │prot.│
            ├───┼───┼────┼────┼─────┼───┼─────┼─────┤
       WRITE│   │   │wait│ cts│erase│r/w│comms│comms│
            │   │   │    │    │     │   │ clk │ data│
            └───┴───┴────┴────┴─────┴───┴─────┴─────┘


    Bits DTR and CTS are used by the RS232 interface.  The WAIT bit is used
    by the Network to synchronise, GAP, SYNC, WR_PROT, ERASE, R/_W, COMMS
    CLK and COMMS DATA are used by the microdrive system.  If the microdrive
    is not being used, the COMMS DATA output selects the function of bit 0
    of out-port F7:


       Bit      7    6   5   4   3   2   1       0
            ┌──────┬───┬───┬───┬───┬───┬───┬───────────┐
        READ│txdata│   │   │   │   │   │   │    net    │
            │      │   │   │   │   │   │   │   input   │
            ├──────┼───┼───┼───┼───┼───┼───┼───────────┤
       WRITE│      │   │   │   │   │   │   │net output/│
            │      │   │   │   │   │   │   │   rxdata  │
            └──────┴───┴───┴───┴───┴───┴───┴───────────┘


    TXDATA and RXDATA are the input and output of the RS232 port.  COMMS
    DATA determines whether bit 0 of F7 is output for the RS232 or the
    network.



5.3  The SamRam

    The SamRam contains a 32K static CMOS Ram chip, and some I/O logic for
    port 31.  If this port is read, it returns the position of the joystick,
    as a normal Kempston joystickinterface would.  If written to, the port
    controls a programmable latch chip (the 74LS259) which contains 8
    latches:


       Bit    7   6   5   4   3   2   1   0
            ┌───┬───┬───┬───┬───┬───┬───┬───┐
       WRITE│   │   │   │   │  address  │bit│
            └───┴───┴───┴───┴───┴───┴───┴───┘


    The address selects on of the eight latches; bit 0 is the new state of
    the latch.  The 16 different possibilities are collected in the diagram
    below:

        OUT 31,   │  Latch  │ Result
        ──────────┼─────────┼────────────────────────────────────────
            0     │    0    │ Switch on write protect of CMOS RAM
            1     │    "    │ Writes to CMOS RAM allowed
            2     │    1    │ turn on CMOS RAM (see also 6/7)
            3     │    "    │ turn off CMOS RAM (standard Spec.  ROM)
            4     │    2    │ -
            5     │    "    │ Ignore all OUT's to 31 hereafter
            6     │    3    │ Select CMOS bank 0 (Basic ROM)
            7     │    "    │ Select CMOS bank 1 (Monitor,...)
            8     │    4    │ Select interface 1
            9     │    "    │ Turn off IF 1 (IF1 rom won't be paged)
           10     │    5    │ Select 32K ram bank 0 (32768-65535)
           11     │    "    │ Select 32K ram bank 1 (32768-65535)
           12     │    6    │ Turn off beeper
           13     │    "    │ Turn on beeper
           14     │    7    │ -
           15     │    "    │ -

    At reset, all latches are 0.  If an OUT 31,5 is issued, only a reset
    will give you control over the latches again.  The write protect latch
    is not emulated; you're never able to write the emulated CMOS ram in the
    emulator.  Latch 4 will pull up the M1 output of the Z80.  The Interface
    I won't page the ROM anymore then.



5.4  The Z80 microprocessor

    The Z80 processor is quite straightforward, and contains to my knowledge
    no interesting bugs or quirks.  However, it has some undocumented
    features.  Some of these are quite useful, and some are not, but since
    many programs use the useful ones, and a few programs use the weird
    ones, I tried to figure them out and emulate them as best as I could.
    There is a Z80 emulator around, intended as a CP/M emulator, which halts
    the program if an undocumented opcode is encountered.  I don't think
    this makes sense.  ZiLOG doesn't dictate the law, the programs which use
    the processor's features do!

    Most Z80 opcodes are one byte long, not counting a possible byte or word
    operand.  The four opcodes CB, DD, ED and FD are shift opcodes: they
    change the meaning of the opcode following them.

    There are 248 different CB opcodes.  The block CB 30 to CB 37 is missing
    from the official list.  These instructions, usually denoted by the
    mnemonic SLL, Shift Left Logical, shift left the operand and make bit 0
    always one.  Bounder and Enduro Racer use them.  The SamRam monitor can
    disassemble these and uses the mnemonic SLL.  These instructions are
    quite commonly used.

    The DD and FD opcodes precede instructions using the IX and IY
    registers.  If you look at the instructions carefully, you see how they
    work:

        2A nn           LD HL,(nn)
        DD 2A nn        LD IX,(nn)
        7E              LD A,(HL)
        DD 7E d         LD A,(IX+d)

    A DD opcode simply changes the meaning of HL in the next instruction.
    If a memory byte is addressed indirectly via HL, as in the second
    example, a displacement byte is added.  Otherwise the instruction simply
    acts on IX instead of HL.  (A notational awkwardness, that will only
    bother assembler and disassembler writers: JP (HL) is not indirect; it
    should have been denoted by JP HL) If a DD opcode precedes an
    instruction that doesn't use the HL register pair at all, the
    instruction is executed as usual.  However, if the instruction uses the
    H or L register, it will now use the high or low halves of the IX
    register! Example:

        44              LD B,H
        FD 44           LD B,IYh

    These types of inofficial instructions are used by very many programs.
    By the way, many DD or FD opcodes after each other will effectively be
    NOPs, doing nothing except repeatedly setting the flag 'treat HL as IX'
    (or IY) and taking up 4 T states.  (But try to let MONS disassemble such
    a block.)

    I've never seen a program using inofficial ED instructions, and except
    for ED 6B nn, a long version of 2A nn, LD HL,(nn) I don't know any.  I
    am pretty sure however that they exist, but I never took the trouble to
    test them all.

    About the R register.  This is not really an undocumented feature,
    although I have never seen any thorough description of it anywhere.  The
    R register is a counter that is updated every instruction, where DD, FD,
    ED and CB are to be regarded as separate instructions.  So shifted
    instruction will increase R by two.  There's an interesting exception:
    doubly-shifted opcodes, the DDCB and FDCB ones, increase R by two too.
    LDI increases R by two, LDIR increases it by 2 times BC, as does LDDR
    etcetera.  The sequence LD R,A / LD A,R increases A by two, except for
    the highest bit: this bit of the R register is never changed.  This is
    because in the old days everyone used 16 Kbit chips.  Inside the chip
    the bits where grouped in a 128x128 matrix, needing a 7 bit refresh
    cycle.  Therefore ZiLOG decided to count only the lowest 7 bits. Anyway,
    if the R register emulation is switched on the R register will behave as
    is does on a real Spectrum; if it is off it will (except for the upper
    bit) act as a random generator.

    You can easily check that the R register is really crucial to memory
    refresh.  Assemble this program:

        ORG 32768
        DI
        LD B,0
    L1  XOR A
        LD R,A
        DEC HL
        LD A,H
        OR L
        JR NZ,L1
        DJNZ L1
        EI
        RET

    It will take about three minutes to run.  Look at the upper 32K of
    memory, for instance the UDG graphics.  It will have faded.  Only the
    first few bytes of each 256 byte block will still contain zeros, because
    they were refreshed during the execution of the loop.  The ULA took care
    of the refreshing of the lower 16K.  (This example won't work on the
    emulator of course!)

    Then there's one other dark corner of the Z80 which has its effect on
    programs like Sabre Wulf, Ghosts'n Goblins and Speedlock.  The Mystery
    of the Undocumented Flags!

    Bit 3 and 5 of the F register are not used.  They can contain
    information, as you can readily figure out by using PUSH AF and POP AF.
    Furthermore, sometimes their values change.  I found the following
    empirical rule:

        The values of bit 7, 5 and 3 follow the values of the
        corresponding bits of the last 8 bit result of an instruction
        that changed the usual flags.

    For instance, after an ADD A,B those bits will be identical to the bits
    of the A register.  (Bit 7 of F is the sign flag, and fits the rule
    exactly).  An exception is the CP x instruction (x=register, (HL) or
    direct argument).  In that case the bits are copied from the argument.

    If the instruction is one that operates on a 16 bit word, the 8 bits of
    the rule are the highest 8 bits of the 16 bit result - that was to be
    expected since the S flag is extracted from bit 15.

    Ghosts'n Goblins use the undocumented flag due to a programming error.
    The rhino in Sabre Wulf walks backward or keeps running in little
    circles in a corner, if the (in this case undocumented) behaviour of the
    sign flag in the BIT instruction isn't right.  I quote:

        AD86    DD CB 06 7E        BIT 7,(IX+6)
        AD89    F2 8F AD           JP P,#AD8F

    An amazing piece of code! Speedlock does so many weird things that all
    must be exactly right for it to run.  Finally, the '128 rom uses the AF
    register to hold the return address of a subroutine for a while.  To
    keep all programs happy, and still have a fast emulator, I had to make a
    compromise.  The undocumented flags are not always emulated right, but
    they are most of the time.

    Finally, a remark about the interrupt flip flops IFF1 and IFF2.  There
    seems to be a little confusion about these.  These flip flops are
    simultaneously set or reset by the EI and DI instructions.  IFF1
    determines whether interrupts are allowed, but its value cannot be read.
    The value of IFF2 is copied to the P/V flag by LD A,I and LD A,R.  When
    an NMI occurs, IFF1 is reset, thereby disallowing further (maskable)
    interrupts, but IFF2 is left unchanged.  This enables the NMI service
    routine to check whether the interrupted program had enabled or disabled
    maskable interrupts.  So, Spectrum snapshot software can only read IFF2,
    but most emulators will emulate both, and then the one that matters most
    is IFF1.

    Now for the emulated Z80.  I have added eight instructions, to speed up
    the RS232 input and output of the Interface I and several things of the
    SamRam.  These opcodes, ED F8 to ED FE are of little use to any other
    program.  ED FF is a nice one: it returns you to DOS immediately.  I
    used it for debugging purposes.



5.5  File formats

    This sections describes the formats of the files used by the emulator.


    ROMS.BIN:
    ---------

        00000-03fff     Ordinary Spectrum rom
        04000-05fff     Interface I rom (8K)
        06000-09fff     First SamRam rom (contains BASIC)
        0a000-0dfff     Second SamRam rom (contains monitor,...)
        0e000-11fff     First Spectrum 128K rom (active at RESET)
        12000-15fff     Second Spectrum 128K rom (contains BASIC)

    The ordinary rom has not been modified.  The Interface I rom has
    undergone some modifications, to speed up the RS232 input/output
    routines.  If you don't like this, or want to use another version of the
    Interface I, you could put that code at the right place in the ROMS.BIN
    file.  The interface I should work properly, although the RS232 will be
    slower (always FORMAT the "b" or "t" channel at 19200 baud, by the way,
    if you replace the rom code, there's no point in waiting for nothing!)
    The microdrive routines have not been modified in any way.  Here are the
    changes of the Interface I rom:

        Address: Old: New:           Address: Old: New:

        0B9E     ED   ED             0D20     FB   00
        0B9F     5B   FC             0D2A     37   ED
        0BA0     C3   F5             0D2B     F3   FD
        0BA1     5C   C3             0D2C     CE   18
        0BA2     21   34             0D2D     00   10
        0BA3     20   0C             0D4C     FB   00

    These changes are not likely to cause problems; there are several
    versions of the Interface I rom around, and program developers know
    this.  It is also a bit pointless to check whether the Interface I rom
    hasn't been modified; who would put his snapshot software in there
    anyway, and that's what those people are afraid of.

    The first and second SamRam rom have been modified more extensively. The
    biggest problem was that switching the upper 32K ram bank is very fast
    in reality, but on the PC two blocks of 32K bytes had to be REP
    MOVSWded.  But since no programs know of the SamRam code anyway, this
    won't cause any more problems it wouldn't already cause either.

    The two Spectrum 128 roms have not been modified.


    .TAP FILES:
    -----------

    The .TAP files contain blocks of tape-saved data.  All blocks start with
    two bytes specifying how many bytes will follow (not counting the two
    length bytes).  Then raw tape data follows, including the flag and
    checksum bytes.  The checksum is the bitwise XOR of all bytes including
    the flag byte.  For example, when you execute the line SAVE "ROM" CODE
    0,2 this will result:


             |------ Spectrum-generated data -------|       |---------|
       13 00 00 03 52 4f 4d 7x20 02 00 00 00 00 80 f1 04 00 ff f3 af a3

       ^^^^^       first block is 19 bytes (17 bytes+flag+checksum)
             ^^    flag byte (A reg, 00 for headers, ff for datablocks)
                ^^ first byte of header, indicating a code block

       filename    ^^^^^^^^^^^^^
       header info               ^^^^^^^^^^^^^^^^^
       checksum of header                          ^^
       length of second block                         ^^^^^
       flag byte                                             ^^
       first two bytes of rom                                  ^^^^^
       checksum (checkbittoggle would be better)                     ^^


    The emulator will always start reading bytes at the beginning of a
    block.  If less bytes are loaded than are available, the other bytes are
    skipped, and the last byte loaded is used as checksum.  If more bytes
    are asked for than exist in the block, the loading routine will
    terminate with the usual tape-loading-error flags set, leaving the error
    handling to the calling Z80 program.

    Note that it is possible to join .TAP files by simply stringing them
    together, for example COPY /B FILE1.TAP + FILE2.TAP ALL.TAP

    For completeness, I'll include the structure of a tape header.  A header
    always consists of 17 bytes:

        Byte    Length  Description
        0       1       Type (0,1,2 or 3)
        1       10      Filename (padded with blanks)
        11      2       Length of data block
        13      2       Parameter 1
        15      2       Parameter 2

    The type is 0,1,2 or 3 for a Program, Number array, Character array or
    Code file.  A screen$ file is regarded as a Code file with start address
    16384 and length 6912 decimal.  If the file is a Program file, parameter
    1 holds the autostart line number (or a number >=32768 if no LINE
    parameter was given) and parameter 2 holds the start of the variable
    area relative to the start of the program.  If it's a Code file,
    parameter 1 holds the start of the code block when saved, and parameter
    2 holds 32768.  For data files finally, the byte at position 14 decimal
    holds the variable name.


    .MDR FILES:
    -----------

    The emulator uses a cartridge file format identical to the 'Microdrive
    File' format of Carlo Delhez' Spectrum emulator Spectator for the QL.
    The following information is adapted from Carlo's documentation.  It can
    also be found in the 'Spectrum Microdrive Book', by Ian Logan (co-writer
    of the excellent 'Complete Spectrum ROM Disassembly').

    A cartridge file contains 254 'sectors' of 543 bytes each, and a final
    byte flag which is non-zero is the cartridge is write protected, so the
    total length is 137923 bytes.  On the cartridge tape, after a GAP of
    some time the Interface I writes 10 zeros and 2 FF bytes (the preamble),
    and then a fifteen byte header-block-with-checksum.  After another GAP,
    it writes a preamble again, with a 15-byte record-
    descriptor-with-checksum (which has a structure very much like the
    header block), immediately followed by the data block of 512 bytes, and
    a final checksum of those 512 bytes.  The preamble is used by the
    Interface I hardware to synchronise, and is not explicitly used by the
    software.  The preamble is not saved to the microdrive file:

    offset length name    contents

      0      1   HDFLAG   Value 1, to indicate header block
      1      1   HDNUMB   sector number (values 254 down to 1)
      2      2            not used
      4     10   HDNAME   microdrive cartridge name (blank padded)
     14      1   HDCHK    header checksum (of first 14 bytes)

     15      1   RECFLG   - bit 0: always 0 to indicate record block
                          - bit 1: set for the EOF block
                          - bit 2: reset for a PRINT file
                          - bits 3-7: not used (value 0)
     16      1   RECNUM   data block sequence number (value starts at 0)
     17      2   RECLEN   data block length (<=512, LSB first)
     19     10   RECNAM   filename (blank padded)
     29      1   DESCHK   record descriptor checksum (of previous 14 bytes)
     30    512            data block
    542      1   DCHK     data block checksum (of all 512 bytes of data
                           block, even when not all bytes are used)
    ---------
    254 times


    (Actually, this information is 'transparent' to the emulator.  All it
    does is store 2 times 254 blocks in the .MDR file as it is OUTed,
    alternatingly of length 15 and 528 bytes.  The emulator does check
    checksums, see below; the other fields are dealt with by the emulated
    Interface I software.)

    A used record block is either an EOF block (bit 1 of RECFLG is 1) or
    contains 512 bytes of data (RECLEN=512, i.e.  bit 1 of MSB is 1).  An
    empty record block has a zero in bit 1 of RECFLG and also RECLEN=0.  An
    unusable block (as determined by the FORMAT command) is an EOF block
    with RECLEN=0.

    The three checksums are calculated by adding all the bytes together
    modulo 255; this will never produce a checksum of 255.  Possibly, this
    is the value that is read by the Interface I if there's no or bad data
    on the tape.

    In normal operation, all first-fifteen-byte blocks of each header or
    record block will have the right checksum.  If the checksum is not
    right, the block will be treated as a GAP.  For instance, if you type
    OUT 239,0 on a normal Spectrum with interface I, the microdrive motor
    starts running and the cartridge will be erased completely in 7 seconds.
    CAT 1 will respond with 'microdrive not ready'.  Try it on the
    emulator...


    .SCR FILES:
    -----------

    .SCR files are memory dumps of the first 6912 bytes of the Spectrum
    memory.  A coordinate (x,y), x between 0 and 255 and y between 0 and
    192, (0,0) being the upper left corner of the screen, corresponds to the
    pixel address

        16384+INT (x/8)+1792*INT (y/64)-2016*INT (y/8)+256*y

    I admit this is not quite the clearest way to explain the organization
    of Spectrum's video memory, but with a bit or (hard) thinking you can
    extract from above formula all information you need...  The lowest three
    bits of x determine which bit of this address corresponds to the pixel
    (x,y).  This bit-map constitutes the larger part of the screen memory,
    256*192/8=6144 bytes.  The final 768 bytes are attribute bytes.  The
    address of the attribute byte corresponding to pixel (x,y) is

        22528+INT (x/8)+32*INT (y/8)

    The lowest three bits of the attribute byte control the foreground color
    (the color of the pixel if the corresponding bit in the bitmap is set),
    bits 3-5 control the background color, bit 6 is the bright bit and bit 7
    is the flash bit - if it is set, every 16/50th of a second the ULA
    effectively flips the foreground and background colours.



    .Z80 FILES:
    -----------

    The old .Z80 snapshot format (for version 1.45 and below) looks like
    this:

        Byte    Length  Description
        0       1       A register
        1       1       F register
        2       2       BC register pair (LSB, i.e.  C, first)
        4       2       HL register pair
        6       2       Program counter
        8       2       Stack pointer
        10      1       Interrupt register
        11      1       Refresh register (Bit 7 is not significant!)
        12      1       Bit 0  : Bit 7 of the R-register
                        Bit 1-3: Border colour
                        Bit 4  : 1=Basic SamRom switched in
                        Bit 5  : 1=Block of data is compressed
                        Bit 6-7: No meaning
        13      2       DE register pair
        15      2       BC' register pair
        17      2       DE' register pair
        19      2       HL' register pair
        21      1       A' register
        22      1       F' register
        23      2       IY register (Again LSB first)
        25      2       IX register
        27      1       Interrupt flipflop, 0=DI, otherwise EI
        28      1       IFF2 (not particularly important...)
        29      1       Bit 0-1: Interrupt mode (0, 1 or 2)
                        Bit 2  : 1=Issue 2 emulation
                        Bit 3  : 1=Double interrupt frequency
                        Bit 4-5: 1=High video synchronisation
                                 3=Low video synchronisation
                                 0,2=Normal
                        Bit 6-7: 0=Cursor/Protek/AGF joystick
                                 1=Kempston joystick
                                 2=Sinclair 1 joystick
                                 3=Sinclair 2 joystick

    Because of compatibility, if byte 12 is 255, it has to be regarded as
    being 1.  After this header block of 30 bytes the 48K bytes of Spectrum
    memory follows in a compressed format (if bit 5 of byte 12 is one). The
    compression method is very simple: it replaces repetitions of at least
    five equal bytes by a four-byte code ED ED xx yy, which stands for "byte
    yy repeated xx times".  Only sequences of length at least 5 are coded.
    The exception is sequences consisting of ED's; if they are encountered,
    even two ED's are encoded into ED ED 02 ED.  Finally, every byte
    directly following a single ED is not taken into a block, for example
    ED 6*00 is not encoded into ED ED ED 06 00 but into ED 00 ED ED 05 00.
    The block is terminated by an end marker, 00 ED ED 00.

    That's the format of .Z80 files as used by versions up to 1.45.  Since
    starting from version 2.0 the program emulates the Spectrum 128 too,
    there was a need for a new format.

    The first 30 bytes are almost the same as the old versions' header.  Of
    the flag byte, bit 4 and 5 have got no meaning anymore, and the program
    counter (bytes 6 and 7) are zero to signal a version 2.0 .Z80 file.  So
    loading a new style .Z80 file into an old emulator will cause an error
    or a reset at the most.

    After the first 30 bytes, an additional header follows:

        Byte    Length  Description
        30      2       Length of additional header block (contains 23)
        32      2       Program counter
        34      1       Hardware mode: 0=Spectrum 48K, 1=0+interface I,
                        2=SamRam, 3=Spectrum 128K, 4=3+interface I.
        35      1       If in SamRam mode, bitwise state of 74ls259.
                        For example, bit 6=1 after an OUT 31,13 (=2*6+1)
                        If in 128 mode, contains last OUT to 7ffd
        36      1       Contains 0FF if Interface I rom paged
        37      1       Bit 0: 1 if R register emulation on
                        Bit 1: 1 if LDIR emulation on
        38      1       Last OUT to fffd (soundchip register number)
        39      16      Contents of the sound chip registers

    Hereafter a number of memory blocks follow, each containing the
    compressed data of a 16K block.  The compression is according to the old
    scheme, except for the end-marker, which is now absent.  The structure
    of a memory block is:

        Byte    Length  Description
        0       2       Length of data (without this 3-byte header)
        2       1       Page number of block
        3       [0]     Compressed data

    The pages are numbered, depending on the hardware mode, in the following
    way:

        Page    In '48 mode     In '128 mode    In SamRam mode

         0      48K rom         rom (basic)     48K rom
         1      Interf. I rom   Interf. I rom   Interf. I rom
         2      -               rom (reset)     samram rom (basic)
         3      -               page 0          samram rom (monitor,..)
         4      8000-bfff       page 1          Normal 8000-bfff
         5      c000-ffff       page 2          Normal c000-ffff
         6      -               page 3          Shadow 8000-bfff
         7      -               page 4          Shadow c000-ffff
         8      4000-7fff       page 5          4000-7fff
         9      -               page 6          -
        10      -               page 7          -

    In 48K mode, pages 4,5 and 8 are saved.  In SamRam mode, pages 4 to 8
    are saved.  In 128 mode, all pages from 3 to 10 are saved.  This
    version saves the pages in numerical order.  There is no end marker.
    end marker.



